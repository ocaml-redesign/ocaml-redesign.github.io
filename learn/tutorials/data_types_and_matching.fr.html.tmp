<h1 id="Typesdedonnesetfiltragedemotif"> Types de données et filtrage de motif</h1><h2 id="Listeschanes"> Listes chaînées</h2><p>

Comme en Perl, la notion de liste est directement supportée dans le
langage OCaml. En OCaml, tous les éléments d&apos;une liste doivent avoir le
même type. Une liste s&apos;écrit :</p>
<pre><code class='ocaml'><span class='o'>[</span>1<span class='o'>;</span> 2<span class='o'>;</span> 3<span class='o'>]</span>
</code></pre>
<p>
(Remarquez l&apos;utilisation de points-virgules, et non de virgules).</p>
<p><code>[]</code> est la liste vide.</p>
<p>Une liste a une <strong>tête</strong> (le premier élément) et une <strong>queue</strong> (les
autres éléments). La tête est un élément, la queue est une liste, donc
dans cet exemple la tête est l&apos;entier <code>1</code> alors que la queue est la
<em>liste</em> <code>[2; 3]</code>.</p>
<p>Une autre façon d&apos;écrire une liste est d&apos;utiliser l&apos;opérateur <strong>cons</strong>
<code>tête :: queue</code>. Toutes les expressions suivantes sont donc équivalentes
:</p>
<pre><code class='ocaml'><span class='o'>[</span>1<span class='o'>;</span> 2<span class='o'>;</span> 3<span class='o'>]</span>
1 <span class='o'>::</span> <span class='o'>[</span>2<span class='o'>;</span> 3<span class='o'>]</span>
1 <span class='o'>::</span> 2 <span class='o'>::</span> <span class='o'>[</span>3<span class='o'>]</span>
1 <span class='o'>::</span> 2 <span class='o'>::</span> 3 <span class='o'>::</span> <span class='o'>[</span><span class='o'>]</span>
</code></pre>
<p>
Pourquoi mentionner l&apos;opérateur cons ? Et bien nous en aurons besoin un
peu plus bas, pour faire du <em>filtrage</em> (<em>pattern matching</em>) sur les
listes.</p>
<h3 id="Letypedaposunelistechane"> Le type d&apos;une liste chaînée</h3><p>
Le type d&apos;une liste chaînée d&apos;entiers est <code>int list</code>, et plus
généralement le type d&apos;une liste chaînée de <code>toto</code>s est <code>toto list</code>.</p>
<p>Cela implique que tous les éléments d&apos;une liste chaînée doivent avoir le
même type; Il existe des types polymorphiques de listes (càd <code>&apos;a list</code>),
très utile pour écrire des fonctions manipulant des &quot;listes de n&apos;importe
quoi&quot; de manière générique. (Mais <code>&apos;a list</code> ne signifie pas que les
différents éléments d&apos;une liste peuvent avoir des types différents -
vous ne pouvez pas utiliser ce type polymorphique pour construire,
disons, une liste d&apos;entiers et de chaînes. Le sens de cette notation est
que les éléments de la liste peuvent être n&apos;importe quoi, mais tous &quot;du
même type de n&apos;importe quoi&quot;).</p>
<p>La fonction <code>length</code> définie dans le module standard de OCaml <code>List</code> en
est un bon exemple. Peu importe si une liste contient des entiers, des
chaînes, des objets ou des ratons-laveurs, la fonction <code>List.length</code>
peut être utilisée dessus. Le type de <code>List.length</code> est donc :</p>
<pre><code class='ocaml'><span class='m'>List</span><span class='o'>.</span>length <span class='o'>:</span> 'a list <span class='k'>-></span> int
</code></pre>
<h2 id="Structures"> Structures</h2><p>

Le C et le C++ proposent le concept simple de <code>struct</code>, abbréviation de
structure. En Java on peut utiliser des classes à la place, mais c&apos;est
beaucoup plus laborieux.</p>
<p>Considérons cette simple structure C :</p>
<pre><code class='ocaml'><span class='k'>struct</span> paire_dentiers <span class='o'>{</span>
  int a<span class='o'>,</span> b<span class='o'>;</span>
<span class='o'>}</span><span class='o'>;</span>
</code></pre>
<p>
L&apos;équivalent le plus simple en OCaml sont les <strong>n-uplets</strong> (tuples),
comme la paire <code>(3, 4)</code> qui a pour type <code>int * int</code>. Contrairement aux
listes, les n-uplets peuvent contenir des éléments de types différents,
par exemple <code>(3, &quot;hello&quot;, &apos;x&apos;)</code> qui a pour type <code>int * string * char</code>.</p>
<p>Une manière légèrement plus complexe de traduire les struct C est
d&apos;utiliser un <strong>enregistrement</strong> (record). Les enregistrements, comme
les structs C, permettent de nommer leurs composants. Les composants des
n-uplets ne peuvent pas être nommées, et il faut se souvenir de l&apos;ordre
dans lequel ils apparaissent. Voici l&apos;enregistrement équivalent au
struct C ci-dessus :</p>
<pre><code class='ocaml'><span class='k'>type</span> paire_dentiers <span class='k'>=</span> <span class='o'>{</span> a <span class='o'>:</span> int<span class='o'>;</span> b <span class='o'>:</span> int <span class='o'>}</span><span class='o'>;;</span>
</code></pre>
<p>
Ceci définit le type, et voici comment <em>créer</em> effectivement des valeurs
de ce type :</p>
<pre><code class='ocaml'><span class='o'>{</span> a<span class='k'>=</span>3<span class='o'>;</span> b<span class='k'>=</span>5 <span class='o'>}</span>
</code></pre>
<p>
Remarquez l&apos;utilisation de &quot;:&quot; dans la définition du type et de &quot;=&quot; pour
créer des valeurs de ce type.</p>
<p>Voici un exemple d&apos;utilisation des enregistrements, testé avec la boucle
interactive :</p>
<pre><code class='ocaml'><span class='o'>#</span> <span class='k'>type</span> paire_dentiers <span class='k'>=</span> <span class='o'>{</span> a <span class='o'>:</span> int<span class='o'>;</span> b <span class='o'>:</span> int <span class='o'>}</span><span class='o'>;;</span>
<span class='k'>type</span> paire_dentiers <span class='k'>=</span> <span class='o'>{</span> a <span class='o'>:</span> int<span class='o'>;</span> b <span class='o'>:</span> int<span class='o'>;</span> <span class='o'>}</span>
<span class='o'>#</span> <span class='o'>{</span>a<span class='k'>=</span>3<span class='o'>;</span> b<span class='k'>=</span>5<span class='o'>}</span><span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> paire_dentiers <span class='k'>=</span> <span class='o'>{</span>a <span class='k'>=</span> 3<span class='o'>;</span> b <span class='k'>=</span> 5<span class='o'>}</span>
<span class='o'>#</span> <span class='o'>{</span>a<span class='k'>=</span>3<span class='o'>}</span><span class='o'>;;</span>
Some record field labels are undefined<span class='o'>:</span> b
</code></pre>
<p>
Donc OCaml refuse de laisser certains champs d&apos;un enregistrement non
définis.</p>
<h2 id="Variantsunionsmarquesetnumrations"> Variants (unions marquées et énumérations)</h2><p>
Le concept d&apos;&quot;union marquée&quot; n&apos;existe pas vraiment en C, bien qu&apos;il
existe dans le compileur gcc. Voici comment on traduit d&apos;habitude une
union marquée en C:</p>
<pre><code class='ocaml'><span class='k'>struct</span> foo <span class='o'>{</span>
  int <span class='k'>type</span><span class='o'>;</span>
<span class='o'>#</span>define TYPE_INT 1
<span class='o'>#</span>define TYPE_PAIR_OF_INTS 2
<span class='o'>#</span>define TYPE_STRING 3
  union <span class='o'>{</span>
    int i<span class='o'>;</span>        <span class='o'>//</span> Si <span class='k'>type</span> <span class='o'>==</span> <span class='m'>TYPE_INT</span><span class='o'>.</span>
    int pair<span class='o'>[</span>2<span class='o'>]</span><span class='o'>;</span>  <span class='o'>//</span> Si <span class='k'>type</span> <span class='o'>==</span> <span class='m'>TYPE_PAIR_OF_INTS</span><span class='o'>.</span>
    char <span class='o'>*</span>str<span class='o'>;</span>    <span class='o'>//</span> Si <span class='k'>type</span> <span class='o'>==</span> <span class='m'>TYPE_STRING</span><span class='o'>.</span>
  <span class='o'>}</span> u<span class='o'>;</span>
<span class='o'>}</span><span class='o'>;</span>
</code></pre>
<p>
Je suppose que nous avons tous déjà vu ça, et ce n&apos;est pas beau à voir.
Pour commencer, ce n&apos;est pas sûr : le programmeur peut accidentellement
utiliser, disons, le champ <code>u.i</code> quand c&apos;est en fait une chaîne qui est
stockée dans la structure. Ensuite, le compilateur ne peut pas
facilement vérifier que tous les types ont été considérés dans les
instructions <code>switch</code> (on peut utiliser un type <code>enum</code> pour se prémunir
contre ce problème précis). Le programmeur peut aussi oublier de
modifier le champ <code>type</code>, ce qui peut procurer des heures de jeu. Pour
finir, c&apos;est lourdingue.</p>
<p>Voici l&apos;équivalent en OCaml, élégant et concis:</p>
<pre><code class='ocaml'><span class='k'>type</span> foo <span class='k'>=</span> Nothing <span class='o'>|</span> Int <span class='k'>of</span> int <span class='o'>|</span> Pair <span class='k'>of</span> int <span class='o'>*</span> int <span class='o'>|</span> String <span class='k'>of</span> string<span class='o'>;;</span>
</code></pre>
<p>
Voilà pour la définition du type. Au début de chacune des sections,
séparées par des <code>|</code>, se trouve un constructeur. On peut les nommer
comme on veut, tant que leur nom commence par une capitale. Si un
constructeur peut être utilisé pour définir une valeur, il est suivi de
<code>of</code> et d&apos;un type, qui lui commence par une minuscule. Dans l&apos;exemple
ci-dessus, Nothing est utilisé comme une constante, alors que les autres
constructeurs définissent des valeurs.</p>
<p>Pour <em>créer</em> effectivement des valeurs de ce type, on peut écrire:</p>
<pre><code class='ocaml'>Nothing
Int 3
Pair (4<span class='o'>,</span> 5)
String <span class='s'>&#34;hello&#34;</span>
     etc<span class='o'>.</span>
</code></pre>
<p>
Toutes ces expressions ont pour type <code>foo</code>.</p>
<p>Remarquez l&apos;utilisation de <code>of</code> dans la définition du type, qui ne se
retrouve PAS dans l&apos;écriture des valeurs de ce type.</p>
<p>Par extension, un simple <code>enum</code> C définit comme</p>
<pre><code class='ocaml'>enum sign <span class='o'>{</span> positive<span class='o'>,</span> zero<span class='o'>,</span> negative <span class='o'>}</span><span class='o'>;</span>
</code></pre>
<p>
peut être traduit en OCaml par</p>
<pre><code class='ocaml'><span class='k'>type</span> sign <span class='k'>=</span> Positive <span class='o'>|</span> Zero <span class='o'>|</span> Negative<span class='o'>;;</span>
</code></pre>
<h3 id="Variantsrcursifsutilisspourlesarbres"> Variants récursifs (utilisés pour les arbres)</h3><p>

Les variants peuvent être récursifs, ce qui est souvent utilisé pour
définir des structures de données arborescentes. C&apos;est vraiment là que
se révèle l&apos;expressivité des langages fonctionnels :</p>
<pre><code class='ocaml'><span class='k'>type</span> binary_tree <span class='k'>=</span> Leaf <span class='k'>of</span> int <span class='o'>|</span> Tree <span class='k'>of</span> binary_tree <span class='o'>*</span> binary_tree<span class='o'>;;</span>
</code></pre>
<p>
Voilà quelques arbres binaires. Comme exercice, essayez de les dessiner
sur un bout de papier.</p>
<pre><code class='ocaml'>Leaf 3

Tree (Leaf 3<span class='o'>,</span> Leaf 4)


Tree (Tree (Leaf 3<span class='o'>,</span> Leaf 4)<span class='o'>,</span> Leaf 5)

Tree (Tree (Leaf 3<span class='o'>,</span> Leaf 4)<span class='o'>,</span> Tree (Tree (Leaf 3<span class='o'>,</span> Leaf 4)<span class='o'>,</span> Leaf 5))
</code></pre>
<h3 id="Variantsparamtrs"> Variants paramétrés</h3><p>

L&apos;arbre binaire de la section précédente comporte un entier à chaque
feuille, mais comment faire pour décrire la <em>forme</em> de la structure de
données, en laissant le choix de ce qui doit être stocké dans chaque
feuille pour plus tard ? On peut utiliser un variant paramétré (ou
polymorphique), comme ceci :</p>
<pre><code class='ocaml'><span class='k'>type</span> 'a binary_tree <span class='k'>=</span> Leaf <span class='k'>of</span> 'a <span class='o'>|</span> Tree <span class='k'>of</span> 'a binary_tree <span class='o'>*</span> 'a binary_tree<span class='o'>;;</span>
</code></pre>
<p>
C&apos;est le type général. Le type où chaque feuille stocke un entier
s&apos;appelle <code>int binary_tree</code>. De la même façon, le type où chaque feuille
stocke une chaîne s&apos;appelle <code>string binary_tree</code>. Pour l&apos;exemple suivant
nous allons taper des valeurs dans la boucle interactive, et laisser le
système d&apos;inférence de types nous donner leurs types :</p>
<pre><code class='ocaml'><span class='o'>#</span> Leaf <span class='s'>&#34;hello&#34;</span><span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> string binary_tree <span class='k'>=</span> Leaf <span class='s'>&#34;hello&#34;</span>
<span class='o'>#</span> Leaf 3.0<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> float binary_tree <span class='k'>=</span> Leaf 3.
</code></pre>
<p>
Remarquez que le nom des types est à l&apos;envers (arbre binaire de
flottants -&#92;&gt; float binary_tree). C&apos;est comparable avec le nom des
types pour les listes, ie <code>int list</code>, etc.</p>
<p>En fait ce n&apos;est pas une coïncidence si <code>&apos;a list</code> est écrit lui aussi &quot;à
l&apos;envers&quot;. Les types listes ne sont que des types variants paramétrés,
avec une définition légèrement spéciale :</p>
<pre><code class='ocaml'> <span class='k'>type</span> 'a list <span class='k'>=</span> <span class='o'>[</span><span class='o'>]</span> <span class='o'>|</span> <span class='o'>::</span> <span class='k'>of</span> 'a <span class='o'>*</span> 'a list   <span class='com2'>(* ceci n'est pas du vrai code OCaml *)</span><!-- end comment -->
</code></pre>
<p>
En fait la définition ci-dessus ne compile pas. La définition suivante,
très similaire, compile correctement :</p>
<pre><code class='ocaml'><span class='o'>#</span> <span class='k'>type</span> 'a list <span class='k'>=</span> Nil <span class='o'>|</span> <span class='o'>::</span> <span class='k'>of</span> 'a <span class='o'>*</span> 'a list<span class='o'>;;</span>
<span class='k'>type</span> 'a list <span class='k'>=</span> Nil <span class='o'>|</span> <span class='o'>::</span> <span class='k'>of</span> 'a <span class='o'>*</span> 'a list
<span class='o'>#</span> Nil<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> 'a list <span class='k'>=</span> Nil
<span class='o'>#</span> 1 <span class='o'>::</span> Nil<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> int list <span class='k'>=</span> <span class='o'>::</span> (1<span class='o'>,</span> Nil)
<span class='o'>#</span> 1 <span class='o'>::</span> 2 <span class='o'>::</span> Nil<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> int list <span class='k'>=</span> <span class='o'>::</span> (1<span class='o'>,</span> <span class='o'>::</span> (2<span class='o'>,</span> Nil))
</code></pre>
<p>
Rappelez vous quand nous avons dit précédemment que les listes pouvaient
être écrites de deux façons, soit sous la forme syntaxiquement édulcorée
<code>[1; 2; 3]</code> ou sous la forme plus formelle <code>1 :: 2 :: 3 :: []</code>. En
regardant la définition de <code>&apos;a list</code> ci-dessus, l&apos;origine de la syntaxe
formelle devrait vous paraître plus clairement.</p>
<h2 id="ListesstructuresetvariantsRsum"> Listes, structures et variants — Résumé</h2><p>
tableau en 3 colonnes avec nom et exemples de définition et de valeur.</p>
<pre><code class='ocaml'>nom OCaml        Example de définition de <span class='k'>type</span>          Exemple(s) de valeur(s) 
liste            int list                               <span class='o'>[</span>1<span class='o'>;</span> 2<span class='o'>;</span> 3<span class='o'>]</span>
n<span class='o'>-</span>uplet          int <span class='o'>*</span> string                           (3<span class='o'>,</span> <span class='s'>&#34;hello&#34;</span>)
enregistrement   <span class='k'>type</span> pair <span class='k'>=</span> <span class='o'>{</span> a <span class='o'>:</span> int<span class='o'>;</span> b <span class='o'>:</span> string <span class='o'>}</span>    <span class='o'>{</span> a <span class='k'>=</span> 3<span class='o'>;</span> b <span class='k'>=</span> <span class='s'>&#34;hello&#34;</span> <span class='o'>}</span>
variant          <span class='k'>type</span> foo <span class='k'>=</span> Int <span class='k'>of</span> int                  Int 3
                           <span class='o'>|</span> Pair <span class='k'>of</span> int <span class='o'>*</span> string                                                                      
variant          <span class='k'>type</span> sign <span class='k'>=</span> Positive <span class='o'>|</span> Zero            Positive
                           <span class='o'>|</span> Negative                   Zero
variant          <span class='k'>type</span> 'a my_list <span class='k'>=</span> Empty                Cons (1<span class='o'>,</span> Cons (2<span class='o'>,</span> Empty))
  paramétré                <span class='o'>|</span> Cons <span class='k'>of</span> 'a <span class='o'>*</span> 'a my_list
</code></pre>
<h2 id="Filtragesurlesstructuresdedonnes"> Filtrage (sur les structures de données)</h2><p>

Une &quot;Fonctionnalité Vraiment Cool&quot;(tm) des langages fonctionnels est
leur capacité à démonter les structures de données et à effectuer du
filtrage (pattern matching) sur les données. Ce n&apos;est pas à proprement
parler une propriété &quot;fonctionnelle&quot; - on pourrait très bien imaginer
une nouvelle sorte de C qui offrirait ces mêmes services. Mais c&apos;est
tout de même une &quot;Fonctionnalité Vraiment Cool&quot;.</p>
<p>Commençons par un problème réel : je veux représenter des expressions
mathématiques simples comme <code>n * (x + y)</code> et effectuer les
multiplications symboliquement pour obtenir <code>n * x + n * y</code>.</p>
<p>Définissons un type pour ces expressions:</p>
<pre><code class='ocaml'><span class='k'>type</span> expr <span class='k'>=</span> Plus <span class='k'>of</span> expr <span class='o'>*</span> expr        <span class='com2'>(* pour a <span class='ic'>+</span> b *)</span><!-- end comment -->
          <span class='o'>|</span> Minus <span class='k'>of</span> expr <span class='o'>*</span> expr       <span class='com2'>(* pour a <span class='ic'>-</span> b *)</span><!-- end comment -->
          <span class='o'>|</span> Times <span class='k'>of</span> expr <span class='o'>*</span> expr       <span class='com2'>(* pour a <span class='ic'>*</span> b *)</span><!-- end comment -->
      <span class='o'>|</span> Divide <span class='k'>of</span> expr <span class='o'>*</span> expr      <span class='com2'>(* pour a <span class='ic'>/</span> b *)</span><!-- end comment -->
          <span class='o'>|</span> Value <span class='k'>of</span> string            <span class='com2'>(* <span class='ic'>&#34;x&#34;</span><span class='ic'>,</span> <span class='ic'>&#34;y&#34;</span><span class='ic'>,</span> <span class='ic'>&#34;n&#34;</span><span class='ic'>,</span> etc<span class='ic'>.</span> *)</span><!-- end comment -->
      <span class='o'>;;</span>
</code></pre>
<p>
L&apos;expression <code>n * (x + y)</code> s&apos;écrirait:</p>
<pre><code class='ocaml'>Times (Value <span class='s'>&#34;n&#34;</span><span class='o'>,</span> Plus (Value <span class='s'>&#34;x&#34;</span><span class='o'>,</span> Value <span class='s'>&#34;y&#34;</span>))
</code></pre>
<p>
Ecrivons une fonction qui affiche
<code>Times (Value &quot;n&quot;, Plus (Value &quot;x&quot;, Value &quot;y&quot;))</code> comme <code>n * (x + y)</code>. En
fait, je vais écrire deux fonctions, l&apos;une qui convertit une expression
en une jolie chaîne, et une autre qui l&apos;affiche (comme ça si j&apos;ai envie
d&apos;écrire la même chaîne dans un fichier, je n&apos;aurais pas à réécrire la
fonction en entier juste pour ça).</p>
<pre><code class='ocaml'><span class='k'>let rec</span> to_string e <span class='k'>=</span>
  <span class='k'>match</span> e <span class='k'>with</span>
    Plus (left<span class='o'>,</span> right)   <span class='k'>-></span> <span class='s'>&#34;(&#34;</span> <span class='o'>^</span> (to_string left) <span class='o'>^</span> <span class='s'>&#34; + &#34;</span> <span class='o'>^</span> (to_string right) <span class='o'>^</span> <span class='s'>&#34;)&#34;</span>
  <span class='o'>|</span> Minus (left<span class='o'>,</span> right)  <span class='k'>-></span> <span class='s'>&#34;(&#34;</span> <span class='o'>^</span> (to_string left) <span class='o'>^</span> <span class='s'>&#34; - &#34;</span> <span class='o'>^</span> (to_string right) <span class='o'>^</span> <span class='s'>&#34;)&#34;</span>

  <span class='o'>|</span> Times (left<span class='o'>,</span> right)  <span class='k'>-></span> <span class='s'>&#34;(&#34;</span> <span class='o'>^</span> (to_string left) <span class='o'>^</span> <span class='s'>&#34; * &#34;</span> <span class='o'>^</span> (to_string right) <span class='o'>^</span> <span class='s'>&#34;)&#34;</span>
  <span class='o'>|</span> Divide (left<span class='o'>,</span> right) <span class='k'>-></span> <span class='s'>&#34;(&#34;</span> <span class='o'>^</span> (to_string left) <span class='o'>^</span> <span class='s'>&#34; / &#34;</span> <span class='o'>^</span> (to_string right) <span class='o'>^</span> <span class='s'>&#34;)&#34;</span>

  <span class='o'>|</span> Value v <span class='k'>-></span> v
  <span class='o'>;;</span>

<span class='k'>let</span> print_expr e <span class='k'>=</span>
  print_endline (to_string e)<span class='o'>;;</span>
</code></pre>
<p>
(NB: L&apos;opérateur <code>^</code> sert à concaténer les chaînes.)</p>
<p>Voilà la fonction d&apos;affichage à l&apos;oeuvre:</p>
<pre><code class='ocaml'><span class='o'>#</span> print_expr (Times (Value <span class='s'>&#34;n&#34;</span><span class='o'>,</span> Plus (Value <span class='s'>&#34;x&#34;</span><span class='o'>,</span> Value <span class='s'>&#34;y&#34;</span>)))<span class='o'>;;</span>
(n <span class='o'>*</span> (x <span class='o'>+</span> y))
</code></pre>
<p>
La forme générale pour le filtrage est:</p>
<pre><code class='ocaml'><span class='k'>match</span> valeur <span class='k'>with</span>
  motif    <span class='k'>-></span>  résultat
<span class='o'>|</span> motif    <span class='k'>-></span>  résultat
    <span class='o'>...</span>
</code></pre>
<p>
Les motifs dans la colonne de gauche peuvent être simples, comme dans la
fonction <code>to_string</code> ci-dessus, ou plus complexe et imbriqués. L&apos;exemple
suivant est notre fonction de distribution symbolique de la
multiplication des expressions de la forme <code>n * (x + y)</code> ou
<code>(x + y) * n</code>, et pour cela on va utiliser un motif imbriqué :</p>
<pre><code class='ocaml'><span class='k'>let rec</span> multiply_out e <span class='k'>=</span>
  <span class='k'>match</span> e <span class='k'>with</span>
    Times (e1<span class='o'>,</span> Plus (e2<span class='o'>,</span> e3)) <span class='k'>-></span>
      Plus (Times (multiply_out e1<span class='o'>,</span> multiply_out e2)<span class='o'>,</span>
            Times (multiply_out e1<span class='o'>,</span> multiply_out e3))
  <span class='o'>|</span> Times (Plus (e1<span class='o'>,</span> e2)<span class='o'>,</span> e3) <span class='k'>-></span>
      Plus (Times (multiply_out e1<span class='o'>,</span> multiply_out e3)<span class='o'>,</span>
            Times (multiply_out e2<span class='o'>,</span> multiply_out e3))
  <span class='o'>|</span> Plus (left<span class='o'>,</span> right) <span class='k'>-></span> Plus (multiply_out left<span class='o'>,</span> multiply_out right)
  <span class='o'>|</span> Minus (left<span class='o'>,</span> right) <span class='k'>-></span> Minus (multiply_out left<span class='o'>,</span> multiply_out right)
  <span class='o'>|</span> Times (left<span class='o'>,</span> right) <span class='k'>-></span> Times (multiply_out left<span class='o'>,</span> multiply_out right)
  <span class='o'>|</span> Divide (left<span class='o'>,</span> right) <span class='k'>-></span> Divide (multiply_out left<span class='o'>,</span> multiply_out right)
  <span class='o'>|</span> Value v <span class='k'>-></span> Value v
  <span class='o'>;;</span>
</code></pre>
<p>
La voilà en action:</p>
<pre><code class='ocaml'><span class='o'>#</span> print_expr (multiply_out (Times (Value <span class='s'>&#34;n&#34;</span><span class='o'>,</span> Plus (Value <span class='s'>&#34;x&#34;</span><span class='o'>,</span> Value <span class='s'>&#34;y&#34;</span>))))<span class='o'>;;</span>
((n <span class='o'>*</span> x) <span class='o'>+</span> (n <span class='o'>*</span> y))
</code></pre>
<p>
Comment est-ce que marche la fonction <code>multiply_out</code> ? L&apos;essentiel se
trouve dans les deux premiers motifs. Le premier est
<code>Times (e1, Plus (e2, e3))</code> qui filtre les expressions de la forme
<code>e1 * (e2 + e3)</code>. Regardez la colonne de droite en face de ce motif, et
assurez vous que son contenu équivaut à <code>(e1 * e2) + (e1 * e3)</code>.</p>
<p>Le second motif fait la même chose pour les expressions de la forme
<code>(e1 + e2) * e3</code>.</p>
<p>Les autres motifs ne modifient pas la forme de l&apos;expression, mais font
le travail nécessaire d&apos;appeler la fonction <code>multiply_out</code> récursivement
sur leurs sous-expressions. Cela garantit que toutes les
sous-expressions de l&apos;expression sont correctement transformées. (Si
vous n&apos;étiez concernés que par la transformation de l&apos;expression la plus
externe, tous ces motifs auraient pu être remplacés par une simple règle
<code>e -&gt; e</code>).</p>
<p>Est-ce que l&apos;on peut effectuer l&apos;opération inverse (càd factoriser au
lieu de distribuer) ? Bien sûr ! (Mais c&apos;est un peu plus compliqué...).
La version suivante ne marche que pour l&apos;expression la plus externe.
Vous pourriez certainement l&apos;améliorer pour gérer tous les niveaux de
sous-expressions, et des cas plus complexes :</p>
<pre><code class='ocaml'><span class='k'>let</span> factorize e <span class='k'>=</span>
  <span class='k'>match</span> e <span class='k'>with</span>
    Plus (Times (e1<span class='o'>,</span> e2)<span class='o'>,</span> Times (e3<span class='o'>,</span> e4)) <span class='k'>when</span> e1 <span class='k'>=</span> e3 <span class='k'>-></span> Times (e1<span class='o'>,</span> Plus (e2<span class='o'>,</span> e4))
  <span class='o'>|</span> Plus (Times (e1<span class='o'>,</span> e2)<span class='o'>,</span> Times (e3<span class='o'>,</span> e4)) <span class='k'>when</span> e2 <span class='k'>=</span> e4 <span class='k'>-></span> Times (Plus (e1<span class='o'>,</span> e3)<span class='o'>,</span> e4)
  <span class='o'>|</span> e <span class='k'>-></span> e
  <span class='o'>;;</span>

<span class='o'>#</span> factorize (Plus (Times (Value <span class='s'>&#34;n&#34;</span><span class='o'>,</span> Value <span class='s'>&#34;x&#34;</span>)<span class='o'>,</span> Times (Value <span class='s'>&#34;n&#34;</span><span class='o'>,</span> Value <span class='s'>&#34;y&#34;</span>)))<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> expr <span class='k'>=</span> Times (Value <span class='s'>&#34;n&#34;</span><span class='o'>,</span> Plus (Value <span class='s'>&#34;x&#34;</span><span class='o'>,</span> Value <span class='s'>&#34;y&#34;</span>))
</code></pre>
<p>
La fonction de factorisation ci-dessus introduit une paire de nouvelles
fonctionnalités. Vous pouvez ajouter ce qui s&apos;appelle une <strong>garde</strong> à
chaque motif. Une garde est une condition précédée de <code>when</code>, et qui
signifie que le filtrage n&apos;est fructueux que si le motif correspond <em>et</em>
la condition après la clause <code>when</code> est satisfaite.</p>
<pre><code class='ocaml'><span class='k'>match</span> valeur <span class='k'>with</span>
  motif      <span class='o'>[</span> <span class='k'>when</span> condition <span class='o'>]</span>   <span class='k'>-></span>  résultat
  motif      <span class='o'>[</span> <span class='k'>when</span> condition <span class='o'>]</span>   <span class='k'>-></span>  résultat
    <span class='o'>...</span>
</code></pre>
<p>
La seconde fonctionalité est l&apos;opérateur <code>=</code> qui teste l&apos;&quot;égalité
structurelle&quot; de deux expressions. Cela signifie qu&apos;il descend
récursivement dans chacune de deux expressions pour vérifier qu&apos;elles
sont identiques à tous les niveaux.</p>
<p>OCaml est capable de vérifier au moment de la compilation que tous les
cas sont couverts par vos motifs. J&apos;ai modifié la définition du
<code>type expr</code> précédent pour y ajouter le constructeur <code>Product</code> :</p>
<pre><code class='ocaml'><span class='k'>type</span> expr <span class='k'>=</span> Plus <span class='k'>of</span> expr <span class='o'>*</span> expr        <span class='com2'>(* pour a <span class='ic'>+</span> b *)</span><!-- end comment -->
          <span class='o'>|</span> Minus <span class='k'>of</span> expr <span class='o'>*</span> expr       <span class='com2'>(* pour a <span class='ic'>-</span> b *)</span><!-- end comment -->
          <span class='o'>|</span> Times <span class='k'>of</span> expr <span class='o'>*</span> expr       <span class='com2'>(* pour a <span class='ic'>*</span> b *)</span><!-- end comment -->
      <span class='o'>|</span> Divide <span class='k'>of</span> expr <span class='o'>*</span> expr      <span class='com2'>(* pour a <span class='ic'>/</span> b *)</span><!-- end comment -->
      <span class='o'>|</span> Product <span class='k'>of</span> expr list       <span class='com2'>(* pour a <span class='ic'>*</span> b <span class='ic'>*</span> c <span class='ic'>*</span> <span class='ic'>...</span> *)</span><!-- end comment -->
          <span class='o'>|</span> Value <span class='k'>of</span> string            <span class='com2'>(* <span class='ic'>&#34;x&#34;</span><span class='ic'>,</span> <span class='ic'>&#34;y&#34;</span><span class='ic'>,</span> <span class='ic'>&#34;n&#34;</span><span class='ic'>,</span> etc<span class='ic'>.</span> *)</span><!-- end comment -->
      <span class='o'>;;</span>
</code></pre>
<p>
J&apos;ai ensuite recompilé la fonction <code>to_string</code> sans modifications. OCaml
a renvoyé l&apos;avertissement suivant :</p>
<pre><code class='ocaml'>Warning<span class='o'>:</span> this pattern<span class='o'>-</span>matching is not exhaustive<span class='o'>.</span>
Here is an example <span class='k'>of</span> a value that is not matched<span class='o'>:</span>
Product <span class='o'>_</span>

</code></pre>
