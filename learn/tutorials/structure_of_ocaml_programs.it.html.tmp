<h1 id="LastrutturadeiprogrammiOCaml"> La struttura dei programmi OCaml</h1><h2 id="LastrutturadeiprogrammiOCamlx"> La struttura dei programmi OCaml</h2><p>

Ci prenderemo ora del tempo per dare uno sguardo ad alto livello a
qualche programma OCaml reale. Voglio istruirvi sulle definizioni locali
e globali, su quando usare <code>;;</code> piuttosto che <code>;</code>, sui moduli, sulle
funzioni annidate, e sui riferimenti. A questo scopo osserveremo molti
concetti di OCaml che non saranno subito chiari, non avendoli noi mai
visti prima. Non preoccupatevi dei dettagli, per ora. Concentratevi
invece sulla forma complessiva dei programmi e sulle caratteristiche che
rileverò.</p>
<h3 id="quotVariabiliquotlocaliinrealtespressionilocali"> &quot;Variabili&quot; locali (<em>in realtà</em> espressioni locali)</h3><p>
Prendiamo la funzione <code>average</code> ed aggiungiamovi una variabile locale in
C. (Confrontatela con la prima definizione che ne avevamo sopra).</p>
<pre><code class='ocaml'>double
average (double a<span class='o'>,</span> double b)
<span class='o'>{</span>
  double sum <span class='k'>=</span> a <span class='o'>+</span> b<span class='o'>;</span>
  return sum <span class='o'>/</span> 2<span class='o'>;</span>
<span class='o'>}</span>
</code></pre>
<p>
Faccia ora lo stesso con la nostra versione in OCaml:</p>
<pre><code class='ocaml'><span class='k'>let</span> average a b <span class='k'>=</span>
  <span class='k'>let</span> sum <span class='k'>=</span> a <span class='o'>+.</span> b <span class='k'>in</span>
  sum <span class='o'>/.</span> 2.0<span class='o'>;;</span>
</code></pre>
<p>
La frase standard <code>let nome = espressione in</code> è usata per definire
un&apos;espressione locale dotata di nome, e <code>name</code> può dunque essere
utilizzato in seguito nella funzione al posto di <code>espressione</code>, fino ad
un <code>;;</code> che termina il blocco di codice. Notate che non indentiamo dopo
l&apos;<code>in</code>. Pensate semplicemente a <code>let ... in</code> come se fosse
un&apos;istruzione.</p>
<p>Ora, confrontare le variabili locali di C e queste espressioni locali
dotate di nome è un trucco. In realtà sono cose alquanto differenti. La
variabile C <code>sum</code> ha uno slot allocato per sé nello stack. Potete
assegnare più tardi valori a <code>sum</code> nella funzione se volete, o anche
ottenete l&apos;indirizzo di <code>sum</code>. Questo NON è vero per la versione in
OCaml. Nella versione in OCaml, <code>sum</code> è soltanto un nome abbreviato per
l&apos;espressione <code>a +. b</code>. Non vi è modo alcuno di assegnare un valore a
<code>sum</code> o di modificarne il valore. (Vedremo presto come potete fare delle
vere variabili).</p>
<p>Ecco un altro esempio per rendere più chiaro ciò. I due frammenti di
codice che seguono dovrebbero restituire il medesimo valore (ossia (a+b)</p>
<ul>
 <li>(a+b)<sup>2</sup>):</li>
</ul>

<p>let f a b =
  (a +. b) +. (a +. b) ** 2.
  ;;</p>
<p>let f a b =
  let x = a +. b in
  x +. x ** 2.
  ;;</p>
<p>La seconda versione potrebbe essere più veloce (ma la maggior parte dei
compilatori dovrebbe poter compiere per voi questo passaggio di
&quot;eliminazione di sottoepressione comune&quot;), ed è certamente più facile da
leggere. <code>x</code> nel secondo esempio non è che una forma abbreviata per
<code>a +. b</code>.</p>
<h3 id="quotVariabiliquotglobaliinrealtespressioniglobali"> &quot;Variabili&quot; globali (<em>in realtà</em> espressioni globali)</h3><p>
Potete anche definire nomi globali per cose al livello superiore, e come
le nostre &quot;variabili&quot; locali sopra queste non sono affatto realmente
variabili, ma soltanto nomi abbreviati per queste cose. Ecco un esempio
reale (ma ridotto):</p>
<pre><code class='ocaml'><span class='k'>let</span> html <span class='k'>=</span>
  <span class='k'>let</span> content <span class='k'>=</span> read_whole_file file <span class='k'>in</span>
  <span class='m'>GHtml</span><span class='o'>.</span>html_from_string content
  <span class='o'>;;</span>

<span class='k'>let</span> menu_bold () <span class='k'>=</span>
  <span class='k'>match</span> bold_button<span class='o'>#</span>active <span class='k'>with</span>
    <span class='o'>true</span> <span class='k'>-></span> html<span class='o'>#</span>set_font_style <span class='o'>~</span>enable<span class='o'>:</span><span class='o'>[</span>`BOLD<span class='o'>]</span> ()
  <span class='o'>|</span> <span class='o'>false</span> <span class='k'>-></span> html<span class='o'>#</span>set_font_style <span class='o'>~</span>disable<span class='o'>:</span><span class='o'>[</span>`BOLD<span class='o'>]</span> ()
  <span class='o'>;;</span>

<span class='k'>let</span> main () <span class='k'>=</span>
  <span class='com2'>(* codice omesso *)</span><!-- end comment -->
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Cut&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>X <span class='o'>~</span>callback<span class='o'>:</span> html<span class='o'>#</span>cut
  <span class='o'>;;</span>
</code></pre>
<p>
In questo reale pezzo di codice, <code>html</code> è un accessorio di editing HTML
(un oggetto della libreria lablgtk) che è creato una sola volta
all&apos;inizio del programma dalla prima istruzione <code>let html =</code>. Vi si fa
quindi riferimento in diverse funzioni successive.</p>
<p>Notate che il nome <code>html</code> nel frammento di codice sopra non dovrebbe
essere realmente confrontato con una vera variabile globale come in C o
in altri linguaggi imperativi. Non vi è spazio allocato per
&quot;immagazzinare&quot; il &quot;puntatore <code>html</code>&quot;. Né è possibile assegnare alcunché
ad <code>html</code>, per esempio per riassegnarlo perché punti ad un accessorio
differente. Nella prossima sezione parleremo dei riferimenti, che sono
vere variabili.</p>
<h3 id="Letbinding"> Let-binding</h3><p>
Ciascun utilizzo di <code>let ...</code>, sia esso al livello superiore
(globalmente) o all&apos;interno di una funzione, è spesso chiamato
<strong>let-binding</strong>.</p>
<h3 id="Riferimentiverevariabili"> Riferimenti: vere variabili</h3><p>
Che cosa succede se volete una vera variabile a cui possiate assegnare
valori e che possiate modificare all&apos;interno del vostro programma?
Dovrete utilizzare un <strong>riferimento</strong>. I riferimenti sono molto simili
ai puntatori in C/C++. In Java, tutte le variabili che immagazzinano
oggetti sono in realtà riferiment (puntatori) agli oggetti. In Perl, i
riferimenti sono riferimenti - la medesima cosa che sono in OCaml.</p>
<p>Ecco come creiamo un riferimento ad un <code>int</code> in OCaml:</p>
<pre><code class='ocaml'>ref 0<span class='o'>;;</span>
</code></pre>
<p>
In realtà tale istruzione non era veramente molto utile. Abbiamo creato
il riferimento e quindi, poiché che non gli abbiamo dato un nome, il
garbage collector è arrivato e l&apos;ha raccolto immediatamente dopo! (in
realtà, è stato probabilmente gettato via durante la compilazione.)
Diamo un nome al riferimento:</p>
<pre><code class='ocaml'><span class='k'>let</span> my_ref <span class='k'>=</span> ref 0<span class='o'>;;</span>
</code></pre>
<p>
Questo riferimento sta attualmente immagazzinando un intero pari a zero.
Mettiamoci dentro qualcosa d&apos;altro (assegnamento):</p>
<pre><code class='ocaml'>my_ref <span class='o'>:=</span> 100<span class='o'>;;</span>
</code></pre>
<p>
E troviamo che cosa contiene ora il riferimento:</p>
<pre><code class='ocaml'><span class='o'>#</span> <span class='o'>!</span>my_ref<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> int <span class='k'>=</span> 100
</code></pre>
<p>
Quindi l&apos;operatore <code>:=</code> è utilizzato per fare assegnamenti a
riferimenti, e l&apos;operatore <code>!</code> dereferenzia per ottenere i contenuti.
Ecco un pronto ed approssimativo confronto con C/C++:</p>
<pre><code class='ocaml'>OCaml                   C<span class='o'>/</span>C<span class='o'>++</span>

<span class='k'>let</span> my_ref <span class='k'>=</span> ref 0<span class='o'>;;</span>    int a <span class='k'>=</span> 0<span class='o'>;</span> int <span class='o'>*</span>my_ptr <span class='k'>=</span> <span class='o'>&#38;</span>a<span class='o'>;</span>
my_ref <span class='o'>:=</span> 100<span class='o'>;;</span>         <span class='o'>*</span>my_ptr <span class='k'>=</span> 100<span class='o'>;</span>
<span class='o'>!</span>my_ref                 <span class='o'>*</span>my_ptr
</code></pre>
<p>
I riferimenti hanno il loro posto, ma potrete trovare di non utilizzare
i riferimenti molto spesso. Molto più spesso utilizzerete
<code>let name = espressione in</code> per dare nomi ad espressioni locali nelle
vostre definizioni di funzione.</p>
<h3 id="Funzioniannidate"> Funzioni annidate</h3><p>
C non ha realmente un concetto di funzioni annidate. GCC supporta le
funzioni annidate per programmi C, ma non so di programmi che utilizzino
effettivamente tale estensione. Ecco comunque che cos&apos;ha da dire la
pagina info di gcc a proposito delle funzioni annidate:</p>
<p>Una &quot;funzione annidata&quot; (&quot;nested function&quot; nell&apos;originale inglese, NdT)
è una funzione definita all&apos;interno di un&apos;altra funzione. (Le funzioni
annidate non sono supportate per GNU C++.) Il nome di una funzione
annidata è locale rispetto al blocco in cui essa è definita. Ad esempio,
di seguito definiamo una funzione annidata chiamata</p>
<pre><code>square&apos;, e la
chiamiamo due volte:

```ocaml
foo (double a, double b)
{
  double square (double z) { return z * z; }

  return square (a) + square (b);
}
```
La funzione annidata può accedere a tutte le variabili della funzione
che la contiene le quali siano visibili al punto a cui essa è definita.
Ciò è detto &quot;scoping lessicale&quot; (&quot;lexical scoping&quot; nell&apos;originale, NdT).
Ad esempio, mostriamo qui una funzione annidata che utilizza una
variabile ereditata chiamata </code></pre>
<p>offset&apos;:</p>
<pre><code class='ocaml'>bar (int <span class='o'>*</span>array<span class='o'>,</span> int offset<span class='o'>,</span> int size)
<span class='o'>{</span>
  int access (int <span class='o'>*</span>array<span class='o'>,</span> int index)
    <span class='o'>{</span> return array<span class='o'>[</span>index <span class='o'>+</span> offset<span class='o'>]</span><span class='o'>;</span> <span class='o'>}</span>
  int i<span class='o'>;</span>
  <span class='o'>/*</span> <span class='o'>...</span> <span class='o'>*/</span>
  <span class='k'>for</span> (i <span class='k'>=</span> 0<span class='o'>;</span> i <span class='o'>&#60;</span> size<span class='o'>;</span> i<span class='o'>++)</span>
    <span class='o'>/*</span> <span class='o'>...</span> <span class='o'>*/</span> access (array<span class='o'>,</span> i) <span class='o'>/*</span> <span class='o'>...</span> <span class='o'>*/</span>
<span class='o'>}</span>
</code></pre>
<p>
Afferrate l&apos;idea. Le funzioni annidate sono tuttavia molto utili e molto
diffusamente utilizzate in OCaml. Ecco un esempio di funzione annidata
proveniente da codice reale:</p>
<pre><code class='ocaml'><span class='k'>let</span> read_whole_channel chan <span class='k'>=</span>
  <span class='k'>let</span> buf <span class='k'>=</span> <span class='m'>Buffer</span><span class='o'>.</span>create 4096 <span class='k'>in</span>
  <span class='k'>let rec</span> loop () <span class='k'>=</span>
    <span class='k'>let</span> newline <span class='k'>=</span> input_line chan <span class='k'>in</span>
    <span class='m'>Buffer</span><span class='o'>.</span>add_string buf newline<span class='o'>;</span>
    <span class='m'>Buffer</span><span class='o'>.</span>add_char buf <span class='s'>&#39;\n&#39;</span><span class='o'>;</span>
    loop ()
  <span class='k'>in</span>
  <span class='k'>try</span>
    loop ()
  <span class='k'>with</span>
    End_of_file <span class='k'>-></span> <span class='m'>Buffer</span><span class='o'>.</span>contents buf<span class='o'>;;</span>
</code></pre>
<p>
Non preoccupatevi di che cosa fa questo codice - contiene molti concetti
che non sono ancora stati discussi in questo tutorial. Concentratevi
invece sulla funzione annidata centrale chiamata <code>loop</code> che prende
soltanto un argomento di tipo unit. Potete chiamare <code>loop ()</code> da dentro
la funzione <code>read_whole_channel</code>, ma essa non è definita al di fuori di
tale funzione. La funzione annidata può accedere alle variabili definite
nella funzione principale (qui <code>loop</code> accede al nome locale <code>buf</code>).</p>
<p>La forma per le funzioni annidate è la medesima utilizzata per le
espressioni con nome locale:
<code>let nome argomenti = definizione-della-funzione in</code>.</p>
<p>Normalmente indenterete la definizione della funzione in una nuova riga
come nell&apos;esempio sopra, e ricorderete di usare <code>let rec</code> al posto di
<code>let</code> se la vostra funzione è ricorsiva (com&apos;è in quell&apos;esempio).</p>
<h3 id="Modulieopen"> Moduli e <code>open</code></h3><p>
OCaml è distribuito con parecchi moduli divertenti ed interessanti
(librerie di codice utile). Vi sono ad esempio librerie standard per
disegnare grafici, interfacciarsi con insiemi di accessori di
interfaccia grafica, trattare grandi numeri, strutture di dati, e fare
chiamate di sistema POSIX. Tali librerie sono collocate in
<code>/usr/lib/ocaml/VERSIONE/</code> (negli Unix comunque). Per questi esempi ci
concentreremo su un modulo piuttosto semplice chiamato <code>Graphics</code>.</p>
<p>Il modulo <code>Graphics</code> è installato in 5 file (sul mio sistema):</p>
<pre><code class='ocaml'><span class='o'>/</span>usr<span class='o'>/</span>lib<span class='o'>/</span>ocaml<span class='o'>/</span>3.08<span class='o'>/</span>graphics<span class='o'>.</span>a
<span class='o'>/</span>usr<span class='o'>/</span>lib<span class='o'>/</span>ocaml<span class='o'>/</span>3.08<span class='o'>/</span>graphics<span class='o'>.</span>cma
<span class='o'>/</span>usr<span class='o'>/</span>lib<span class='o'>/</span>ocaml<span class='o'>/</span>3.08<span class='o'>/</span>graphics<span class='o'>.</span>cmi
<span class='o'>/</span>usr<span class='o'>/</span>lib<span class='o'>/</span>ocaml<span class='o'>/</span>3.08<span class='o'>/</span>graphics<span class='o'>.</span>cmxa
<span class='o'>/</span>usr<span class='o'>/</span>lib<span class='o'>/</span>ocaml<span class='o'>/</span>3.08<span class='o'>/</span>graphics<span class='o'>.</span>mli
</code></pre>
<p>
Concentriamoci per un momento soltanto sul file <code>graphics.mli</code>. Questo è
un file di testo, per cui lo potete leggere ora. Notate innanzitutto che
il nome è <code>graphics.mli</code> e non <code>Graphics.mli</code>. OCaml mette sempre in
maiuscolo la prima lettera del nome del file per ottenere il nome del
modulo. Ciò può confondervi assai finché non lo sapete!</p>
<p>Se vogliamo utilizzare le funzioni contenute in <code>Graphics</code> vi sono due
modi in cui lo possiamo fare. O abbiamo all&apos;inizio del programma la
dichiarazione <code>open Graphics;;</code>. Oppure dotiamo di prefisso tutte le
chiamate alle funzioni come segue: <code>Graphics.open_graph</code>. <code>open</code> è un
poco come l&apos;istruzione <code>import</code> di Java, e molto più come l&apos;istruzione
<code>use</code> di Perl.</p>
<p>Un paio di esempi dovrebbero rendere chiaro quanto detto. (I due esempi
disegnano cose diverse - provateli). Si noti che il primo esempio chiama
<code>open_graph</code> ed il secondo <code>Graphics.open_graph</code>.</p>
<pre><code class='ocaml'><span class='com2'>(* Per compilare questo esempio<span class='ic'>:</span> ocamlc graphics<span class='ic'>.</span>cma grtest1<span class='ic'>.</span>ml <span class='ic'>-</span>o grtest1 *)</span><!-- end comment -->

<span class='k'>open</span> Graphics<span class='o'>;;</span>

open_graph <span class='s'>&#34; 640x480&#34;</span><span class='o'>;;</span>
<span class='k'>for</span> i <span class='k'>=</span> 12 <span class='k'>downto</span> 1 <span class='k'>do</span>
  <span class='k'>let</span> radius <span class='k'>=</span> i <span class='o'>*</span> 20 <span class='k'>in</span>
  set_color (<span class='k'>if</span> (i <span class='k'>mod</span> 2) <span class='k'>=</span> 0 <span class='k'>then</span> red <span class='k'>else</span> yellow)<span class='o'>;</span>
  fill_circle 320 240 radius
<span class='k'>done</span><span class='o'>;;</span>
read_line ()<span class='o'>;;</span>

<span class='com2'>(* Per compilare questo esempio<span class='ic'>:</span> ocamlc graphics<span class='ic'>.</span>cma grtest2<span class='ic'>.</span>ml <span class='ic'>-</span>o grtest2 *)</span><!-- end comment -->

<span class='m'>Random</span><span class='o'>.</span>self_init ()<span class='o'>;;</span>
<span class='m'>Graphics</span><span class='o'>.</span>open_graph <span class='s'>&#34; 640x480&#34;</span><span class='o'>;;</span>

<span class='k'>let rec</span> iterate r x_init i <span class='k'>=</span>
        <span class='k'>if</span> i <span class='o'>==</span> 1 <span class='k'>then</span> x_init
        <span class='k'>else</span>
                <span class='k'>let</span> x <span class='k'>=</span> iterate r x_init (i-1) <span class='k'>in</span>
                r <span class='o'>*.</span> x <span class='o'>*.</span> (1.0 <span class='o'>-.</span> x)<span class='o'>;;</span>

<span class='k'>for</span> x <span class='k'>=</span> 0 <span class='k'>to</span> 640 <span class='k'>do</span>
        <span class='k'>let</span> r <span class='k'>=</span> 4.0 <span class='o'>*.</span> (float_of_int x) <span class='o'>/.</span> 640.0 <span class='k'>in</span>
        <span class='k'>for</span> i <span class='k'>=</span> 0 <span class='k'>to</span> 39 <span class='k'>do</span>
                <span class='k'>let</span> x_init <span class='k'>=</span> <span class='m'>Random</span><span class='o'>.</span>float 1.0 <span class='k'>in</span>
                <span class='k'>let</span> x_final <span class='k'>=</span> iterate r x_init 500 <span class='k'>in</span>
                <span class='k'>let</span> y <span class='k'>=</span> int_of_float (x_final <span class='o'>*.</span> 480.) <span class='k'>in</span>
                <span class='m'>Graphics</span><span class='o'>.</span>plot x y
        <span class='k'>done</span>
<span class='k'>done</span><span class='o'>;;</span>

read_line ()<span class='o'>;;</span>
</code></pre>
<p>
Entrambi gli esempi fanno uso di alcune caratteristiche di cui non
abbiamo ancora parlato: i loop for in stile imperativo, gli if-then-else
e la ricorsione. Ne parleremo più avanti. Cionondimeno dovreste guardare
questi programmi e provarli e trovare (1) come funzionano, e (2) come
l&apos;inferenza dei tipi vi aiuta ad eliminare i bug.</p>
<h3 id="IlmoduloPervasives"> Il modulo <code>Pervasives</code></h3><p>
C&apos;è un solo modulo per cui non serve mai usare &quot;<code>open</code>&quot;. È il modulo
<code>Pervasives</code> (andate ora a leggervi
<code>/usr/lib/ocaml/3.08/pervasives.mli</code>). Tutti i simboli del modulo
<code>Pervasives</code> sono importati automaticamente in qualunque programma
OCaml.</p>
<h3 id="Rinominaremoduli"> Rinominare moduli</h3><p>
Che cosa succede se volete utilizzare i simboli del modulo <code>Graphics</code>,
ma non volete importarli tutti e non sopportate il fastidio di digitare
<code>Graphics</code> ogni volta? Semplicemente rinominatelo usando questo trucco:</p>
<pre><code class='ocaml'><span class='k'>module</span> Gr <span class='k'>=</span> Graphics<span class='o'>;;</span>

<span class='m'>Gr</span><span class='o'>.</span>open_graph <span class='s'>&#34; 640x480&#34;</span><span class='o'>;;</span>
<span class='m'>Gr</span><span class='o'>.</span>fill_circle 320 240 240<span class='o'>;;</span>
read_line ()<span class='o'>;;</span>
</code></pre>
<p>
In realtà questo è utile quando volete importare un modulo annidato (i
moduli possono essere annidati l&apos;uno dentro l&apos;altro), ma non volete
digitare ogni volta il percorso completo per il modulo annidato.</p>
<h3 id="Usoedomissionedie"> Uso ed omissione di <code>;;</code> e <code>;</code></h3><p>
Veniamo ora ad esaminare una questione assai importante. Quando dovreste
usare <code>;;</code>, quando dovreste usare <code>;</code>, e quando non dovreste usare
affatto alcuno di essi? È una questione ingannevole finché non &quot;la
afferri&quot;, e ha messo a lungo alla prova l&apos;autore quando anch&apos;egli stava
imparando OCaml.</p>
<p>La regola n° 1 è che dovreste usare <code>;;</code> per separare istruzioni al più
altto livello del vostro codice, e <em>mai</em> all&apos;interno di definizioni di
funzioni o di qualunque altro tipo di istruzione.</p>
<p>Osservate una sezione dal secondo esempio su &quot;graphics&quot; sopra:</p>
<pre><code class='ocaml'><span class='m'>Random</span><span class='o'>.</span>self_init ()<span class='o'>;;</span>
<span class='m'>Graphics</span><span class='o'>.</span>open_graph <span class='s'>&#34; 640x480&#34;</span><span class='o'>;;</span>

<span class='k'>let rec</span> iterate r x_init i <span class='k'>=</span>
        <span class='k'>if</span> i <span class='o'>==</span> 1 <span class='k'>then</span> x_init
        <span class='k'>else</span>
                <span class='k'>let</span> x <span class='k'>=</span> iterate r x_init (i-1) <span class='k'>in</span>
                r <span class='o'>*.</span> x <span class='o'>*.</span> (1.0 <span class='o'>-.</span> x)<span class='o'>;;</span>
</code></pre>
<p>
Abbiamo due istruzioni del livello più alto ed una definizione di
funzione (per una funzione chiamata <code>iterate</code>). Ciascuna è seguita da
<code>;;</code>.</p>
<p>La regola n° 2 è che <em>a volte</em> potete elidere [omettere] il <code>;;</code>. Come
principianti non dovreste preoccuparvene - dovreste sempre immettere il
<code>;;</code> come stabilito dala regola n° 1. Ma dal momento che leggerete anche
una quantità di codice scritto da altre persone dovete sapere che a
volte possiamo elidere <code>;;</code>. I posti particolari in cui ciò è concesso
sono:</p>
<ul>
 <li>Prima della parola chiave <code>let</code>.
 </li>
 <li>Prima della parola chiave <code>open</code>.
 </li>
 <li>Prima della parola chiave <code>type</code>.
 </li>
 <li>Precisamente in fondo al file.
 </li>
 <li>Alcuni altri (assai rari) posti in cui OCaml può &quot;indovinare&quot; che
 ciò che segue è l&apos;inizio di una nuova istruzione e non la
 continuazione dell&apos;istruzione corrente.</li>
</ul>

<p>Ecco del codice funzionante con <code>;;</code> eliso ovunque possibile:</p>
<pre><code class='ocaml'><span class='k'>open</span> Random                   <span class='com2'>(* <span class='ic'>;;</span> *)</span><!-- end comment -->
<span class='k'>open</span> Graphics<span class='o'>;;</span>

self_init ()<span class='o'>;;</span>
open_graph <span class='s'>&#34; 640x480&#34;</span>         <span class='com2'>(* <span class='ic'>;;</span> *)</span><!-- end comment -->

<span class='k'>let rec</span> iterate r x_init i <span class='k'>=</span>
        <span class='k'>if</span> i <span class='o'>==</span> 1 <span class='k'>then</span> x_init
        <span class='k'>else</span>
                <span class='k'>let</span> x <span class='k'>=</span> iterate r x_init (i-1) <span class='k'>in</span>
                r <span class='o'>*.</span> x <span class='o'>*.</span> (1.0 <span class='o'>-.</span> x)<span class='o'>;;</span>

<span class='k'>for</span> x <span class='k'>=</span> 0 <span class='k'>to</span> 640 <span class='k'>do</span>
        <span class='k'>let</span> r <span class='k'>=</span> 4.0 <span class='o'>*.</span> (float_of_int x) <span class='o'>/.</span> 640.0 <span class='k'>in</span>
        <span class='k'>for</span> i <span class='k'>=</span> 0 <span class='k'>to</span> 39 <span class='k'>do</span>
                <span class='k'>let</span> x_init <span class='k'>=</span> <span class='m'>Random</span><span class='o'>.</span>float 1.0 <span class='k'>in</span>
                <span class='k'>let</span> x_final <span class='k'>=</span> iterate r x_init 500 <span class='k'>in</span>
                <span class='k'>let</span> y <span class='k'>=</span> int_of_float (x_final <span class='o'>*.</span> 480.) <span class='k'>in</span>
                <span class='m'>Graphics</span><span class='o'>.</span>plot x y
        <span class='k'>done</span>
<span class='k'>done</span><span class='o'>;;</span>

read_line ()                  <span class='com2'>(* <span class='ic'>;;</span> *)</span><!-- end comment -->
</code></pre>
<p>
Le regole n° 3 e n° 4 sono riferite al <code>;</code> singolo. Esso è del tutto
differente da <code>;;</code>. Il punto e virgola singolo <code>;</code> è ciò che è noto come
<strong>punto di sequenza</strong>, il che vuol dire che ha esattamente la stessa
funzione del punto e virgola singolo in C, C++, Java e Perl. Esso
significa &quot;fai la roba che c&apos;è prima di questo punto, poi fai lo roba
che c&apos;è dopo questo punto quando la prima roba è completata&quot;. Scommetto
che non lo sapevate.</p>
<p>La regola n° 3 è: Considera <code>let ... in</code> come un&apos;istruzione, e non porre
mai dopo di essa un singolo <code>;</code>.</p>
<p>La regola n° 4 è: Per tutte le altre istruzioni all&apos;interno di un blocco
di codice, falle seguire da un singolo <code>;</code>, <em>eccetto</em> per l&apos;ultima in
fondo.</p>
<p>Il ciclo for interno nel nostro esempio sopra è una buona dimostrazione.
Notate che in questo codice non usiamo mai un singolo <code>;</code>:</p>
<pre><code class='ocaml'>        <span class='k'>for</span> i <span class='k'>=</span> 0 <span class='k'>to</span> 39 <span class='k'>do</span>
                <span class='k'>let</span> x_init <span class='k'>=</span> <span class='m'>Random</span><span class='o'>.</span>float 1.0 <span class='k'>in</span>
                <span class='k'>let</span> x_final <span class='k'>=</span> iterate r x_init 500 <span class='k'>in</span>
                <span class='k'>let</span> y <span class='k'>=</span> int_of_float (x_final <span class='o'>*.</span> 480.) <span class='k'>in</span>
                <span class='m'>Graphics</span><span class='o'>.</span>plot x y
        <span class='k'>done</span>
</code></pre>
<p>
L&apos;unico posto nel codice sopra dove si potrebbe pensare di inserire un
<code>;</code> è dopo il <code>Graphics.plot x y</code>, ma poiché questa è l&apos;ultima
istruzione nel blocco, la regola n° 4 ci dice di non metterne uno lì.</p>
<p><strong>Nota sul &quot;;&quot;</strong> Brian Hurt scrive per correggermi sul &quot;;&quot;</p>
<p>Il <code>;</code> è un operatore, proprio come lo è il <code>+</code>. O meglio, non
esattamente come lo è <code>+</code>, ma concettualmente è lo stesso. <code>+</code> ha tipo
<code>int -&gt; int -&gt; int</code> - esso prende due int e restituisce un int (la
somma). <code>;</code> ha tipo <code>unit -&gt; &apos;b -&gt; &apos;b</code> - esso prende due valori e
semplicemente restituisce il secondo. Piuttosto come l&apos;operatore <code>,</code>
(virgola) del C. Potete scrivere <code>a ; b ; c ; d</code> con la facilità con cui
potete scrivere <code>a + b + c + d</code>.</p>
<p>Questo è uno di quei &quot;salti mentali&quot; che non sono mai spiegati molto
bene - in OCaml, pressoché ogni cosa è un&apos;espressione. <code>if/then/else</code> è
un&apos;espressione. <code>a ; b</code> è un&apos;espressione. <code>match foo with ...</code> è un
espressione. Il codice che segue è perfettamente legale (e tutto fa la
medesima cosa):</p>
<pre><code class='ocaml'><span class='k'>let</span> f x b y <span class='k'>=</span> <span class='k'>if</span> b <span class='k'>then</span> x<span class='o'>+</span>y <span class='k'>else</span> x<span class='o'>+</span>0

<span class='k'>let</span> f x b y <span class='k'>=</span> x <span class='o'>+</span> (<span class='k'>if</span> b <span class='k'>then</span> y <span class='k'>else</span> 0)

<span class='k'>let</span> f x b y <span class='k'>=</span> x <span class='o'>+</span> (<span class='k'>match</span> b <span class='k'>with</span> <span class='o'>true</span> <span class='k'>-></span> y <span class='o'>|</span> <span class='o'>false</span> <span class='k'>-></span> 0)

<span class='k'>let</span> f x b y <span class='k'>=</span> x <span class='o'>+</span> (<span class='k'>let</span> g z <span class='k'>=</span> <span class='k'>function</span> <span class='o'>true</span> <span class='k'>-></span> z <span class='o'>|</span> <span class='o'>false</span> <span class='k'>-></span> 0 <span class='k'>in</span> g y b)

<span class='k'>let</span> f x b y <span class='k'>=</span> x <span class='o'>+</span> (<span class='k'>let</span> <span class='o'>_</span> <span class='k'>=</span> y <span class='o'>+</span> 3 <span class='k'>in</span> ()<span class='o'>;</span> <span class='k'>if</span> b <span class='k'>then</span> y <span class='k'>else</span> 0)
</code></pre>
<p>
Si noti in special modo la prima - uso <code>;</code> come operatore per &quot;unire&quot;
due istruzioni. Tutte le funzioni in OCaml possono essere espresse come:</p>
<pre><code class='ocaml'><span class='k'>let</span> nome <span class='o'>[</span>parametri<span class='o'>]</span> <span class='k'>=</span> espressione
</code></pre>
<p>
La definizione di OCaml di che cos&apos;è un&apos;espressione è soltanto un po&apos;
più ampia che quella di C. Infatti, C ha il concetto di &quot;istruzione&quot; -
ma tutte le istruzioni di C sono in OCaml semplicemente espressioni
(combinate con l&apos;operatore <code>;</code>).</p>
<p>L&apos;unico punto in cui <code>;</code> differisce da <code>+</code> è che posso fare riferimento
a <code>+</code> semplicemente come ad una funzione. Ad esempio, posso definire una
funzione <code>sum_list</code>, per sommare una lista di int, come segue:</p>
<pre><code class='ocaml'><span class='k'>let</span> sum_list <span class='k'>=</span> <span class='m'>List</span><span class='o'>.</span>fold_left ( <span class='o'>+</span> ) 0
</code></pre>
<h3 id="Metteretuttoinsiemedelcodicereale"> Mettere tutto insieme: del codice reale</h3><p>

In questa sezione mostreremo dei frammenti di codice reale provenienti
dalla libreria lablgtk 1.2. (Lablgtk è l&apos;interfaccia di OCaml alla
libreria nativa Unix degli accessori di Gtk). Un&apos;avvertenza: questi
frammenti contengono parecchie idee che non abbiamo ancora discusse. Non
guardate i dettagli, guardate piuttosto l&apos;aspetto complessivo del
codice, dove gli autori hanno usato <code>;;</code>, dove hanno usato <code>;</code> e dove
hanno usato <code>open</code>, come hanno indentato il codice, come hanno usato
espressioni con nomi locali e globali.</p>
<p>... Vi darò però degli indizi, perché non vi perdiate totalmente!</p>
<ul>
 <li><code>?foo</code> e <code>~foo</code> è la maniera di OCaml di dare argomenti opzionali e
 dotati di nome alle funzioni. Non v&apos;è alcun reale parallelo a ciò in
 linguaggi derivati da C, ma Perl,Python e Smalltalk hanno tutti
 questo concetto per cui è possibile nominare gli argomenti in una
 chiamata di funzione, ometterne alcuni e fornire gli altri
 nell&apos;ordine che si preferisce.
 </li>
 <li><code>foo#bar</code> è un&apos;invocazione di metodo (chiamare un metodo di nome
 <code>bar</code> su un oggetto di nome <code>foo</code>). È simile a <code>foo-&gt;bar</code> o
 <code>foo.bar</code> o <code>$foo-&gt;bar</code> rispettivamente in C++, Java o Perl.</li>
</ul>

<p>Primo frammento: Il programmatore apre un paio di librerie standard
(elidendo <code>;;</code> poiché la successiva parola chiave è rispettivamente
<code>open</code> e <code>let</code>). Egli crea quindi una funzione chiamata <code>file_dialog</code>.
All&apos;interno di questa funzione definisce un&apos;espressione con nome
chiamata <code>sel</code> usando un&apos;istruzione <code>let sel = ... in</code> su due righe.
Quindi chiama diversi metodi su <code>sel</code>.</p>
<pre><code class='ocaml'><span class='com2'>(* Primo frammento *)</span><!-- end comment -->

<span class='k'>open</span> StdLabels
<span class='k'>open</span> GMain

<span class='k'>let</span> file_dialog <span class='o'>~</span>title <span class='o'>~</span>callback <span class='o'>?</span>filename () <span class='k'>=</span>
  <span class='k'>let</span> sel <span class='k'>=</span>
    <span class='m'>GWindow</span><span class='o'>.</span>file_selection <span class='o'>~</span>title <span class='o'>~</span>modal<span class='o'>:</span><span class='o'>true</span> <span class='o'>?</span>filename () <span class='k'>in</span>
  sel<span class='o'>#</span>cancel_button<span class='o'>#</span>connect<span class='o'>#</span>clicked <span class='o'>~</span>callback<span class='o'>:</span>sel<span class='o'>#</span>destroy<span class='o'>;</span>
  sel<span class='o'>#</span>ok_button<span class='o'>#</span>connect<span class='o'>#</span>clicked <span class='o'>~</span>callback<span class='o'>:</span>do_ok<span class='o'>;</span>
  sel<span class='o'>#</span>show ()
</code></pre>
<p>
Secondo frammento: Solo una lunga lista di nomi globali al livello
superiore. Notate che l&apos;autore ha eliso ogni singolo <code>;;</code> grazie alla
regola n° 2.</p>
<pre><code class='ocaml'><span class='com2'>(* Secondo frammento *)</span><!-- end comment -->

<span class='k'>let</span> window <span class='k'>=</span> <span class='m'>GWindow</span><span class='o'>.</span>window <span class='o'>~</span>width<span class='o'>:</span>500 <span class='o'>~</span>height<span class='o'>:</span>300 <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;editor&#34;</span> ()
<span class='k'>let</span> vbox <span class='k'>=</span> <span class='m'>GPack</span><span class='o'>.</span>vbox <span class='o'>~</span>packing<span class='o'>:</span>window<span class='o'>#</span>add ()

<span class='k'>let</span> menubar <span class='k'>=</span> <span class='m'>GMenu</span><span class='o'>.</span>menu_bar <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>pack ()
<span class='k'>let</span> factory <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GMenu</span><span class='o'>.</span>factory menubar
<span class='k'>let</span> accel_group <span class='k'>=</span> factory<span class='o'>#</span>accel_group
<span class='k'>let</span> file_menu <span class='k'>=</span> factory<span class='o'>#</span>add_submenu <span class='s'>&#34;File&#34;</span>
<span class='k'>let</span> edit_menu <span class='k'>=</span> factory<span class='o'>#</span>add_submenu <span class='s'>&#34;Edit&#34;</span>

<span class='k'>let</span> hbox <span class='k'>=</span> <span class='m'>GPack</span><span class='o'>.</span>hbox <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>add ()
<span class='k'>let</span> editor <span class='k'>=</span> <span class='k'>new</span> editor <span class='o'>~</span>packing<span class='o'>:</span>hbox<span class='o'>#</span>add ()
<span class='k'>let</span> scrollbar <span class='k'>=</span> <span class='m'>GRange</span><span class='o'>.</span>scrollbar `VERTICAL <span class='o'>~</span>packing<span class='o'>:</span>hbox<span class='o'>#</span>pack ()
</code></pre>
<p>
Terzo frammento: L&apos;autore importa tutti i simboli dal modulo
<code>GdkKeysyms</code>. Ora abbiamo un inusuale let-binding. <code>let _ = espressione</code>
significa &quot;calcola il valore dell&apos;espressione (con tutti gli effetti
laterali che può comportare), ma getta via il risultato&quot;. In questo
caso, &quot;calcola il valore dell&apos;espressione&quot; significa eseguire
<code>Main.main ()</code> che è il loop principale (main) di Gtk, che ha l&apos;effetto
laterale di far sbucare la finestra sullo schermo ed eseguire l&apos;intera
applicazione. Il &quot;risultato&quot; di <code>Main.main ()</code> è insignificante -
probabilmente un valore di ritorno <code>unit</code>, ma non ho verificato - e non
è restituito finché l&apos;applicazione non esce infine.</p>
<p>Notate che in questo frammento abbiamo una lunga serie di comandi
essenzialmente procedurali. Questo è in realtà un classico programma
imperativo.</p>
<pre><code class='ocaml'><span class='com2'>(* Terzo frammento *)</span><!-- end comment -->

<span class='k'>open</span> GdkKeysyms

<span class='k'>let</span> <span class='o'>_</span> <span class='k'>=</span>
  window<span class='o'>#</span>connect<span class='o'>#</span>destroy <span class='o'>~</span>callback<span class='o'>:</span><span class='m'>Main</span><span class='o'>.</span>quit<span class='o'>;</span>
  <span class='k'>let</span> factory <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GMenu</span><span class='o'>.</span>factory file_menu <span class='o'>~</span>accel_group <span class='k'>in</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Open...&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>O <span class='o'>~</span>callback<span class='o'>:</span>editor<span class='o'>#</span>open_file<span class='o'>;</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Save&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>S <span class='o'>~</span>callback<span class='o'>:</span>editor<span class='o'>#</span>save_file<span class='o'>;</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Save as...&#34;</span> <span class='o'>~</span>callback<span class='o'>:</span>editor<span class='o'>#</span>save_dialog<span class='o'>;</span>
  factory<span class='o'>#</span>add_separator ()<span class='o'>;</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Quit&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>Q <span class='o'>~</span>callback<span class='o'>:</span>window<span class='o'>#</span>destroy<span class='o'>;</span>
  <span class='k'>let</span> factory <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GMenu</span><span class='o'>.</span>factory edit_menu <span class='o'>~</span>accel_group <span class='k'>in</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Copy&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>C <span class='o'>~</span>callback<span class='o'>:</span>editor<span class='o'>#</span>text<span class='o'>#</span>copy_clipboard<span class='o'>;</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Cut&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>X <span class='o'>~</span>callback<span class='o'>:</span>editor<span class='o'>#</span>text<span class='o'>#</span>cut_clipboard<span class='o'>;</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Paste&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>V <span class='o'>~</span>callback<span class='o'>:</span>editor<span class='o'>#</span>text<span class='o'>#</span>paste_clipboard<span class='o'>;</span>
  factory<span class='o'>#</span>add_separator ()<span class='o'>;</span>
  factory<span class='o'>#</span>add_check_item <span class='s'>&#34;Word wrap&#34;</span> <span class='o'>~</span>active<span class='o'>:</span><span class='o'>false</span>
    <span class='o'>~</span>callback<span class='o'>:</span>editor<span class='o'>#</span>text<span class='o'>#</span>set_word_wrap<span class='o'>;</span>
  factory<span class='o'>#</span>add_check_item <span class='s'>&#34;Read only&#34;</span> <span class='o'>~</span>active<span class='o'>:</span><span class='o'>false</span>
    <span class='o'>~</span>callback<span class='o'>:</span>(<span class='k'>fun</span> b <span class='k'>-></span> editor<span class='o'>#</span>text<span class='o'>#</span>set_editable (not b))<span class='o'>;</span>
  window<span class='o'>#</span>add_accel_group accel_group<span class='o'>;</span>
  editor<span class='o'>#</span>text<span class='o'>#</span>event<span class='o'>#</span>connect<span class='o'>#</span>button_press
    <span class='o'>~</span>callback<span class='o'>:</span>(<span class='k'>fun</span> ev <span class='k'>-></span>

      <span class='k'>let</span> button <span class='k'>=</span> <span class='m'>GdkEvent</span><span class='o'>.</span><span class='m'>Button</span><span class='o'>.</span>button ev <span class='k'>in</span>
      <span class='k'>if</span> button <span class='k'>=</span> 3 <span class='k'>then</span> <span class='k'>begin</span>
        file_menu<span class='o'>#</span>popup <span class='o'>~</span>button <span class='o'>~</span>time<span class='o'>:</span>(<span class='m'>GdkEvent</span><span class='o'>.</span><span class='m'>Button</span><span class='o'>.</span>time ev)<span class='o'>;</span> <span class='o'>true</span>
      <span class='k'>end</span> <span class='k'>else</span> <span class='o'>false</span>)<span class='o'>;</span>
  editor<span class='o'>#</span>text<span class='o'>#</span>set_vadjustment scrollbar<span class='o'>#</span>adjustment<span class='o'>;</span>
  window<span class='o'>#</span>show ()<span class='o'>;</span>
  <span class='m'>Main</span><span class='o'>.</span>main ()

</code></pre>
