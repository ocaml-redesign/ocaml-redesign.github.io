<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title> &#8211; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" />
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet" />
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen" />
    <link href="/static/css/opamdoc.css" rel="stylesheet" media="screen" />
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <script type="text/javascript">
      function octry(x){
        if(document.getElementById('buttons').innerHTML=='') {
          t = document.getElementById('tryocaml');
          js = document.createElement("script"); js.type = "text/javascript"; js.src = "/try-ocaml.js";
          t.appendChild(js);
        } else {
          t = document.getElementById('tryocaml');
          t.style.display = 'block';
          document.getElementById('console').value = x;
          document.getElementById('console').focus();
          document.getElementById('console').select();
        }
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml" /></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/pkg/">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
        <div class="container">
      <div class="row">



          <div id='main-contents' class="content">
            <h1 id="PerformanceandProfiling"> Performance and Profiling</h1><h2 id="ObQuote"> ObQuote...</h2><p>

<em>&quot;One serious obstacle to the adoption of good programming languages is
the notion that everything has to be sacrificed for speed. In computer
languages as in life, speed kills.&quot; â€” Mike Vanier</em></p>
<h2 id="Speed"> Speed</h2><p>
Why is OCaml fast? Indeed, step back and ask <em>is OCaml fast?</em> How can we
make programs faster? In this chapter we&#39;ll look at what actually
happens when you compile your OCaml programs down to machine code. This
will help in understanding why OCaml is not just a great language for
programming, but is also a very fast language indeed. And it&#39;ll help you
to help the compiler write better machine code for you. It&#39;s also (I
believe anyway) a good thing for programmers to have some idea of what
happens between you typing <code>ocamlopt</code> and getting a binary you can run.</p>
<p>But you will need to know some assembler to get the most out of this
section. Don&#39;t be afraid! I&#39;ll help you out by translating the assembler
into a C-like pseudocode (after all C is just a portable assembly
language).</p>
<h3 id="Basicsofassemblylanguage"> Basics of assembly language</h3><p>
The examples I give in this chapter are all compiled on an x86 Linux
machine. The x86 is, of course, a 32 bit machine, so an x86 &quot;word&quot; is 4
bytes (= 32 bits) long. At this level OCaml deals mostly with word-sized
objects, so you&#39;ll need to remember to multiply by four to get the size
in bytes.</p>
<p>To refresh your memory, the x86 has only a small number of general
purpose registers, each of which can store one word. The Linux assembler
puts <code>%</code> in front of register names. The registers are: <code>%eax</code>, <code>%ebx</code>,
<code>%ecx</code>, <code>%edx</code>, <code>%esi</code>, <code>%edi</code>, <code>%ebp</code> (special register used for stack
frames), and <code>%esp</code> (the stack pointer).</p>
<p>The Linux assembler (in common with other Unix assemblers, but opposite
to MS-derived assemblers) writes moves to and from registers/memory as:</p>
<pre><code class='ocaml'>movl from<span class='o'>,</span> <span class='k'>to</span>
<a href="javascript:octry('movl from, to\n');">[try]</a></code></pre>
<p>
So <code>movl %ebx, %eax</code> means &quot;copy the contents of register <code>%ebx</code> into
register <code>%eax</code>&quot; (not the other way round).</p>
<p>Almost all of the assembly language that we will look at is going to be
dominated not by machine code instructions like <code>movl</code> but by what are
known as \&lt;dfn\&gt;assembler directives\&lt;/dfn\&gt;. These directives begin
with a . (period) and they literally <em>direct</em> the assembler to do
something. Here are the common ones for the Linux assembler:</p>
<p><strong>.text</strong></p>
<p><strong>Text</strong> is the Unix way of saying &quot;program code&quot;. The <strong>text segment</strong>
simply means the part of the executable where program code is stored.
The <code>.text</code> directive switches the assembler so it starts writing into
the text segment.</p>
<p><strong>.data</strong></p>
<p>Similarly, the <code>.data</code> directive switches the assembler so it starts
writing into the data segment (part) of the executable.</p>
<pre><code class='ocaml'>  <span class='o'>.</span>globl foo
foo<span class='o'>:</span>
<a href="javascript:octry('  .globl foo\nfoo:\n');">[try]</a></code></pre>
<p>
This declares a global symbol called <code>foo</code>. It means the address of the
next thing to come can be named <code>foo</code>. Writing just <code>foo:</code> without the
preceeding <code>.globl</code> directive declares a local symbol (local to just the
current file).</p>
<pre><code class='ocaml'><span class='o'>.</span>long 12345
<span class='o'>.</span>byte 9
<span class='o'>.</span>ascii <span class='s'>&#34;hello&#34;</span>
<span class='o'>.</span>space 4
<a href="javascript:octry('.long 12345\n.byte 9\n.ascii &#34;hello&#34;\n.space 4\n');">[try]</a></code></pre>
<p>
<code>.long</code> writes a word (4 bytes) to the current segment. <code>.byte</code> writes a
single byte. <code>.ascii</code> writes a string of bytes (NOT nul-terminated).
<code>.space</code> writes the given number of zero bytes. Normally you use these
in the data segment.</p>
<h3 id="Thequothelloworldquotprogram"> The &quot;hello, world&quot; program</h3><p>
Enough assembler. Put the following program into a file called
<code>smallest.ml</code>:</p>
<pre><code class='ocaml'>print_string <span class='s'>&#34;hello, world\n&#34;</span>
<a href="javascript:octry('print_string &#34;hello, world\n&#34;\n');">[try]</a></code></pre>
<p>
And compile it to a native code executable using:</p>
<pre><code class='ocaml'>ocamlopt <span class='o'>-</span>S smallest<span class='o'>.</span>ml <span class='o'>-</span>o smallest
<a href="javascript:octry('ocamlopt -S smallest.ml -o smallest\n');">[try]</a></code></pre>
<p>
The <code>-S</code> (capital S) tells the compiler to leave the assembly language
file (called <code>smallest.s</code> - lowercase s) instead of deleting it.</p>
<p>Here are the edited highlights of the <code>smallest.s</code> file with my comments
added. First of all the data segment:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>data
        <span class='o'>.</span>long   4348                     <span class='o'>;</span> header <span class='k'>for</span> string
        <span class='o'>.</span>globl  Smallest__1
Smallest__1<span class='o'>:</span>
        <span class='o'>.</span>ascii  <span class='s'>&#34;hello, world\12&#34;</span>        <span class='o'>;</span> string
        <span class='o'>.</span>space  2                        <span class='o'>;</span> padding <span class='o'>..</span>
        <span class='o'>.</span>byte   2                        <span class='o'>;</span>  <span class='o'>..</span> after string
<a href="javascript:octry('        .data\n        .long   4348                     ; header for string\n        .globl  Smallest__1\nSmallest__1:\n        .ascii  &#34;hello, world\12&#34;        ; string\n        .space  2                        ; padding ..\n        .byte   2                        ;  .. after string\n');">[try]</a></code></pre>
<p>
Next up the text (program code) segment:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>text
        <span class='o'>.</span>globl  Smallest__entry          <span class='o'>;</span> entry point <span class='k'>to</span> the program
Smallest__entry<span class='o'>:</span>

        <span class='o'>;</span> this is equivalent <span class='k'>to</span> the C pseudo<span class='o'>-</span>code<span class='o'>:</span>
        <span class='o'>;</span> <span class='m'>Pervasives</span><span class='o'>.</span>output_string (stdout<span class='o'>,</span> <span class='o'>&#38;</span>Smallest__1)

        movl    <span class='o'>$</span>Smallest__1<span class='o'>,</span> <span class='o'>%</span>ebx
        movl    Pervasives <span class='o'>+</span> 92<span class='o'>,</span> <span class='o'>%</span>eax    <span class='o'>;</span> Pervasives <span class='o'>+</span> 92 <span class='o'>==</span> stdout
        call    Pervasives__output_string_212

        <span class='o'>;</span> return 1

        movl    <span class='o'>$</span>1<span class='o'>,</span> <span class='o'>%</span>eax
        ret
<a href="javascript:octry('        .text\n        .globl  Smallest__entry          ; entry point to the program\nSmallest__entry:\n\n        ; this is equivalent to the C pseudo-code:\n        ; Pervasives.output_string (stdout, &#38;Smallest__1)\n\n        movl    $Smallest__1, %ebx\n        movl    Pervasives + 92, %eax    ; Pervasives + 92 == stdout\n        call    Pervasives__output_string_212\n\n        ; return 1\n\n        movl    $1, %eax\n        ret\n');">[try]</a></code></pre>
<p>
In C everything has to be inside a function. Think about how you can&#39;t
just write <code>printf (&quot;hello, world\n&quot;);</code> in C, but instead you have to
put it inside <code>main () { ... }</code>. In OCaml you are allowed to have
commands at the top level, not inside a function. But when we translate
this into assembly language, where do we put those commands? There needs
to be some way to call those commands from outside, so they need to be
labelled in some way. As you can see from the code snippet, OCaml solves
this by taking the filename (<code>smallest.ml</code>), capitalizing it and adding
<code>__entry</code>, thus making up a symbol called <code>Smallest__entry</code> to refer to
the top level commands in this file.</p>
<p>Now look at the code that OCaml has generated. The original code said
<code>print_string &quot;hello, world\n&quot;</code>, but OCaml has instead compiled the
equivalent of <code>Pervasives.output_string stdout &quot;hello, world\n&quot;</code>. Why?
If you look into <code>pervasives.ml</code> you&#39;ll see why:</p>
<pre><code class='ocaml'><span class='k'>let</span> print_string s <span class='k'>=</span> output_string stdout s
<a href="javascript:octry('let print_string s = output_string stdout s\n');">[try]</a></code></pre>
<p>
OCaml has <em>inlined</em> this function. <strong>Inlining</strong> - taking a function and
expanding it from its definition - is sometimes a performance win,
because it avoids the overhead of an extra function call, and it can
lead to more opportunities for the optimizer to do its thing. Sometimes
inlining is not good, because it can lead to code bloating, and thus
destroys the good work done by the processor cache (and besides function
calls are actually not very expensive at all on modern processors).
OCaml will inline simple calls like this, because they are essentially
risk free, almost always leading to a small performance gain.</p>
<p>What else can we notice about this? The calling convention seems to be
that the first two arguments are passed in the <code>%eax</code> and <code>%ebx</code>
registers respectively. Other arguments are probably passed on the
stack, but we&#39;ll see about that later.</p>
<p>C programs have a simple convention for storing strings, known as
<strong>ASCIIZ</strong>. This just means that the string is stored in ASCII, followed
by a trailing NUL (<code>\0</code>) character. OCaml stores strings in a different
way, as we can see from the data segment above. This string is stored
like this:</p>
<pre><code class='ocaml'>4 byte header<span class='o'>:</span> 4348
the string<span class='o'>:</span>    h e l l o <span class='o'>,</span> SP w o r l d <span class='o'>\</span>n
padding<span class='o'>:</span>       <span class='o'>\</span>0 <span class='o'>\</span>0 <span class='o'>\</span>002
<a href="javascript:octry('4 byte header: 4348\nthe string:    h e l l o , SP w o r l d \n\npadding:       \0 \0 \002\n');">[try]</a></code></pre>
<p>
The format is unusual. It&#39;s documented in <a href='http://caml.inria.fr/pub/ml-archives/caml-list/2002/08/e109df224ff0150b302033e2002dbf87.en.html' title='http://caml.inria.fr/pub/ml-archives/caml-list/2002/08/e109df224ff0150b302033e2002dbf87.en.html'>this posting on the OCaml
mailing
list</a>.
\&lt;!-- (old: http://caml.inria.fr/archives/200208/msg00463.html) --\&gt;</p>
<p>Firstly the padding brings the total length of the string up to a whole
number of words (4 words, 16 bytes in this example). The padding is
carefully designed so that you can work out the actual length of the
string in bytes, provided that you know the total number of <em>words</em>
allocated to the string. The encoding for this is unambiguous (which you
can prove to yourself).</p>
<p>One nice feature of having strings with an explicit length is that you
can represent strings containing ASCII NUL (<code>\0</code>) characters in them,
something which is difficult to do in C. However, the flip side is that
you need to be aware of this if you pass an OCaml string to some C
native code: if it contains ASCII NUL, then the C <code>str*</code> functions will
fail on it.</p>
<p>Secondly we have the header. Every boxed (allocated) object in OCaml has
a header which tells the garbage collector about how large the object is
in words, and something about what the object contains. Writing the
number 4348 in binary:</p>
<pre><code class='ocaml'>length <span class='k'>of</span> the object <span class='k'>in</span> words<span class='o'>:</span>  0000 0000 0000 0000 0001 00 (4 words)
color (used by GC)<span class='o'>:</span>             00
tag<span class='o'>:</span>                            1111 1100 (String_tag)
<a href="javascript:octry('length of the object in words:  0000 0000 0000 0000 0001 00 (4 words)\ncolor (used by GC):             00\ntag:                            1111 1100 (String_tag)\n');">[try]</a></code></pre>
<p>
See <code>/usr/include/ocaml/3.08/caml/mlvalues.h</code> for more information about
the format of heap allocated objects in OCaml.</p>
<p>One unusual thing is that the code passes a pointer to the start of the
string (ie. the word immediately after the header) to
<code>Pervasives.output_string</code>. This means that <code>output_string</code> must
subtract 4 from the pointer to get at the header to determine the length
of the string.</p>
<p>What have I missed out from this simple example? Well, the text segment
above is not the whole story. It would be really nice if OCaml
translated that simple hello world program into just the five lines of
assembler shown above. But there is the question of what actually calls
<code>Smallest__entry</code> in the real program. For this OCaml includes a whole
load of bootstrapping code which does things like starting up the
garbage collector, allocating and initializing memory, calling
initializers in libraries and so on. OCaml links all of this code
statically to the final executable, which is why the program I end up
with (on Linux) weighs in at a portly 95,442 bytes. Nevertheless the
start-up time for the program is still unmeasurably small (under a
millisecond), compared to several seconds for starting up a reasonable
Java program and a second or so for a Perl script.</p>
<h3 id="Tailrecursion"> Tail recursion</h3><p>
We mentioned in chapter 6 that OCaml can turn tail-recursive function
calls into simple loops. Is this actually true? Let&#39;s look at what
simple tail recursion compiles to:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> loop () <span class='k'>=</span>
  print_string <span class='s'>&#34;I go on forever ...&#34;</span><span class='o'>;</span>
  loop ()

<span class='k'>let</span> () <span class='k'>=</span> loop ()
<a href="javascript:octry('let rec loop () =\n  print_string &#34;I go on forever ...&#34;;\n  loop ()\n\nlet () = loop ()\n');">[try]</a></code></pre>
<p>
The file is called <code>tail.ml</code>, so following OCaml&#39;s usual procedure for
naming functions, our function will be called <code>Tail__loop_nnn</code> (where
<code>nnn</code> is some unique number which OCaml appends to distinguish
identically named functions from one another).</p>
<p>Here is the assembler for just the <code>loop</code> function defined above:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>text
        <span class='o'>.</span>globl  Tail__loop_56
Tail__loop_56<span class='o'>:</span>
<span class='o'>.</span>L100<span class='o'>:</span>

        <span class='o'>;</span> Print the string

        movl    <span class='o'>$</span>Tail__2<span class='o'>,</span> <span class='o'>%</span>ebx
        movl    Pervasives <span class='o'>+</span> 92<span class='o'>,</span> <span class='o'>%</span>eax
        call    <span class='m'>Pervasives__output_string_212</span>
<span class='o'>.</span>L101<span class='o'>:</span>

        <span class='o'>;</span> The following movl is <span class='k'>in</span> fact obsolete<span class='o'>:</span>

        movl    <span class='o'>$</span>1<span class='o'>,</span> <span class='o'>%</span>eax

        <span class='o'>;</span> Jump back <span class='k'>to</span> the <span class='o'>.</span>L100 label above (ie<span class='o'>.</span> loop forever)

        jmp     <span class='o'>.</span>L100
<a href="javascript:octry('        .text\n        .globl  Tail__loop_56\nTail__loop_56:\n.L100:\n\n        ; Print the string\n\n        movl    $Tail__2, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n.L101:\n\n        ; The following movl is in fact obsolete:\n\n        movl    $1, %eax\n\n        ; Jump back to the .L100 label above (ie. loop forever)\n\n        jmp     .L100\n');">[try]</a></code></pre>
<p>
So that&#39;s pretty conclusive. Calling <code>Tail__loop_56</code> will first print
the string, and then jump back to the top, then print the string, and
jump back, and so on forever. It&#39;s a simple loop, <em>not</em> a recursive
function call, so it doesn&#39;t use any stack space.</p>
<h3 id="DigressionWherearethetypes"> Digression: Where are the types?</h3><p>
OCaml is statically typed as we&#39;ve said before on many occasions, so at
compile time, OCaml knows that the type of <code>loop</code> is <code>unit -&gt; unit</code>. It
knows that the type of <code>&quot;hello, world\n&quot;</code> is <code>string</code>. It doesn&#39;t make
any attempt to communicate this fact to the <code>output_string</code> function.
<code>output_string</code> is expecting a <code>channel</code> and a <code>string</code> as arguments,
and indeed that&#39;s what it gets. What would happen if we passed, say, an
<code>int</code> instead of a <code>string</code>?</p>
<p>This is essentially an impossible condition. Because OCaml knows the
types at compile time, it doesn&#39;t need to deal with types or check types
at run time. There is no way, in pure OCaml, to &quot;trick&quot; the compiler
into generating a call to <code>Pervasives.output_string stdout 1</code>. Such an
error would be flagged at compile time, by type inference, and so could
never be compiled.</p>
<p>The upshot is that by the time we have compiled OCaml code to assembler
type information mostly isn&#39;t required, certainly in the cases we&#39;ve
looked at above where the type is fully known at compile time, and there
is no polymorphism going on.</p>
<p>Fully knowing all your types at compile time is a major performance win
because it totally avoids any dynamic type checking at run time. Compare
this to a Java method invocation for example: <code>obj.method ()</code>. This is
an expensive operation because you need to find the concrete class that
<code>obj</code> is an instance of, and then look up the method, and you need to do
all of this potentially <em>every</em> time you call any method. Casting
objects is another case where you need to do a considerable amount of
work at run time in Java. None of this is allowed with OCaml&#39;s static
types.</p>
<h3 id="Polymorphictypes"> Polymorphic types</h3><p>
As you might have guessed from the discussion above, polymorphism, which
is where the compiler <em>doesn&#39;t</em> have a fully known type for a function
at compile time, might have an impact on performance. Suppose we require
a function to work out the maximum of two integers. Our first attempt
is:</p>
<pre><code class='ocaml'><span class='k'>let</span> max a b <span class='k'>=</span>
  <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> a <span class='k'>else</span> b
<a href="javascript:octry('let max a b =\n  if a &#62; b then a else b\n');">[try]</a></code></pre>
<p>
Simple enough, but recall that the \&gt; (greater than) operator in OCaml
is polymorphic. It has type <code>&#39;a -&gt; &#39;a -&gt; bool</code>, and this means that the
<code>max</code> function we defined above is going to be polymorphic:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> max a b <span class='k'>=</span>
    <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> a <span class='k'>else</span> b
<a href="javascript:octry('  let max a b =\n    if a &#62; b then a else b\n');">[try]</a></code></pre>
<p>
This is indeed reflected in the code that OCaml generates for this
function, which is pretty complex:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>text
        <span class='o'>.</span>globl  Max__max_56
Max__max_56<span class='o'>:</span>

        <span class='o'>;</span> Reserve two words <span class='k'>of</span> stack space<span class='o'>.</span>

        subl    <span class='o'>$</span>8<span class='o'>,</span> <span class='o'>%</span>esp

        <span class='o'>;</span> Save the first <span class='k'>and</span> second arguments (a <span class='k'>and</span> b) on the stack<span class='o'>.</span>

        movl    <span class='o'>%</span>eax<span class='o'>,</span> 4<span class='o'>(%</span>esp)
        movl    <span class='o'>%</span>ebx<span class='o'>,</span> 0<span class='o'>(%</span>esp)

        <span class='o'>;</span> Call the C <span class='s'>&#34;greaterthan&#34;</span> <span class='k'>function</span> (<span class='k'>in</span> the OCaml library)<span class='o'>.</span>

        pushl   <span class='o'>%</span>ebx
        pushl   <span class='o'>%</span>eax
        movl    <span class='o'>$</span>greaterthan<span class='o'>,</span> <span class='o'>%</span>eax
        call    caml_c_call
<span class='o'>.</span>L102<span class='o'>:</span>
        addl    <span class='o'>$</span>8<span class='o'>,</span> <span class='o'>%</span>esp

        <span class='o'>;</span> If the C <span class='s'>&#34;greaterthan&#34;</span> <span class='k'>function</span> returned 1<span class='o'>,</span> jump <span class='k'>to</span> <span class='o'>.</span>L100

        cmpl    <span class='o'>$</span>1<span class='o'>,</span> <span class='o'>%</span>eax
        je      <span class='o'>.</span>L100

        <span class='o'>;</span> Returned 0<span class='o'>,</span> so get argument a which we previously saved on
        <span class='o'>;</span> the stack <span class='k'>and</span> return it<span class='o'>.</span>

        movl    4<span class='o'>(%</span>esp)<span class='o'>,</span> <span class='o'>%</span>eax
        addl    <span class='o'>$</span>8<span class='o'>,</span> <span class='o'>%</span>esp
        ret

        <span class='o'>;</span> Returned 1<span class='o'>,</span> so get argument b which we previously saved on
        <span class='o'>;</span> the stack <span class='k'>and</span> return it<span class='o'>.</span>

<span class='o'>.</span>L100<span class='o'>:</span>
        movl    0<span class='o'>(%</span>esp)<span class='o'>,</span> <span class='o'>%</span>eax
        addl    <span class='o'>$</span>8<span class='o'>,</span> <span class='o'>%</span>esp
        ret
<a href="javascript:octry('        .text\n        .globl  Max__max_56\nMax__max_56:\n\n        ; Reserve two words of stack space.\n\n        subl    $8, %esp\n\n        ; Save the first and second arguments (a and b) on the stack.\n\n        movl    %eax, 4(%esp)\n        movl    %ebx, 0(%esp)\n\n        ; Call the C &#34;greaterthan&#34; function (in the OCaml library).\n\n        pushl   %ebx\n        pushl   %eax\n        movl    $greaterthan, %eax\n        call    caml_c_call\n.L102:\n        addl    $8, %esp\n\n        ; If the C &#34;greaterthan&#34; function returned 1, jump to .L100\n\n        cmpl    $1, %eax\n        je      .L100\n\n        ; Returned 0, so get argument a which we previously saved on\n        ; the stack and return it.\n\n        movl    4(%esp), %eax\n        addl    $8, %esp\n        ret\n\n        ; Returned 1, so get argument b which we previously saved on\n        ; the stack and return it.\n\n.L100:\n        movl    0(%esp), %eax\n        addl    $8, %esp\n        ret\n');">[try]</a></code></pre>
<p>
Basically the \&gt; operation is done by calling a C function from the
OCaml library. This is obviously not going to be very efficient, nothing
like as efficient as if we could generate some quick inline assembly
language for doing the \&gt;.</p>
<p>This is not a complete dead loss by any means. All we need to do is to
hint to the OCaml compiler that the arguments are in fact integers. Then
OCaml will generate a specialised version of <code>max</code> which only works on
<code>int</code> arguments:</p>
<pre><code class='ocaml'><span class='k'>let</span> max (a <span class='o'>:</span> int) (b <span class='o'>:</span> int) <span class='k'>=</span>
  <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> a <span class='k'>else</span> b
<a href="javascript:octry('let max (a : int) (b : int) =\n  if a &#62; b then a else b\n');">[try]</a></code></pre>
<p>
Here is the assembly code generated for this function:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>text
        <span class='o'>.</span>globl  Max_int__max_56
Max_int__max_56<span class='o'>:</span>

        <span class='o'>;</span> Single assembly instruction <span class='s'>&#34;cmpl&#34;</span> <span class='k'>for</span> performing the <span class='o'>&#62;</span> op<span class='o'>.</span>

        cmpl    <span class='o'>%</span>ebx<span class='o'>,</span> <span class='o'>%</span>eax

        <span class='o'>;</span> If <span class='o'>%</span>ebx <span class='o'>&#62;</span> <span class='o'>%</span>eax<span class='o'>,</span> jump <span class='k'>to</span> <span class='o'>.</span>L100

        jle     <span class='o'>.</span>L100

        <span class='o'>;</span> Just return argument a<span class='o'>.</span>

        ret

        <span class='o'>;</span> Return argument b<span class='o'>.</span>

<span class='o'>.</span>L100<span class='o'>:</span>
        movl    <span class='o'>%</span>ebx<span class='o'>,</span> <span class='o'>%</span>eax
        ret
<a href="javascript:octry('        .text\n        .globl  Max_int__max_56\nMax_int__max_56:\n\n        ; Single assembly instruction &#34;cmpl&#34; for performing the &#62; op.\n\n        cmpl    %ebx, %eax\n\n        ; If %ebx &#62; %eax, jump to .L100\n\n        jle     .L100\n\n        ; Just return argument a.\n\n        ret\n\n        ; Return argument b.\n\n.L100:\n        movl    %ebx, %eax\n        ret\n');">[try]</a></code></pre>
<p>
That&#39;s just 5 lines of assembler, and is about as simple as you can make
it.</p>
<p>What about this code:</p>
<pre><code class='ocaml'><span class='k'>let</span> max a b <span class='k'>=</span>
  <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> a <span class='k'>else</span> b

<span class='k'>let</span> () <span class='k'>=</span> print_int (max 2 3)
<a href="javascript:octry('let max a b =\n  if a &#62; b then a else b\n\nlet () = print_int (max 2 3)\n');">[try]</a></code></pre>
<p>
Is OCaml going to be smart enough to inline the <code>max</code> function and
specialise it to work on integers? Disappointingly the answer is no.
OCaml still has to generate the external <code>Max.max</code> symbol (because this
is a module, and so that function might be called from outside the
module), and it doesn&#39;t inline the function.</p>
<p>Here&#39;s another variation:</p>
<pre><code class='ocaml'><span class='k'>let</span> max a b <span class='k'>=</span>
  <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> a <span class='k'>else</span> b <span class='k'>in</span>
print_int (max 2 3)
<a href="javascript:octry('let max a b =\n  if a &#62; b then a else b in\nprint_int (max 2 3)\n');">[try]</a></code></pre>
<p>
Disappointingly although the definition of <code>max</code> in this code is local
(it can&#39;t be called from outside the module), OCaml still doesn&#39;t
specialise the function.</p>
<p>Lesson: if you have a function which is unintentionally polymorphic then
you can help the compiler by specifying types for one or more of the
arguments.</p>
<h3 id="Therepresentationofintegerstagbitsheapallocatedvalues"> The representation of integers, tag bits, heap-allocated values</h3><p>
There are a number of peculiarities about integers in OCaml. One of
these is that integers are 31 bit entities, not 32 bit entities. What
happens to the &quot;missing&quot; bit?</p>
<p>Write this to <code>int.ml</code>:</p>
<pre><code class='ocaml'>print_int 3<span class='o'>;;</span>
<a href="javascript:octry('print_int 3;;\n');">[try]</a></code></pre>
<p>
and compile with <code>ocamlopt -S int.ml -o int</code> to generate assembly
language in <code>int.s</code>. Recall from the discussion above that we are
expecting OCaml to inline the <code>print_int</code> function as
<code>output_string (string_of_int 3)</code>, and examining the assembly language
output we can see that this is exactly what OCaml does:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>text
        <span class='o'>.</span>globl  Int__entry
Int__entry<span class='o'>:</span>

        <span class='o'>;</span> Call <span class='m'>Pervasives</span><span class='o'>.</span>string_of_int (3)

        movl    <span class='o'>$</span>7<span class='o'>,</span> <span class='o'>%</span>eax
        call    Pervasives__string_of_int_152

        <span class='o'>;</span> Call <span class='m'>Pervasives</span><span class='o'>.</span>output_string (stdout<span class='o'>,</span> result_of_previous)

        movl    <span class='o'>%</span>eax<span class='o'>,</span> <span class='o'>%</span>ebx
        movl    Pervasives <span class='o'>+</span> 92<span class='o'>,</span> <span class='o'>%</span>eax
        call    Pervasives__output_string_212
<a href="javascript:octry('        .text\n        .globl  Int__entry\nInt__entry:\n\n        ; Call Pervasives.string_of_int (3)\n\n        movl    $7, %eax\n        call    Pervasives__string_of_int_152\n\n        ; Call Pervasives.output_string (stdout, result_of_previous)\n\n        movl    %eax, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n');">[try]</a></code></pre>
<p>
The important code is shown in red. It shows two things: Firstly the
integer is unboxed (not allocated on the heap), but is instead passed
directly to the function in the register <code>%eax</code>. This is fast. But
secondly we see that the number being passed is 7, not 3.</p>
<p>This is a consequence of the representation of integers in OCaml. The
bottom bit of the integer is used as a tag - we&#39;ll see what for next.
The top 31 bits are the actual integer. The binary representation of 7
is 111, so the bottom tag bit is 1 and the top 31 bits form the number
11 in binary = 3. To get from the OCaml representation to the integer,
divide by two and round down.</p>
<p>Why the tag bit at all? This bit is used to distinguish between integers
and pointers to structures on the heap, and the distinction is only
necessary if we are calling a polymorphic function. In the case above,
where we are calling <code>string_of_int</code>, the argument can only ever be an
<code>int</code> and so the tag bit would never be consulted. Nevertheless, to
avoid having two internal representations for integers, all integers in
OCaml carry around the tag bit.</p>
<p>A bit of background about pointers is required to understand why the tag
bit is really necessary, and why it is where it is.</p>
<p>In the world of RISC chips like the Sparc, MIPS and Alpha, pointers have
to be word-aligned. So on the older 32 bit Sparc, for example, it&#39;s not
possible to create and use a pointer which isn&#39;t aligned to a multiple
of 4 (bytes). Trying to use one generates a processor exception, which
means basically your program segfaults. The reason for this is just to
simplify memory access. It&#39;s just a lot simpler to design the memory
subsystem of a CPU if you only need to worry about word-aligned access.</p>
<p>For historical reasons (because the x86 is derived from an 8 bit chip),
the x86 has supported unaligned memory access, although if you align all
memory accesses to multiples of 4, then things go faster.</p>
<p>Nevertheless, all pointers in OCaml are aligned - ie. multiples of 4 for
32 bit processors, and multiples of 8 for 64 bit processors. This means
that the bottom bit of any pointer in OCaml will always be zero.</p>
<p>So you can see that by looking at the bottom bit of a register, you can
immediately tell if it stores a pointer (&quot;tag&quot; bit is zero), or an
integer (tag bit set to one).</p>
<p>Remember our polymorphic \&gt; function which caused us so much trouble in
the previous section? We looked at the assembler and found out that
OCaml compiles a call to a C function called <code>greaterthan</code> whenever it
sees the polymorphic form of \&gt;. This function takes two arguments, in
registers <code>%eax</code> and <code>%ebx</code>. But <code>greaterthan</code> can be called with
integers, floats, strings, opaque objects ... How does it know what
<code>%eax</code> and <code>%ebx</code> point to?</p>
<p>It uses the following decision tree:</p>
<ul>
 <li><strong>Tag bit is one:</strong> compare the two integers and return.
 </li>
 <li><strong>Tag bit is zero:</strong> <code>%eax</code> and <code>%ebx</code> must point at two
 heap-allocated memory blocks. Look at the header word of the memory
 blocks, specifically the bottom 8 bits of the header word, which tag
 the content of the block.
 </li>
 <li>  <ul>
   <li><strong>String_tag:</strong> Compare two strings.
   </li>
  </ul>
 </li>
 <li>  <ul>
   <li><strong>Double_tag:</strong> Compare two floats.
   </li>
  </ul>
 </li>
 <li>etc.</li>
</ul>

<p>Note that because \&gt; has type <code>&#39;a -&gt; &#39;a -&gt; bool</code>, both arguments must
have the same type. The compiler should enforce this at compile time. I
would assume that <code>greaterthan</code> probably contains code to sanity-check
this at run time however.</p>
<h3 id="Floats"> Floats</h3><p>
Floats are, by default, boxed (allocated on the heap). Save this as
<code>float.ml</code> and compile it with <code>ocamlopt -S float.ml -o float</code>:</p>
<pre><code class='ocaml'>print_float 3.0
<a href="javascript:octry('print_float 3.0\n');">[try]</a></code></pre>
<p>
The number is not passed directly to <code>string_of_float</code> in the <code>%eax</code>
register as happened above with ints. Instead, it is created statically
in the data segment:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>data
        <span class='o'>.</span>long   2301
        <span class='o'>.</span>globl  Float__1
Float__1<span class='o'>:</span>
        <span class='o'>.</span>double 3.0
<a href="javascript:octry('        .data\n        .long   2301\n        .globl  Float__1\nFloat__1:\n        .double 3.0\n');">[try]</a></code></pre>
<p>
and a pointer to the float is passed in <code>%eax</code> instead:</p>
<pre><code class='ocaml'>        movl    <span class='o'>$</span>Float__1<span class='o'>,</span> <span class='o'>%</span>eax
        call    Pervasives__string_of_float_157
<a href="javascript:octry('        movl    $Float__1, %eax\n        call    Pervasives__string_of_float_157\n');">[try]</a></code></pre>
<p>
Note the structure of the floating point number: it has a header (2301),
followed by the 8 byte (2 word) representation of the number itself. The
header can be decoded by writing it as binary:</p>
<pre><code class='ocaml'>Length <span class='k'>of</span> the object <span class='k'>in</span> words<span class='o'>:</span>  0000 0000 0000 0000 0000 10 (8 bytes)
Color<span class='o'>:</span>                          00
Tag<span class='o'>:</span>                            1111 1101 (Double_tag)
<a href="javascript:octry('Length of the object in words:  0000 0000 0000 0000 0000 10 (8 bytes)\nColor:                          00\nTag:                            1111 1101 (Double_tag)\n');">[try]</a></code></pre>
<p>
<code>string_of_float</code> isn&#39;t polymorphic, but suppose we have a polymorphic
function <code>foo : &#39;a -&gt; unit</code> taking one polymorphic argument. If we call
<code>foo</code> with <code>%eax</code> containing 7, then this is equivalent to <code>foo 3</code>,
whereas if we call <code>foo</code> with <code>%eax</code> containing a pointer to <code>Float__1</code>
above, then this is equivalent to <code>foo 3.0</code>.</p>
<h3 id="Arrays"> Arrays</h3><p>
I mentioned earlier that one of OCaml&#39;s targets was numerical computing.
Numerical computing does a lot of work on vectors and matrices, which
are essentially arrays of floats. As a special hack to make this go
faster, OCaml implements \&lt;dfn\&gt;arrays of unboxed floats\&lt;/dfn\&gt;. This
means that in the special case where we have an object of type
<code>float array</code> (array of floats), OCaml stores them the same way as in C:</p>
<pre><code class='ocaml'>double array<span class='o'>[</span>10<span class='o'>]</span><span class='o'>;</span>
<a href="javascript:octry('double array[10];\n');">[try]</a></code></pre>
<p>
... instead of having an array of pointers to ten separately allocated
floats on the heap.</p>
<p>Let&#39;s see this in practice:</p>
<pre><code class='ocaml'><span class='k'>let</span> a <span class='k'>=</span> <span class='m'>Array</span><span class='o'>.</span>create 10 0.0<span class='o'>;;</span>
<span class='k'>for</span> i <span class='k'>=</span> 0 <span class='k'>to</span> 9 <span class='k'>do</span>
  a<span class='o'>.</span>(i) <span class='o'>&#60;-</span> float_of_int i
<span class='k'>done</span>
<a href="javascript:octry('let a = Array.create 10 0.0;;\nfor i = 0 to 9 do\n  a.(i) &#60;- float_of_int i\ndone\n');">[try]</a></code></pre>
<p>
I&#39;m going to compile this code with the <code>-unsafe</code> option to remove
bounds checking (simplifying the code for our exposition here). The
first line, which creates the array, is compiled to a simple C call:</p>
<pre><code class='ocaml'>        pushl   <span class='o'>$</span>Arrayfloats__1     <span class='o'>;</span> Boxed float 0.0
        pushl   <span class='o'>$</span>21                 <span class='o'>;</span> The integer 10
        movl    <span class='o'>$</span>make_vect<span class='o'>,</span> <span class='o'>%</span>eax    <span class='o'>;</span> Address <span class='k'>of</span> the C <span class='k'>function</span> <span class='k'>to</span> call
        call    caml_c_call
    <span class='o'>;</span> <span class='o'>...</span>
        movl    <span class='o'>%</span>eax<span class='o'>,</span> Arrayfloats   <span class='o'>;</span> Store the resulting pointer <span class='k'>to</span> the
                                    <span class='o'>;</span> array at this place on the heap<span class='o'>.</span>
<a href="javascript:octry('        pushl   $Arrayfloats__1     ; Boxed float 0.0\n        pushl   $21                 ; The integer 10\n        movl    $make_vect, %eax    ; Address of the C function to call\n        call    caml_c_call\n    ; ...\n        movl    %eax, Arrayfloats   ; Store the resulting pointer to the\n                                    ; array at this place on the heap.\n');">[try]</a></code></pre>
<p>
The loop is compiled to this relatively simple assembly language:</p>
<pre><code class='ocaml'>        movl    <span class='o'>$</span>1<span class='o'>,</span> <span class='o'>%</span>eax            <span class='o'>;</span> Let <span class='o'>%</span>eax <span class='k'>=</span> 0. <span class='o'>%</span>eax is going <span class='k'>to</span> store i<span class='o'>.</span>
        cmpl    <span class='o'>$</span>19<span class='o'>,</span> <span class='o'>%</span>eax           <span class='o'>;</span> If <span class='o'>%</span>eax <span class='o'>&#62;</span> 9<span class='o'>,</span> <span class='k'>then</span> jump out <span class='k'>of</span> the
        jg      <span class='o'>.</span>L100               <span class='o'>;</span>   loop (<span class='k'>to</span> label <span class='o'>.</span>L100 at the <span class='k'>end</span>)<span class='o'>.</span>

<span class='o'>.</span>L101<span class='o'>:</span>                              <span class='o'>;</span> This is the start <span class='k'>of</span> the loop body<span class='o'>.</span>
        movl    Arrayfloats<span class='o'>,</span> <span class='o'>%</span>ecx   <span class='o'>;</span> Address <span class='k'>of</span> the array <span class='k'>to</span> <span class='o'>%</span>ecx<span class='o'>.</span>

        movl    <span class='o'>%</span>eax<span class='o'>,</span> <span class='o'>%</span>ebx          <span class='o'>;</span> Copy i <span class='k'>to</span> <span class='o'>%</span>ebx<span class='o'>.</span>
        sarl    <span class='o'>$</span>1<span class='o'>,</span> <span class='o'>%</span>ebx            <span class='o'>;</span> Remove the tag bit from <span class='o'>%</span>ebx by
                                    <span class='o'>;</span>   shifting it right 1 place<span class='o'>.</span> So <span class='o'>%</span>ebx
                                    <span class='o'>;</span>   now contains the real integer i<span class='o'>.</span>

        pushl   <span class='o'>%</span>ebx                <span class='o'>;</span> Convert <span class='o'>%</span>ebx <span class='k'>to</span> a float<span class='o'>.</span>
        fildl   <span class='o'>(%</span>esp)
        addl    <span class='o'>$</span>4<span class='o'>,</span> <span class='o'>%</span>esp

        fstpl   -4<span class='o'>(%</span>ecx<span class='o'>,</span> <span class='o'>%</span>eax<span class='o'>,</span> 4)   <span class='o'>;</span> Store the float <span class='k'>in</span> the array at the ith
                                <span class='o'>;</span> position<span class='o'>.</span>

        addl    <span class='o'>$</span>2<span class='o'>,</span> <span class='o'>%</span>eax            <span class='o'>;</span> i <span class='o'>:=</span> i <span class='o'>+</span> 1
        cmpl    <span class='o'>$</span>19<span class='o'>,</span> <span class='o'>%</span>eax           <span class='o'>;</span> If i <span class='o'>&#60;=</span> 9<span class='o'>,</span> loop around again<span class='o'>.</span>
        jle     <span class='o'>.</span><span class='m'>L101</span>
<span class='o'>.</span>L100<span class='o'>:</span>
<a href="javascript:octry('        movl    $1, %eax            ; Let %eax = 0. %eax is going to store i.\n        cmpl    $19, %eax           ; If %eax &#62; 9, then jump out of the\n        jg      .L100               ;   loop (to label .L100 at the end).\n\n.L101:                              ; This is the start of the loop body.\n        movl    Arrayfloats, %ecx   ; Address of the array to %ecx.\n\n        movl    %eax, %ebx          ; Copy i to %ebx.\n        sarl    $1, %ebx            ; Remove the tag bit from %ebx by\n                                    ;   shifting it right 1 place. So %ebx\n                                    ;   now contains the real integer i.\n\n        pushl   %ebx                ; Convert %ebx to a float.\n        fildl   (%esp)\n        addl    $4, %esp\n\n        fstpl   -4(%ecx, %eax, 4)   ; Store the float in the array at the ith\n                                ; position.\n\n        addl    $2, %eax            ; i := i + 1\n        cmpl    $19, %eax           ; If i &#60;= 9, loop around again.\n        jle     .L101\n.L100:\n');">[try]</a></code></pre>
<p>
The important statement is the one which stores the float into the
array. It is:</p>
<pre><code class='ocaml'>        fstpl   -4<span class='o'>(%</span>ecx<span class='o'>,</span> <span class='o'>%</span>eax<span class='o'>,</span> 4)
<a href="javascript:octry('        fstpl   -4(%ecx, %eax, 4)\n');">[try]</a></code></pre>
<p>
The assembler syntax is rather complex, but the bracketed expression
<code>-4(%ecx, %eax, 4)</code> means &quot;at the address <code>%ecx + 4*%eax - 4</code>&quot;. Recall
that <code>%eax</code> is the OCaml representation of i, complete with tag bit, so
it is essentially equal to <code>i*2+1</code>, so let&#39;s substitute that and
multiply it out:</p>
<pre><code class='ocaml'>  <span class='o'>%</span>ecx <span class='o'>+</span> 4<span class='o'>*%</span>eax <span class='o'>-</span> 4
<span class='k'>=</span> <span class='o'>%</span>ecx <span class='o'>+</span> 4<span class='o'>*</span>(i<span class='o'>*</span>2<span class='o'>+</span>1) <span class='o'>-</span> 4
<span class='k'>=</span> <span class='o'>%</span>ecx <span class='o'>+</span> 4<span class='o'>*</span>i<span class='o'>*</span>2 <span class='o'>+</span> 4 <span class='o'>-</span> 4
<span class='k'>=</span> <span class='o'>%</span>ecx <span class='o'>+</span> 8<span class='o'>*</span>i
<a href="javascript:octry('  %ecx + 4*%eax - 4\n= %ecx + 4*(i*2+1) - 4\n= %ecx + 4*i*2 + 4 - 4\n= %ecx + 8*i\n');">[try]</a></code></pre>
<p>
(Each float in the array is 8 bytes long.)</p>
<p>So arrays of floats are unboxed, as expected.</p>
<h3 id="Partiallyappliedfunctionsandclosures"> Partially applied functions and closures</h3><p>
How does OCaml compile functions which are only partially applied? Let&#39;s
compile this code:</p>
<pre><code class='ocaml'><span class='m'>Array</span><span class='o'>.</span>map (<span class='o'>(+</span>) 2) <span class='o'>[</span><span class='o'>|</span> 1<span class='o'>;</span> 2<span class='o'>;</span> 3<span class='o'>;</span> 4<span class='o'>;</span> 5 <span class='o'>|</span><span class='o'>]</span>
<a href="javascript:octry('Array.map ((+) 2) [| 1; 2; 3; 4; 5 |]\n');">[try]</a></code></pre>
<p>
If you recall the syntax, <code>[| ... |]</code> declares an array (in this case an
<code>int array</code>), and <code>((+) 2)</code> is a closure - &quot;the function which adds 2 to
things&quot;.</p>
<p>Compiling this code reveals some interesting new features. Firstly the
code which allocates the array:</p>
<pre><code class='ocaml'>        
        movl    <span class='o'>$</span>24<span class='o'>,</span> <span class='o'>%</span>eax           <span class='o'>;</span> Allocate 5 <span class='o'>*</span> 4 <span class='o'>+</span> 4 <span class='k'>=</span> 24 bytes <span class='k'>of</span> memory<span class='o'>.</span>
        call    caml_alloc

        leal    4<span class='o'>(%</span>eax)<span class='o'>,</span> <span class='o'>%</span>eax       <span class='o'>;</span> Let <span class='o'>%</span>eax point <span class='k'>to</span> 4 bytes into the
                                    <span class='o'>;</span>   allocated memory<span class='o'>.</span>
<a href="javascript:octry('        \n        movl    $24, %eax           ; Allocate 5 * 4 + 4 = 24 bytes of memory.\n        call    caml_alloc\n\n        leal    4(%eax), %eax       ; Let %eax point to 4 bytes into the\n                                    ;   allocated memory.\n');">[try]</a></code></pre>
<p>
All heap allocations have the same format: 4 byte header + data. In this
case the data is 5 integers, so we allocate 4 bytes for the header plus
5 * 4 bytes for the data. We update the pointer to point at the first
data word, ie. 4 bytes into the allocated memory block.</p>
<p>Next OCaml generates code to initialize the array:</p>
<pre><code class='ocaml'>        movl    <span class='o'>$</span>5120<span class='o'>,</span> -4<span class='o'>(%</span>eax)
        movl    <span class='o'>$</span>3<span class='o'>,</span> <span class='o'>(%</span>eax)
        movl    <span class='o'>$</span>5<span class='o'>,</span> 4<span class='o'>(%</span>eax)
        movl    <span class='o'>$</span>7<span class='o'>,</span> 8<span class='o'>(%</span>eax)
        movl    <span class='o'>$</span>9<span class='o'>,</span> 12<span class='o'>(%</span>eax)
        movl    <span class='o'>$</span>11<span class='o'>,</span> 16<span class='o'>(%</span>eax)
<a href="javascript:octry('        movl    $5120, -4(%eax)\n        movl    $3, (%eax)\n        movl    $5, 4(%eax)\n        movl    $7, 8(%eax)\n        movl    $9, 12(%eax)\n        movl    $11, 16(%eax)\n');">[try]</a></code></pre>
<p>
The header word is 5120, which if you write it in binary means a block
containing 5 words, with tag zero. The tag of zero means it&#39;s a
&quot;structured block&quot; a.k.a. an array. We also copy the numbers 1, 2, 3, 4
and 5 to the appropriate places in the array. Notice the OCaml
representation of integers is used. Because this is a structured block,
the garbage collector will scan each word in this block, and the GC
needs to be able to distriguish between integers and pointers to other
heap-allocated blocks (the GC does not have access to type information
about this array).</p>
<p>Next the closure <code>((+) 2)</code> is created. The closure is represented by
this block allocated in the data segment:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>data
        <span class='o'>.</span>long   3319
        <span class='o'>.</span>globl  Closure__1
Closure__1<span class='o'>:</span>
        <span class='o'>.</span>long   caml_curry2
        <span class='o'>.</span>long   5
        <span class='o'>.</span>long   Closure__fun_58
<a href="javascript:octry('        .data\n        .long   3319\n        .globl  Closure__1\nClosure__1:\n        .long   caml_curry2\n        .long   5\n        .long   Closure__fun_58\n');">[try]</a></code></pre>
<p>
The header is 3319, indicating a <code>Closure_tag</code> with length 3 words. The
3 words in the block are the address of the function <code>caml_curry2</code>, the
integer number 2 and the address of this function:</p>
<pre><code class='ocaml'>        <span class='o'>.</span>text
        <span class='o'>.</span>globl  Closure__fun_58
Closure__fun_58<span class='o'>:</span>

        <span class='o'>;</span> The <span class='k'>function</span> takes two arguments<span class='o'>,</span> <span class='o'>%</span>eax <span class='k'>and</span> <span class='o'>%</span>ebx<span class='o'>.</span>
        <span class='o'>;</span> This line causes the <span class='k'>function</span> <span class='k'>to</span> return <span class='o'>%</span>eax <span class='o'>+</span> <span class='o'>%</span>ebx <span class='o'>-</span> 1.

        lea     -1<span class='o'>(%</span>eax<span class='o'>,</span> <span class='o'>%</span>ebx)<span class='o'>,</span> <span class='o'>%</span>eax
        ret
<a href="javascript:octry('        .text\n        .globl  Closure__fun_58\nClosure__fun_58:\n\n        ; The function takes two arguments, %eax and %ebx.\n        ; This line causes the function to return %eax + %ebx - 1.\n\n        lea     -1(%eax, %ebx), %eax\n        ret\n');">[try]</a></code></pre>
<p>
What does this function do? On the face of it, it adds the two
arguments, and subtracts one. But remember that <code>%eax</code> and <code>%ebx</code> are in
the OCaml representation for integers. Let&#39;s represent them as:</p>
<ul>
 <li><code>%eax = 2 * a + 1</code>
 </li>
 <li><code>%ebx = 2 * b + 1</code></li>
</ul>

<p>where <code>a</code> and <code>b</code> are the actual integer arguments. So this function
returns:</p>
<pre><code class='ocaml'>  <span class='o'>%</span>eax <span class='o'>+</span> <span class='o'>%</span>ebx <span class='o'>-</span> 1
<span class='k'>=</span> 2 <span class='o'>*</span> a <span class='o'>+</span> 1 <span class='o'>+</span> 2 <span class='o'>*</span> b <span class='o'>+</span> 1 <span class='o'>-</span> 1
<span class='k'>=</span> 2 <span class='o'>*</span> a <span class='o'>+</span> 2 <span class='o'>*</span> b <span class='o'>+</span> 1
<span class='k'>=</span> 2 <span class='o'>*</span> (a <span class='o'>+</span> b) <span class='o'>+</span> 1
<a href="javascript:octry('  %eax + %ebx - 1\n= 2 * a + 1 + 2 * b + 1 - 1\n= 2 * a + 2 * b + 1\n= 2 * (a + b) + 1\n');">[try]</a></code></pre>
<p>
In other words, this function returns the OCaml integer representation
of the sum <code>a + b</code>. This function is <code>(+)</code>!</p>
<p>(It&#39;s actually more subtle than this - to perform the mathematics
quickly, OCaml uses the x86 addressing hardware in a way that probably
wasn&#39;t intended by the designers of the x86.)</p>
<p>So back to our closure - we won&#39;t go into the details of the
<code>caml_curry2</code> function, but just say that this closure is the argument
<code>2</code> applied to the function <code>(+)</code>, waiting for a second argument. Just
as expected.</p>
<p>The actual call to the <code>Array.map</code> function is quite difficult to
understand, but the main points for our examination of OCaml is that the
code:</p>
<ul>
 <li>Does call <code>Array.map</code> with an explicit closure.
 </li>
 <li>Does not attempt to inline the call and turn it into a loop.</li>
</ul>

<p>Calling <code>Array.map</code> in this way is undoubtedly slower than writing a
loop over the array by hand. The overhead is mainly in the fact that the
closure must be evaluated for each element of the array, and that isn&#39;t
as fast as inlining the closure as a function (if this optimization were
even possible). However, if you had a more substantial closure than just
<code>((+) 2)</code>, the overhead would be reduced. The FP version also saves
expensive <em>programmer</em> time versus writing the imperative loop.</p>
<h2 id="Profiling"> Profiling</h2><p>
There are two types of profiling that you can do on OCaml programs:</p>
<ol>
 <li>Get execution counts for bytecode.
 </li>
 <li>Get real profiling for native code.</li>
</ol>

<p>The <code>ocamlcp</code> and <code>ocamlprof</code> programs perform profiling on bytecode.
Here is an example:</p>
<pre><code class='ocaml'><span class='com2'>(* <span class='ic'>$</span> ocamlcp <span class='ic'>-</span>p a graphics<span class='ic'>.</span>cma graphtest<span class='ic'>.</span>ml <span class='ic'>-</span>o graphtest</span>
<span class='com2'>   <span class='ic'>$</span> <span class='ic'>./</span>graphtest</span>
<span class='com2'>   <span class='ic'>$</span> ocamlprof graphtest<span class='ic'>.</span>ml *)</span><!-- end comment -->

<span class='m'>Random</span><span class='o'>.</span>self_init ()<span class='o'>;;</span>
<span class='m'>Graphics</span><span class='o'>.</span>open_graph <span class='s'>&#34; 640x480&#34;</span><span class='o'>;;</span>

<span class='k'>let rec</span> iterate r x_init i <span class='k'>=</span>
  <span class='com2'>(* 12820000 *)</span><!-- end comment --> <span class='k'>if</span> i <span class='o'>==</span> 1 <span class='k'>then</span> <span class='com2'>(* 25640 *)</span><!-- end comment --> x_init
  <span class='k'>else</span>
    <span class='com2'>(* 12794360 *)</span><!-- end comment --> <span class='k'>let</span> x <span class='k'>=</span> iterate r x_init (i-1) <span class='k'>in</span>
    r <span class='o'>*.</span> x <span class='o'>*.</span> (1.0 <span class='o'>-.</span> x)<span class='o'>;;</span>

<span class='k'>for</span> x <span class='k'>=</span> 0 <span class='k'>to</span> 640 <span class='k'>do</span>
  <span class='com2'>(* 641 *)</span><!-- end comment --> <span class='k'>let</span> r <span class='k'>=</span> 4.0 <span class='o'>*.</span> (float_of_int x) <span class='o'>/.</span> 640.0 <span class='k'>in</span>
  <span class='k'>for</span> i <span class='k'>=</span> 0 <span class='k'>to</span> 39 <span class='k'>do</span>
    <span class='com2'>(* 25640 *)</span><!-- end comment --> <span class='k'>let</span> x_init <span class='k'>=</span> <span class='m'>Random</span><span class='o'>.</span>float 1.0 <span class='k'>in</span>
    <span class='k'>let</span> x_final <span class='k'>=</span> iterate r x_init 500 <span class='k'>in</span>
    <span class='k'>let</span> y <span class='k'>=</span> int_of_float (x_final <span class='o'>*.</span> 480.) <span class='k'>in</span>
    <span class='m'>Graphics</span><span class='o'>.</span>plot x y
  <span class='k'>done</span>
<span class='k'>done</span><span class='o'>;;</span>
<a href="javascript:octry('(* $ ocamlcp -p a graphics.cma graphtest.ml -o graphtest\n   $ ./graphtest\n   $ ocamlprof graphtest.ml *)\n\nRandom.self_init ();;\nGraphics.open_graph &#34; 640x480&#34;;;\n\nlet rec iterate r x_init i =\n  (* 12820000 *) if i == 1 then (* 25640 *) x_init\n  else\n    (* 12794360 *) let x = iterate r x_init (i-1) in\n    r *. x *. (1.0 -. x);;\n\nfor x = 0 to 640 do\n  (* 641 *) let r = 4.0 *. (float_of_int x) /. 640.0 in\n  for i = 0 to 39 do\n    (* 25640 *) let x_init = Random.float 1.0 in\n    let x_final = iterate r x_init 500 in\n    let y = int_of_float (x_final *. 480.) in\n    Graphics.plot x y\n  done\ndone;;\n');">[try]</a></code></pre>
<p>
The comments <code>(* nnn *)</code> are added by <code>ocamlprof</code>, showing how many
times each part of the code was called.</p>
<p>Profiling native code is done using your operating system&#39;s native
support for profiling. In the case of Linux, we use <code>gprof</code>.</p>
<p>To demonstrate native code profiling, I&#39;m going to calculate the first
3000 primes using the Sieve of Eratosthenes (<a href='http://www.bagley.org/~doug/ocaml/Notes/lazy.shtml' title='http://www.bagley.org/~doug/ocaml/Notes/lazy.shtml'>original
code</a>).
This program uses streams and camlp4, techniques which we haven&#39;t
covered in this tutorial.</p>
<pre><code class='ocaml'><span class='k'>let rec</span> filter p <span class='k'>=</span> parser
  <span class='o'>[</span><span class='o'>&#60;</span> 'n<span class='o'>;</span> s <span class='o'>&#62;</span><span class='o'>]</span> <span class='k'>-></span> <span class='k'>if</span> p n <span class='k'>then</span> <span class='o'>[</span><span class='o'>&#60;</span> 'n<span class='o'>;</span> filter p s <span class='o'>&#62;</span><span class='o'>]</span> <span class='k'>else</span> <span class='o'>[</span><span class='o'>&#60;</span> filter p s <span class='o'>&#62;</span><span class='o'>]</span>

<span class='k'>let</span> naturals <span class='k'>=</span>
  <span class='k'>let rec</span> gen n <span class='k'>=</span> <span class='o'>[</span><span class='o'>&#60;</span> 'n<span class='o'>;</span> gen (succ n) <span class='o'>&#62;</span><span class='o'>]</span> <span class='k'>in</span> gen 2

<span class='k'>let</span> primes <span class='k'>=</span>
  <span class='k'>let rec</span> sieve <span class='k'>=</span> parser
    <span class='o'>[</span><span class='o'>&#60;</span> 'n<span class='o'>;</span> s <span class='o'>&#62;</span><span class='o'>]</span> <span class='k'>-></span> <span class='o'>[</span><span class='o'>&#60;</span> 'n<span class='o'>;</span> sieve (filter (<span class='k'>fun</span> m <span class='k'>-></span> m <span class='k'>mod</span> n <span class='o'>&#60;&#62;</span> 0) s) <span class='o'>&#62;</span><span class='o'>]</span> <span class='k'>in</span>
  sieve naturals

<span class='k'>let</span> () <span class='k'>=</span>
  <span class='k'>for</span> i <span class='k'>=</span> 1 <span class='k'>to</span> 3000 <span class='k'>do</span>
    ignore (<span class='m'>Stream</span><span class='o'>.</span>next primes)
  <span class='k'>done</span>
<a href="javascript:octry('let rec filter p = parser\n  [&#60; &#39;n; s &#62;] -&#62; if p n then [&#60; &#39;n; filter p s &#62;] else [&#60; filter p s &#62;]\n\nlet naturals =\n  let rec gen n = [&#60; &#39;n; gen (succ n) &#62;] in gen 2\n\nlet primes =\n  let rec sieve = parser\n    [&#60; &#39;n; s &#62;] -&#62; [&#60; &#39;n; sieve (filter (fun m -&#62; m mod n &#60;&#62; 0) s) &#62;] in\n  sieve naturals\n\nlet () =\n  for i = 1 to 3000 do\n    ignore (Stream.next primes)\n  done\n');">[try]</a></code></pre>
<p>
We compile it using the <code>-p</code> option to <code>ocamlopt</code> which tells the
compiler to include profiling information for <code>gprof</code>:</p>
<pre><code class='ocaml'><span class='o'>$</span> ocamlopt <span class='o'>-</span>p <span class='o'>-</span>pp <span class='s'>&#34;camlp4o pa_extend.cmo&#34;</span> <span class='o'>-</span>I <span class='o'>+</span>camlp4 sieve<span class='o'>.</span>ml <span class='o'>-</span>o sieve
<a href="javascript:octry('$ ocamlopt -p -pp &#34;camlp4o pa_extend.cmo&#34; -I +camlp4 sieve.ml -o sieve\n');">[try]</a></code></pre>
<p>
After running the program as normal, the profiling code dumps out a file
<code>gmon.out</code> which we can interpret with <code>gprof</code>:</p>
<pre><code class='ocaml'><span class='o'>$</span> gprof <span class='o'>./</span>sieve
Flat profile<span class='o'>:</span>

Each sample counts <span class='k'>as</span> 0.01 seconds<span class='o'>.</span>
  <span class='o'>%</span>   cumulative   self              self     total
 time   seconds   seconds    calls   s<span class='o'>/</span>call   s<span class='o'>/</span>call  name
 10.86      0.57     0.57     2109     0.00     0.00  sweep_slice
  9.71      1.08     0.51     1113     0.00     0.00  mark_slice
  7.24      1.46     0.38  4569034     0.00     0.00  Sieve__code_begin
  6.86      1.82     0.36  9171515     0.00     0.00  Stream__set_data_140
  6.57      2.17     0.34 12741964     0.00     0.00  fl_merge_block
  6.29      2.50     0.33  4575034     0.00     0.00  Stream__peek_154
  5.81      2.80     0.30 12561656     0.00     0.00  alloc_shr
  5.71      3.10     0.30     3222     0.00     0.00  oldify_mopup
  4.57      3.34     0.24 12561656     0.00     0.00  allocate_block
  4.57      3.58     0.24  9171515     0.00     0.00  modify
  4.38      3.81     0.23  8387342     0.00     0.00  oldify_one
  3.81      4.01     0.20 12561658     0.00     0.00  fl_allocate
  3.81      4.21     0.20  4569034     0.00     0.00  Sieve__filter_56
  3.62      4.40     0.19     6444     0.00     0.00  empty_minor_heap
  3.24      4.57     0.17     3222     0.00     0.00  oldify_local_roots
  2.29      4.69     0.12  4599482     0.00     0.00  Stream__slazy_221
  2.10      4.80     0.11  4597215     0.00     0.00  darken
  1.90      4.90     0.10  4596481     0.00     0.00  Stream__fun_345
  1.52      4.98     0.08  4575034     0.00     0.00  Stream__icons_207
  1.52      5.06     0.08  4575034     0.00     0.00  Stream__junk_165
  1.14      5.12     0.06     1112     0.00     0.00  do_local_roots

<span class='o'>[</span> etc<span class='o'>.</span> <span class='o'>]</span>
<a href="javascript:octry('$ gprof ./sieve\nFlat profile:\n\nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls   s/call   s/call  name\n 10.86      0.57     0.57     2109     0.00     0.00  sweep_slice\n  9.71      1.08     0.51     1113     0.00     0.00  mark_slice\n  7.24      1.46     0.38  4569034     0.00     0.00  Sieve__code_begin\n  6.86      1.82     0.36  9171515     0.00     0.00  Stream__set_data_140\n  6.57      2.17     0.34 12741964     0.00     0.00  fl_merge_block\n  6.29      2.50     0.33  4575034     0.00     0.00  Stream__peek_154\n  5.81      2.80     0.30 12561656     0.00     0.00  alloc_shr\n  5.71      3.10     0.30     3222     0.00     0.00  oldify_mopup\n  4.57      3.34     0.24 12561656     0.00     0.00  allocate_block\n  4.57      3.58     0.24  9171515     0.00     0.00  modify\n  4.38      3.81     0.23  8387342     0.00     0.00  oldify_one\n  3.81      4.01     0.20 12561658     0.00     0.00  fl_allocate\n  3.81      4.21     0.20  4569034     0.00     0.00  Sieve__filter_56\n  3.62      4.40     0.19     6444     0.00     0.00  empty_minor_heap\n  3.24      4.57     0.17     3222     0.00     0.00  oldify_local_roots\n  2.29      4.69     0.12  4599482     0.00     0.00  Stream__slazy_221\n  2.10      4.80     0.11  4597215     0.00     0.00  darken\n  1.90      4.90     0.10  4596481     0.00     0.00  Stream__fun_345\n  1.52      4.98     0.08  4575034     0.00     0.00  Stream__icons_207\n  1.52      5.06     0.08  4575034     0.00     0.00  Stream__junk_165\n  1.14      5.12     0.06     1112     0.00     0.00  do_local_roots\n\n[ etc. ]\n');">[try]</a></code></pre>
<p>
In fact this program spends much of its time in the garbage collector
(not surprisingly, since although the solution is elegant, it is far
from optimal - a solution using arrays and loops would have been much
faster).</p>
<h2 id="Summary"> Summary</h2><p>
In summary here are some tips for getting the best performance out of
your programs:</p>
<ol>
 <li>Write your program as simply as possible. If it takes too long to
 run, profile it to find out where it&#39;s spending its time and
 concentrate optimizations on just those areas.
 </li>
 <li>Check for unintentional polymorphism, and add type hints for the
 compiler.
 </li>
 <li>Closures are slower than simple function calls, but add to
 maintainability and readability.
 </li>
 <li>As a last resort, rewrite hotspots in your program in C (but first
 check the assembly language produced by the OCaml compiler to see if
 you can do better than it).
 </li>
 <li>Performance might depend on external factors (speed of your database
 queries? speed of the network?). If so then no amount of
 optimization will help you.</li>
</ol>

<h3 id="Furtherreading"> Further reading</h3><p>
You can find out more about how OCaml represents different types by
reading chapter 18 of the manual (&quot;Interfacing C with OCaml&quot;) and also
looking at the <code>mlvalues.h</code> header file.</p>
<h2 id="DiscussionOnThisPage"> Discussion On This Page</h2><h3 id="Javadynamicdispatch"> Java dynamic dispatch</h3><p>

<strong>There are some serious mistakes in the last paragraph:</strong></p>
<ul>
 <li><p>Dynamic method dispatch itself is seldom a performance problem. In
 languages without multiple inheritance (e.g. Java) this is usually
 done via one step of pointer indirection. Objects in OCaml are also
 dynamically dispatched. Since this is the point with polymorphism in
 an OO setting.</p>
 </li>
 <li><p>Dynamic method dispatch often hinders a compiler to inline function
 and this hits the performance.</p>
 </li>
 <li><p>In Java is a dynamic type check (aka cast) much more expensive than
 a dynamic method dispatch.</p>
 </li>
</ul>


          </div>
        </div>
      </div>

    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-left">
            <li><a href="javascript:document.getElementById('footer').style.display='none'">[X]</a></li>
          </ul>
          <ul class="nav pull-right">
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/tree/master/md-pages/learn/tutorials/performance_and_profiling.md">Edit</a></li>
            <li><a href="#">Feedback</a></li>
            <li><a href="#">Contact us</a></li>
            <li><a href="#">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script>
      if(document.getElementById('buttons')) octry('')
</script>
  </body>
</html>
