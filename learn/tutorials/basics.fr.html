<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Notions de base &#8211; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" />
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet" />
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen" />
    <link href="/static/css/bootstrap_mod.css" rel="stylesheet" media="screen" />
    <link href="/static/css/opamdoc.css" rel="stylesheet" media="screen" />
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <script type="text/javascript">
      function octry(x){
        if(document.getElementById('buttons').innerHTML=='') {
          t = document.getElementById('tryocaml');
          js = document.createElement("script"); js.type = "text/javascript"; js.src = "/try-ocaml.js";
          t.appendChild(js);
        } else {
          t = document.getElementById('tryocaml');
          t.style.display = 'block';
          document.getElementById('console').value = x;
          document.getElementById('console').focus();
          document.getElementById('console').select();
        }
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml" /></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/pkg/">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form id="searchform" class="navbar-search pull-right" method="get" action="http://www.google.com/search">
              <input value="site:http://ocaml.org/" name="q" type="hidden" />
              <input placeholder="Search" class="search-query" name="q" type="text" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
    <div class="container">
  <div class="row">
    

    <div id="content-primary" class="span8">
      <div id='tryocaml' class="content" style='display:none;'>
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style='display:none;'></div>
            <div id="menu-lessons" style='display:none'>
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td id=""></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id='main-contents' class="content">
        <!--   -->
<h1 id="Notionsdebase"> Notions de base</h1><h2 id="Commentaires"> Commentaires</h2><p>

Les commentaires OCaml sont d√©limit√©s par <code>(*</code> et <code>*)</code>, comme ceci:</p>
<pre><code class='tryocaml'><span class='comment'>(* Ceci est une ligne de commentaire. *)</span>

<span class='comment'>(* Ceci est
 * un commentaire
 * multi-ligne.
 *)</span>
</code></pre>
<p>
Autrement dit, les commentaires ressemblent fortement aux commentaires
du C traditionnel (<code>/* ... */</code>).</p>
<p>Il n&#39;y a pas actuellement de syntaxe pour les commentaires de fin de
ligne comme <code># ...</code> en Perl ou <code>// ...</code> en C99/C++/Java. L&#39;emploi de
<code>## ...</code> a √©t√© √©voqu√© √† quelques occasions, et je recommande fortement √†
l&#39;√©quipe d&#39;OCaml d&#39;ajouter √ßa dans les versions √† venir.</p>
<p>OCaml prend en compte les commentaires imbriqu√©s, ce qui permet
facilement de mettre des portions de code en commentaire:</p>
<pre><code class='tryocaml'><span class='comment'>(* Ce code n&#39;est pas au point...

(* Test de primalit√©. *)
let is_prime n =
  (* pense-b√™te: demander √ßa aux mailing lists *) XXX;;

*)</span>
</code></pre>
<h2 id="Appelsdefonctions"> Appels de fonctions</h2><p>

Supposons que vous ayez √©crit une fonction nomm√©e <code>repeated</code>, qui prend
en argument une cha√Æne de caract√®res <code>s</code> et un nombre <code>n</code> et renvoie une
nouvelle cha√Æne de caract√®res qui contient l&#39;originale r√©p√©t√©e <code>n</code> fois.</p>
<p>Dans la plupart des languages d√©riv√©s du C, un appel de fonction
ressemble √† √ßa :</p>
<pre><code class='tryocaml'><span class='lower'>repeated</span> <span class='keywordsign'>(</span><span class='string'>&#34;hello&#34;</span><span class='keywordsign'>,</span> <span class='number'>3</span><span class='keywordsign'>)</span>  <span class='keywordsign infix'>/*</span> <span class='lower'>c&#39;est</span> <span class='lower'>du</span> <span class='lower'>code</span> <span class='constructor module'>C</span> <span class='keywordsign infix'>*/</span>
</code></pre>
<p>
Ca veut dire ¬´ appelle la fonction <code>repeated</code> avec deux arguments, le
premier √©tant la cha√Æne de caract√®res hello et le second √©tant le nombre
3 ¬ª.</p>
<p>OCaml, tout comme d&#39;autres langages fonctionnels, √©crit et parenth√®se
diff√©remment les appels de fonctions, ce qui entra√Æne bien des erreurs
au d√©but. Voici le m√™me appel de fonction en OCaml :</p>
<pre><code class='tryocaml'><span class='lower'>repeated</span> <span class='string'>&#34;hello&#34;</span> <span class='number'>3</span>  <span class='comment'>(* c&#39;est du code OCaml *)</span>
</code></pre>
<p>
Notez-bien : <strong>pas</strong> de parenth√®ses, et <strong>pas</strong> de virgule entre les
arguments.</p>
<p>Maintenant ce qui est source de confusion est que
<code>repeated (&quot;hello&quot;, 3)</code> <strong>a un sens</strong> particulier en OCaml. Cela
signifie ¬´ appelle la fonction <code>repeated</code> avec UN argument, cet argument
√©tant une structure repr√©sentant un couple d&#39;√©l√©ments ¬ª. Bien s√ªr ce
serait ici une erreur puisque la fonction <code>repeated</code> attend 2 arguments
et non un seul, et que quoi qu&#39;il en soit le premier argument doit √™tre
une cha√Æne de caract√®res et non un couple. Mais laissons de c√¥t√© les
couples (n-uplets) pour le moment. Retenez plut√¥t que c&#39;est une erreur
de mettre des parenth√®ses et des virgules autour des arguments de
fonctions.</p>
<p>Int√©ressons-nous maintenant √† une autre fonction -
<code>get_string_from_user</code> - qui prend en argument une cha√Æne de caract√®res
qui demande √† l&#39;utilisateur de taper quelque chose et renvoie la cha√Æne
de caract√®re ainsi entr√©e. Nous voulons passer cette cha√Æne de
caract√®res √† la fonction <code>repeated</code>. Voici les versions C et OCaml :</p>
<pre><code class='tryocaml'><span class='keywordsign infix'>/*</span> <span class='lower'>code</span> <span class='constructor module'>C</span><span class='keywordsign'>:</span> <span class='keywordsign infix'>*/</span>
<span class='lower'>repeated</span> <span class='keywordsign'>(</span><span class='lower'>get_string_from_user</span> <span class='keywordsign'>(</span><span class='string'>&#34;Veuillez entrer une cha√Æne de caract√®res.&#34;</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='number'>3</span><span class='keywordsign'>)</span>

<span class='comment'>(* code OCaml: *)</span>
<span class='lower'>repeated</span> <span class='keywordsign'>(</span><span class='lower'>get_string_from_user</span> <span class='string'>&#34;Veuillez entrer une cha√Æne de caract√®res.&#34;</span><span class='keywordsign'>)</span> <span class='number'>3</span>
</code></pre>
<p>
Soyez attentif au parenth√©sage et √† l&#39;absence de virgules. En g√©n√©ral la
r√®gle est la suivante : ¬´ mettez des parenth√®ses autour de tout l&#39;appel
de fonction - ne mettez pas de parenth√®ses autour des arguments pass√©s √†
une fonction ¬ª. Voici quelques exemples suppl√©mentaires :</p>
<pre><code class='tryocaml'><span class='lower'>f</span> <span class='number'>5</span> <span class='keywordsign'>(</span><span class='lower'>g</span> <span class='string'>&#34;hello&#34;</span><span class='keywordsign'>)</span> <span class='number'>3</span>    <span class='comment'>(* f a 3 arguments, g a un argument *)</span>
<span class='lower'>f</span> <span class='keywordsign'>(</span><span class='lower'>g</span> <span class='number'>3</span> <span class='number'>4</span><span class='keywordsign'>)</span>            <span class='comment'>(* f a un argument, g a 2 arguments *)</span>

<span class='keywordsign'>#</span> <span class='lower'>repeated</span> <span class='keywordsign'>(</span><span class='string'>&#34;hello&#34;</span><span class='keywordsign'>,</span> <span class='number'>3</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>     <span class='comment'>(* OCaml va rep√©rer l&#39;erreur *)</span>
<span class='constructor module'>This</span> <span class='lower'>expression</span> <span class='lower'>has</span> <span class='keyword'>type</span> <span class='lower'>string</span> <span class='keywordsign'>*</span> <span class='lower'>int</span> <span class='lower'>but</span> <span class='lower'>is</span> <span class='lower'>here</span> <span class='lower'>used</span> <span class='keyword'>with</span> <span class='keyword'>type</span> <span class='lower'>string</span>
</code></pre>
<h2 id="Dfinirunefonction"> D√©finir une fonction</h2><p>

Vous savez tous comment on d√©finit une fonction (ou une m√©thode
statique, pour ceux qui pensent en Java) dans d&#39;autres langages. Comment
fait-on √ßa en OCaml ?</p>
<p>La syntaxe d&#39;OCaml est agr√©ablement concise. Voici une fonction qui
prend deux nombres flottants et calcule leur moyenne :</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>average</span> <span class='lower'>a</span> <span class='lower'>b</span> <span class='keywordsign'>=</span>
  <span class='keywordsign'>(</span><span class='lower'>a</span> <span class='keywordsign infix'>+.</span> <span class='lower'>b</span><span class='keywordsign'>)</span> <span class='keywordsign infix'>/.</span> <span class='number'>2.0</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
Tapez ceci dans le ¬´ toplevel ¬ª OCaml (sous Unix, tapez <code>ocaml</code> depuis
le shell) et voici ce que vous verrez :</p>
<pre><code class='tryocaml'><span class='keywordsign'>#</span> <span class='keyword'>let</span> <span class='lower'>average</span> <span class='lower'>a</span> <span class='lower'>b</span> <span class='keywordsign'>=</span>
  <span class='keywordsign'>(</span><span class='lower'>a</span> <span class='keywordsign infix'>+.</span> <span class='lower'>b</span><span class='keywordsign'>)</span> <span class='keywordsign infix'>/.</span> <span class='number'>2.0</span><span class='keywordsign'>;;</span>
<span class='keyword'>val</span> <span class='lower'>average</span> <span class='keywordsign'>:</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span> <span class='keywordsign'>=</span> <span class='keywordsign'>&#60;</span><span class='keyword'>fun</span><span class='keywordsign'>&#62;</span>
</code></pre>
<p>
Si vous regardez la d√©finition de fonction d&#39;un peu plus pr√®s, et aussi
ce qu&#39;OCaml vous affiche, vous devez vous posez un certain nombre de
questions :</p>
<ul>
 <li>Que font ces points ins√©r√©s apr√®s + et / ?
 </li>
 <li>Qu&#39;est-ce <code>float -&gt; float -&gt; float</code> peut bien vouloir dire ?</li>
</ul>

<p>Je vais r√©pondre √† toutes ces questions dans les sections qui viennent,
mais commen√ßons plut√¥t par d√©finir la m√™me fonction en C (la version
Java serait tr√®s semblable √† la version C), et normalement √ßa devrait
soulever encore plus d&#39;interrogations. Voici notre version C de
<code>average</code>:</p>
<pre><code class='tryocaml'><span class='lower'>double</span>
<span class='lower'>average</span> <span class='keywordsign'>(</span><span class='lower'>double</span> <span class='lower'>a</span><span class='keywordsign'>,</span> <span class='lower'>double</span> <span class='lower'>b</span><span class='keywordsign'>)</span>
<span class='keywordsign'>{</span>
  <span class='lower'>return</span> <span class='keywordsign'>(</span><span class='lower'>a</span> <span class='keywordsign'>+</span> <span class='lower'>b</span><span class='keywordsign'>)</span> <span class='keywordsign infix'>/</span> <span class='number'>2</span><span class='keywordsign'>;</span>
<span class='keywordsign'>}</span>
</code></pre>
<p>
Maintenant revenez sur la d√©finition OCaml vue pr√©c√©demment. Vous
devriez vous demander :</p>
<ul>
 <li>Pourquoi n&#39;a-t-on pas besoin de d√©finir les types de <code>a</code> et <code>b</code> dans
 la version OCaml ? Comment OCaml fait-il pour conna√Ætre leurs types,
 et au fait le sait-il au moins, ou est-ce que OCaml est typ√©
 dynamiquement ?
 </li>
 <li>En C, le <code>2</code> est implicitement converti en un <code>double</code>, mais
 pourquoi OCaml ne fait-il pas la m√™me chose ?
 </li>
 <li>Comment √©crit-on un <code>return</code> en OCaml ?</li>
</ul>

<p>OK, voyons √ßa.</p>
<ul>
 <li>OCaml est un langage fortement typ√© (en d&#39;autres mots, il n&#39;y a rien
 de dynamique concernant les types, comme ce serait le cas en Perl).
 </li>
 <li>OCaml utilise un m√©canisme d&#39;<em>inf√©rence de types</em>, c&#39;est-√†-dire
 qu&#39;il devine les types tout seul. Si vous utilisez le toplevel OCaml
 comme pr√©c√©demment, alors OCaml vous donnera [ce qu&#39;il pense
 √™tre...] le type correct de votre fonction.
 </li>
 <li>OCaml ne fait pas de conversions de types implicites. Si vous voulez
 un flottant, vous devez √©crire <code>2.0</code> parce que <code>2</code> est un entier.
 </li>
 <li>Parce qu&#39;OCaml ne permet pas la surcharge (overloading)
 d&#39;op√©rateurs, il a deux op√©rateurs diff√©rents pour signifier ¬´
 ajoute deux entiers ¬ª (c&#39;est +) et ¬´ ajoute deux flottants ¬ª (c&#39;est
 +. - notez bien le point). Et c&#39;est la m√™me chose pour les autres
 op√©rateurs arithm√©tiques.
 </li>
 <li>OCaml renvoie la derni√®re expression de la fonction, donc pas besoin
 d&#39;√©crire <code>return</code> comme en C.</li>
</ul>

<p>Les d√©tails sur tout √ßa vont √™tre expliqu√©s dans les sections et
chapitres qui suivent.</p>
<h2 id="Typesdebase"> Types de base</h2><p>
En OCaml les types de base sont:</p>
<pre><code class='tryocaml'>Characters 1:31 - 1:32 :
Error: Lexical error: don't know what to do with character '√'
</code></pre>
<p>
Un des bits de chaque <code>int</code> est utilis√© en interne par OCaml pour la
gestion de la m√©moire (garbage collection ou r√©cup√©ration automatique de
m√©moire). C&#39;est pourquoi le type <code>int</code> a 31 bits au lieu de 32 (63 si
vous utilisez une plate-forme 64 bits). En pratique ce n&#39;est un probl√®me
que dans quelques cas tr√®s sp√©cifiques. Par exemple si vous comptez des
choses en utilisant une boucle, OCaml vous limite √† compter un milliard
d&#39;√©l√©ments au lieu de 2 milliards. Ce n&#39;est pas un probl√®me parce que si
vous comptez autant de choses dans n&#39;importe quel langage vous devriez
de toute fa√ßon utiliser des entiers √† pr√©cision infinie (modules <code>Nat</code>
et <code>Big_int</code> en OCaml). N√©anmoins si vous avez besoin de manipuler des
types avec exactement 32 bits (par exemple si vous √©crivez du code pour
faire de la cryptographie ou pour des protocoles r√©seau), OCaml fournit
un type <code>nativeint</code> qui correspond exactement au type d&#39;entiers
correspondant √† votre plate-forme.</p>
<p>OCaml n&#39;a pas de type de base pour les entiers sans signe (unsigned),
mais vous pouvez obtenir le m√™me effet en utilisant <code>nativeint</code>. OCaml
n&#39;a pas non plus de type flottant simple pr√©cision.</p>
<p>OCaml fournit un type <code>char</code> qui est utilis√© pour les caract√®res, comme
par exemple <code>&#39;x&#39;</code>. Malheureusement le type <code>char</code> ne permet pas de
repr√©senter les caract√®res Unicode puisqu&#39;il ne supporte que 256
caract√®res diff√©rents. C&#39;est un probl√®me important qui n&#39;est pas r√©solu
au niveau d&#39;OCaml directement, mais cependant il y a des
<a href='http://camomile.sourceforge.net/' title='http://camomile.sourceforge.net/'>biblioth√®ques</a>
qui fournissent des types et des fonctions pour manipuler les caract√®res
Unicode et leurs diff√©rents encodages.</p>
<p>Les strings ne sont pas des listes de caract√®res. Elles ont leur propre
repr√©sentation interne qui est particuli√®rement efficace.</p>
<p>Le type <code>unit</code> est en quelque sorte l&#39;√©quivalent de <code>void</code> en C, nous en
reparlerons plus tard.</p>
<h2 id="Conversionsdetypesimplicitesouexplicites"> Conversions de types implicites ou explicites</h2><p>
Dans les langages d√©riv√©s du C, les ints se retrouvent convertis en
flottants dans certaines circonstances. Par exemple si vous √©crivez
<code>1 + 2.5</code> le premier argument (qui est un entier) est converti en
flottant, et le r√©sultat est √©galement un flottant. C&#39;est comme si vous
aviez √©crit <code>((double) 1) + 2.5</code>, mais cela s&#39;est fait implicitement.</p>
<p>OCaml ne fait jamais ce genre de conversion implicites (implicit casts).
En OCaml, <code>1 + 2.5</code> est une erreur de type. L&#39;op√©rateur <code>+</code> en OCaml
requiert deux arguments entiers, et si on lui donne un int et un float,
il indique cette erreur :</p>
<pre><code class='tryocaml'><span class='keywordsign'>#</span> <span class='number'>1</span> <span class='keywordsign'>+</span> <span class='number'>2.5</span><span class='keywordsign'>;;</span>
      <span class='keywordsign infix'>^^^</span>
<span class='constructor module'>This</span> <span class='lower'>expression</span> <span class='lower'>has</span> <span class='keyword'>type</span> <span class='lower'>float</span> <span class='lower'>but</span> <span class='lower'>is</span> <span class='lower'>here</span> <span class='lower'>used</span> <span class='keyword'>with</span> <span class='keyword'>type</span> <span class='lower'>int</span>
</code></pre>
<p>
Cela signifie &quot;ceci est un float, mais ici j&#39;attendais un int&quot;.</p>
<p>Pour ajouter deux floats, il faut utiliser un op√©rateur diff√©rent, <code>+.</code>
(notez le point qui suit le plus).</p>
<p>OCaml ne convertit pas les ints en floats automatiquement, donc le code
suivant est √©galement incorrect :</p>
<pre><code class='tryocaml'><span class='keywordsign'>#</span> <span class='number'>1</span> <span class='keywordsign infix'>+.</span> <span class='number'>2.5</span><span class='keywordsign'>;;</span>
  <span class='keywordsign infix'>^</span>
<span class='constructor module'>This</span> <span class='lower'>expression</span> <span class='lower'>has</span> <span class='keyword'>type</span> <span class='lower'>int</span> <span class='lower'>but</span> <span class='lower'>is</span> <span class='lower'>here</span> <span class='lower'>used</span> <span class='keyword'>with</span> <span class='keyword'>type</span> <span class='lower'>float</span>
</code></pre>
<p>
Dans ce cas OCaml se plaint du premier argument.</p>
<p>Comment faire alors si on veut vraiment ajouter un int √† un float ?
(Supposons qu&#39;ils soient stock√©s dans des variables appel√©es <code>i</code> et
<code>f</code>). En OCaml la conversion doit √™tre explicite :</p>
<pre><code class='tryocaml'><span class='lower'>float_of_int</span> <span class='lower'>i</span> <span class='keywordsign infix'>+.</span> <span class='lower'>f</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
<code>float_of_int</code> est une fonction qui prend un <code>int</code> et renvoie un
<code>float</code>. Il y a toute une collection de fonctions de ce genre, comme par
exemple <code>int_of_float</code>, <code>char_of_int</code>, <code>int_of_char</code>, <code>string_of_int</code> et
ainsi de suite, et elle font essentiellement ce qu&#39;on attend d&#39;elles.</p>
<p>Puisque convertir un <code>int</code> en un <code>float</code> est une op√©ration
particuli√®rement courante, la fonction <code>float_of_int</code> a √©galement un
autre nom, plus court : l&#39;exemple ci-dessus aurait pu simplement √™tre
√©crit</p>
<pre><code class='tryocaml'><span class='lower'>float</span> <span class='lower'>i</span> <span class='keywordsign infix'>+.</span> <span class='lower'>f</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
(Remarquez bien que contrairement au C, en OCaml il est parfaitement
possible qu&#39;un type et qu&#39;une fonction portent le m√™me nom.)</p>
<h3 id="Qu39estcequiestmieuxconversionimpliciteouexplicite"> Qu&#39;est-ce qui est mieux, conversion implicite ou explicite ?</h3><p>
Vous √™tre peut-√™tre en train de vous dire que ces conversions explicites
sont lourdes, peut-√™tre m√™me qu&#39;elles font perdre du temps, et c&#39;est
justifi√©, mais il y a au moins deux arguments en leur faveur.
Premi√®rement, OCaml a besoin de cette conversion explicite pour
l&#39;inf√©rence de type (voir plus bas), et l&#39;inf√©rence de type permet de
gagner √©norm√©ment de temps de d√©veloppement, et taper un peu plus au
clavier est une perte insignifiante √† c√¥t√©. Deuxi√®mement, si vous avez
pass√© du temps √† d√©bugger des programmes C vous devez savoir que (a) les
conversions (¬´ casts ¬ª) implicites entra√Ænent des erreurs qui sont
difficiles √† d√©tecter, et (b) vous passez alors une bonne partie du
temps √† vous demander o√π les conversions ont lieu. Les rendre explicites
vous aide donc pour le d√©buggage. Troisi√®mement, certaines conversions
(notamment int \&lt;-\&gt; float) sont vraiment des op√©rations co√ªteuses. Cela
ne vous rapporte pas grand-chose de les cacher.</p>
<h2 id="Fonctionsordinairesetfonctionsrcursives"> Fonctions ordinaires et fonctions r√©cursives</h2><p>
Contrairement au langage C et ses d√©riv√©s, une fonction en OCaml n&#39;est
r√©cursive que si vous le pr√©cisez en utilisant <code>let rec</code> au lieu de
seulement <code>let</code>. Voici un exemple de fonction r√©cursive :</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>range</span> <span class='lower'>a</span> <span class='lower'>b</span> <span class='keywordsign'>=</span>
  <span class='keyword'>if</span> <span class='lower'>a</span> <span class='keywordsign'>&#62;</span> <span class='lower'>b</span> <span class='keyword'>then</span> <span class='keywordsign operator'>[]</span>
  <span class='keyword'>else</span> <span class='lower'>a</span> <span class='keywordsign'>::</span> <span class='lower'>range</span> <span class='keywordsign'>(</span><span class='lower'>a</span><span class='keywordsign'>+</span><span class='number'>1</span><span class='keywordsign'>)</span> <span class='lower'>b</span>
  <span class='keywordsign'>;;</span>
</code></pre>
<p>
Remarquez que <code>range</code> s&#39;appelle elle-m√™me.</p>
<p>La seule diff√©rence entre <code>let</code> et <code>let rec</code> est au niveau de la
visibilit√© du nom de la fonction. Si la fonction ci-dessus avait √©t√©
d√©finie avec <code>let</code> tout seul, alors l&#39;appel √† <code>range</code> aurait essay√© de
trouver une fonction nomm√©e <code>range</code> pr√©c√©demment d√©finie, et pas la
fonction en cours de d√©finition. Il n&#39;y a pas de diff√©rence de
performance entre les fonctions d√©finies avec <code>let</code> et celles d√©finies
avec <code>let rec</code>, donc si vous pr√©f√©rez vous pouvez toujours utiliser la
forme <code>let rec</code> et vous aurez ainsi la m√™me s√©mantique qu&#39;en C et
d√©riv√©s.</p>
<h2 id="Typesdesfonctions"> Types des fonctions</h2><p>
Du fait de l&#39;inf√©rence de type, vous n&#39;aurez presque jamais √† √©crire le
type de vos fonctions. Cependant OCaml affiche fr√©quemment ce qu&#39;il
pense √™tre le type de vos fonctions, donc il vous faut conna√Ætre la
syntax qu&#39;il utilise. Pour une fonction <code>f</code> qui prend comme arguments
<code>arg1</code>, <code>arg2</code>, ... <code>argn</code>, et retourne quelque chose de type <code>rettype</code>,
le compilateur affichera :</p>
<pre><code class='tryocaml'><span class='lower'>f</span> <span class='keywordsign'>:</span> <span class='lower'>arg1</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>arg2</span> <span class='keywordsign'>-&#62;</span> <span class='keywordsign operator'>...</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>argn</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>rettype</span>
</code></pre>
<p>
Cette syntaxe avec des fl√®ches peut vous para√Ætre √©trange pour
l&#39;instant, mais lorsque nous parlerons de l&#39;application partielle, vous
verrez pourquoi √ßa a √©t√© choisi comme √ßa. Pour le moment, voici
simplement quelques exemples.</p>
<p>Notre fonction <code>repeated</code> qui prend une cha√Æne de caract√®res et un
entier et renvoie une cha√Æne de caract√®res a le type suivant :</p>
<pre><code class='tryocaml'><span class='lower'>repeated</span> <span class='keywordsign'>:</span> <span class='lower'>string</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>int</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>string</span>
</code></pre>
<p>
Notre fonction <code>average</code> qui prend deux flottants et renvoie un flottant
a le type suivant :</p>
<pre><code class='tryocaml'><span class='lower'>average</span> <span class='keywordsign'>:</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span>
</code></pre>
<p>
La fonction de conversion OCaml standard <code>int_of_char</code> a le type suivant
:</p>
<pre><code class='tryocaml'><span class='lower'>int_of_char</span> <span class='keywordsign'>:</span> <span class='lower'>char</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>int</span>
</code></pre>
<p>
Si une fonction ne renvoie rien (<code>void</code> pour les programmeurs C et
Java), on √©crit qu&#39;elle renvoie le type <code>unit</code>. Voici par exemple
l&#39;√©quivalent OCaml de <code>fputc</code> :</p>
<pre><code class='tryocaml'><span class='lower'>output_char</span> <span class='keywordsign'>:</span> <span class='lower'>out_channel</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>char</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>unit</span>
</code></pre>
<h3 id="Fonctionspolymorphes"> Fonctions polymorphes</h3><p>

Voyons maintenant quelqu&#39;un d&#39;un peu plus √©trange. Que pensez-vous d&#39;une
fonction qui prend <em>n&#39;importe quoi</em> comme argument ? Voici une fonction
bizarre qui prend un argument, l&#39;ignore et renvoie toujours 3 :</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>give_me_a_three</span> <span class='lower'>x</span> <span class='keywordsign'>=</span> <span class='number'>3</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
Quel est le type de cette fonction ? En OCaml on utilise une notation
sp√©ciale pour dire ¬´ le type que vous voulez ¬ª. C&#39;est un caract√®res
apostrophe suivi d&#39;une lettre. Le type de la fonction ci-dessus s&#39;√©crit
donc normalement comme ceci :</p>
<pre><code class='tryocaml'><span class='lower'>give_me_a_three</span> <span class='keywordsign'>:</span> <span class='keywordsign'>&#39;</span><span class='lower'>a</span><span class='keywordsign'>-&#62;</span> <span class='lower'>int</span>
</code></pre>
<p>
o√π <code>&#39;a</code> est mis pour n&#39;importe quel type. Vous pouvez par exemple
utiliser cette fonction comme ceci: <code>give_me_a_three &quot;foo&quot;</code>, ou comme
cela: <code>give_me_a_three 2.0</code>, et les deux sont tout-√†-fait valides en
OCaml.</p>
<p>Pour le moment l&#39;utilit√© des fonctions polymorphes n&#39;est pas √©vidente,
mais elles sont vraiment tr√®s utiles et tr√®s communes, nous en parlerons
plus tard. (nous verrons que c&#39;est un peu comme les templates en C++ ou
les generics en Java 1.5).</p>
<h2 id="Infrencedetypes"> Inf√©rence de types</h2><p>
Donc le th√®me de ce tutoriel est que les langages fonctionnels ont un
tas de Fonctionnalit√©s Vraiment Cool, et OCaml est un langage qui a tous
ces Trucs Bien Sympas en m√™me temps, ce qui en fait un langage tr√®s
pratique pour les programmeurs. Mais le plus bizarre est sans doute que
la plupart de ces propri√©t√©s avantageuses n&#39;ont en fait rien √† voir avec
la ¬´ programmation fonctionnelle ¬ª. Quoi qu&#39;il en soit, voici donc le
premier de ces Trucs Bien Sympas: l&#39;inf√©rence de types.</p>
<p>En deux mots : vous n&#39;avez pas besoin de d√©clarer le type de vos
fonctions et variables puisqu&#39;OCaml fait √ßa pour vous.</p>
<p>En plus OCaml v√©rifie que tous vos types collent bien entre eux, m√™me
entre diff√©rents fichiers.</p>
<p>Et comme OCaml est aussi un langage pratique, il fournit √©galement
certains moyens pour contourner le syst√®me de types et ses
v√©rifications, pour les (tr√®s) rares cas o√π cela est n√©cessaire. Il n&#39;y
a probablement que les gourous qui auront √©ventuellement besoin de
pratiquer ce genre de sport.</p>
<p>Retournons maintenant √† la fonction <code>average</code> que nous avions tap√© ainsi
dans le toplevel :</p>
<pre><code class='tryocaml'><span class='keywordsign'>#</span> <span class='keyword'>let</span> <span class='lower'>average</span> <span class='lower'>a</span> <span class='lower'>b</span> <span class='keywordsign'>=</span>
  <span class='keywordsign'>(</span><span class='lower'>a</span> <span class='keywordsign infix'>+.</span> <span class='lower'>b</span><span class='keywordsign'>)</span> <span class='keywordsign infix'>/.</span> <span class='number'>2.0</span><span class='keywordsign'>;;</span>
<span class='keyword'>val</span> <span class='lower'>average</span> <span class='keywordsign'>:</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span> <span class='keywordsign'>=</span> <span class='keywordsign'>&#60;</span><span class='keyword'>fun</span><span class='keywordsign'>&#62;</span>
</code></pre>
<p>
Oh merveille ! OCaml a devin√© tout seul que la fonction prend deux
arguments de type <code>float</code> et renvoie un <code>float</code>.</p>
<p>Comment a-t-il fait ? Tout d&#39;abord il regarde o√π <code>a</code> et <code>b</code> sont
utilis√©s, en l&#39;occurrence dans l&#39;expression <code>(a +. b)</code>. Ensuite, √©tant
donn√© que <code>+.</code> est lui-m√™me une fonction qui prend deux arguments de
type <code>float</code>, il en d√©duit simplement que <code>a</code> et <code>b</code> doivent √™tre de
type <code>float</code>.</p>
<p>Apr√®s √ßa, la fonction <code>/.</code> renvoie un <code>float</code>, qui est √©galement la
valeur de retour de la fonction <code>average</code>. Donc <code>average</code> doit renvoyer
un <code>float</code>. En conclusion, le type de <code>average</code> correspond √† la
signature suivante :</p>
<pre><code class='tryocaml'><span class='lower'>average</span> <span class='keywordsign'>:</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>float</span>
</code></pre>
<p>
L&#39;inf√©rence de types est bien s√ªr assez simple pour un programme aussi
court, mais elle fonctionne aussi pour les programmes de grande taille.
C&#39;est une des qualit√©s majeures du langage parce que √ßa supprime toute
une classe d&#39;erreurs qui produisent des segfaults,
<code>NullPointerException</code>s et autres <code>ClassCastException</code>s dans d&#39;autres
langages (ou bien des warnings bien souvent ignor√©s comme en Perl).</p>

      </div>
    </div>
  </div>
</div>

    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-left">
            <li><a style='cursor:pointer;' onclick="document.getElementById('footer').style.display='none'">[X]</a></li>

            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/tree/master/md-pages/learn/tutorials/basics.fr.md">Edit this page</a></li>
          </ul>
          <ul class="nav pull-right">
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Feedback</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Contact us</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      // <!--
      if(document.getElementsByTagName('pre').length > 0)
         octry('')
      // -->
    </script>
  </body>
</html>
