<!DOCTYPE HTML>

<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title> &ndash; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet">
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet">
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen">
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml"></a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform.html">Platform</a></li>
              <li ><a href="/menu.html">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>
            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    <div class="container">
      <div class="row">

        <div class="span4">
          <nav id="nav-secondary">
            <ul class="nav nav-list">
              <li class="nav-header"><a href="#">Contents</a></li>

 <ul>
  <li><a href='#Tracingfunctionscallsinthetoplevel'>Tracing functions calls in the toplevel</a>
   <ul>
    <li><a href='#Polymorphicfunction'> Polymorphic function</a></li>
    <li><a href='#Limitations'> Limitations</a></li>
   </ul>
</li>
  <li><a href='#TheOCamldebugger'>The OCaml debugger</a>
   <ul>
    <li><a href='#Launchingthedebugger'> Launching the debugger</a></li>
    <li><a href='#Findingthecauseofaspuriousexception'> Finding the cause of a spurious exception</a></li>
    <li><a href='#Gettinghelpandinfointhedebugger'> Getting help and info in the debugger</a></li>
    <li><a href='#Settingbreakpoints'> Setting break points</a></li>
    <li><a href='#UsingthedebuggerunderXEmacs'> Using the debugger under (X)Emacs</a>
</li>
   </ul>
</li>
 </ul>

            </ul>
          </nav>
        </div>
        <div id="content-primary" class="span8">
          <div class="content">
            <p><em>Table of contents</em></p>
<h1 id="Debugging">Debugging</h1>
<p>This note quickly presents two techniques to debug OCaml programs:</p>

 <ul>
  <li><p><a href='#trace'>Tracing functions calls</a>that works in the toplevel,</p>
</li>
  <li><p><a href='#ocamldebug'>OCaml debugger</a>, which allows analysing programes
 compiled with <code>ocamlc</code>.</p>
</li>
 </ul>

<h2 id="Tracingfunctionscallsinthetoplevel">Tracing functions calls in the toplevel</h2>
<p>The simplest way to debug programs in the toplevel is to follow the
function calls, by “tracing” the faulty function:</p>
<pre><code>  let rec fib x = if x &lt;= 1 then 1 else fib (x - 1) + fib (x - 2);;
# #trace fib;;
fib is now traced.
# fib 3;;
fib &lt;-- 3
fib &lt;-- 1
fib --&gt; 1
fib &lt;-- 2
fib &lt;-- 0
fib --&gt; 1
fib &lt;-- 1
fib --&gt; 1
fib --&gt; 2
fib --&gt; 3
- : int = 3
# #untrace fib;;
fib is no longer traced.</code></pre>
<h3 id="Polymorphicfunction"> Polymorphic function</h3>
<p>A difficulty with polymorphic functions is that the output of the trace
system is not very informative in case of polymorphic arguments and/or
results. Consider a sorting algorithm (say bubble sort):</p>
<pre><code>  let exchange i j v =
    let aux = v.(i) in
    v.(i) &lt;- v.(j); v.(j) &lt;- aux;;
  
  let one_pass_vect fin v =
    for j = 1 to fin do
      if v.(j - 1) &gt; v.(j) then exchange (j - 1) j v
    done;;
  
  let bubble_sort_vect v =
    for i = Array.length v - 1 downto 0 do
    one_pass_vect i v
  done;;

  let q = [| 18; 3; 1 |];;

# #trace one_pass_vect;;
one_pass_vect is now traced.
# bubble_sort_vect q;;
one_pass_vect &lt;-- 2
one_pass_vect --&gt; &lt;fun&gt;
one_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]
one_pass_vect* --&gt; ()
one_pass_vect &lt;-- 1
one_pass_vect --&gt; &lt;fun&gt;
one_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]
one_pass_vect* --&gt; ()
one_pass_vect &lt;-- 0
one_pass_vect --&gt; &lt;fun&gt;
one_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]
one_pass_vect* --&gt; ()
- : unit = ()</code></pre>
<p>The function <code>one_pass_vect</code> being polymorphic, its vector argument is
printed as a vector containing polymorphic values,
<code>[|&lt;poly&gt;; &lt;poly&gt;;           &lt;poly&gt;|]</code>, and thus we cannot properly
follow the computation.</p>
<p>A simple way to overcome this problem is to define a monomorphic version
of the faulty function. This is fairly easy using a <em>type constraint</em>.
Generally speaking, this allows a proper understanding of the error in
the definition of the polymorphic function. Once this has been
corrected, you just have to suppress the type constraint to revert to a
polymorphic version of the function. For our sorting routine, a single
type constraint on the argument of the <code>exchange</code> function warranties a
monomorphic typing, that allows a proper trace of function calls:</p>
<pre><code># let exchange i j (v : int vect) =
    [...]
exchange : int -&gt; int -&gt; int vect -&gt; unit = &lt;fun&gt;
    [...]
one_pass_vect : int -&gt; int vect -&gt; unit = &lt;fun&gt;
    [...]
bubble_sort_vect : int vect -&gt; unit = &lt;fun&gt;
# #trace one_pass_vect;;
one_pass_vect is now traced.
# let q = [| 18; 3; 1 |];;
q : int vect = [|18; 3; 1|]
# bubble_sort_vect q;;
one_pass_vect &lt;-- 2
one_pass_vect --&gt; &lt;fun&gt;
one_pass_vect* &lt;-- [|18; 3; 1|]
one_pass_vect* --&gt; ()
one_pass_vect &lt;-- 1
one_pass_vect --&gt; &lt;fun&gt;
one_pass_vect* &lt;-- [|3; 1; 18|]
one_pass_vect* --&gt; ()
one_pass_vect &lt;-- 0
one_pass_vect --&gt; &lt;fun&gt;
one_pass_vect* &lt;-- [|1; 3; 18|]
one_pass_vect* --&gt; ()
- : unit = ()</code></pre>
<h3 id="Limitations"> Limitations</h3>
<p>To keep track of assignments to data structures and mutable variables in
a program, the trace facility is not powerful enough. You need an extra
mechanism to stop the program in any place and ask for internal values:
that is a symbolic debugger with its stepping feature.</p>
<p>Stepping a functional program has a meaning which is a bit weird to
define and understand. Let me say that we use the notion of *runtime
events* that happen for instance when a parameter is passed to a
function or when entering a pattern matching, or selecting a clause in a
pttern matching. Computation progress is taken into account by these
events, independantly of the instructions executed on the hardware.</p>
<p>Although this is difficult to implement, there exists such a debugger
for OCaml under Unix: <code>ocamldebug</code> (there also exists one for Caml
Light, as a user contribution). Its use is illustrated in the next
section.</p>
<p>In fact, for complex programs, it is likely the case that the programmer
will use explicit printing to find the bugs, since this methodology
allows the reduction of the trace material : only useful data are
printed and special purpose formats are more suited to get the relevant
information, than what can be output automatically by the generic
pretty-printer used by the trace mechanism.</p>
<h2 id="TheOCamldebugger">The OCaml debugger</h2>
<p>We now give a quick tutorial for the OCaml debugger (<code>ocamldebug</code>).
Before starting, please note that <code>ocamldebug</code> does not work under
native Windows ports of OCaml (but it runs under the Cygwin port.</p>
<h3 id="Launchingthedebugger"> Launching the debugger</h3>
<p>Consider the following obviously wrong program written in the file
<code>uncaught.ml</code>:</p>
<pre><code>(* file uncaught.ml *)
let l = ref [];;
let find_address name = List.assoc name !l;;
let add_address name address = l := (name, address) :: ! l;;
add_address &quot;IRIA&quot; &quot;Rocquencourt&quot;;;
print_string (find_address &quot;INRIA&quot;); print_newline ();;</code></pre>
<p>At runtime, the program raises an uncaught exception <code>Not_found</code>.
Suppose we want to find where and why this exception has been raised, we
can proceed as follows:</p>

 <ol>
  <li><p>we compile the program in debug mode:  
</p>
<pre><code>ocamlc -g uncaught.</code></pre>
</li>
  <li><p>we launch the debugger:
</p>
<pre><code>ocamldebug a.</code></pre>

<p>Then the debugger answers with a banner and a prompt:
</p>
<pre><code>    OCaml Debugger version 4.00.</code></pre>
<p>
(ocd</p>
</li>
 </ol>

<h3 id="Findingthecauseofaspuriousexception"> Finding the cause of a spurious exception</h3>
<p>Type <code>r</code> (for <em>run</em>); you get</p>
<pre><code>(ocd) r
Loading program... done.
Time : 12
Program end.
Uncaught exception: Not_found
(ocd)</code></pre>
<p>Self explanatory, is&apos;nt it? So, you want to step backward to set the
program counter before the time the exception is raised; hence type in
<code>b</code> as <em>backstep</em>, and you get</p>
<pre><code>(ocd) b
Time : 11 - pc : 15500 - module List
143     [] -&gt; &lt;|b|&gt;raise Not_found</code></pre>
<p>The debugger tells you that you are in module <code>List</code>, inside a pattern
matching on a list that already chose the <code>[]</code> case and is about to
execute <code>raise Not_found</code>, since the program is stopped just before this
expression (as witnessed by the <code>&lt;|b|&gt;</code> mark).</p>
<p>But, as you know, you want the debugger to tell you which procedure
calls the one from <code>List</code>, and also who calls the procedure that calls
the one from <code>List</code>; hence, you want a backtrace of the execution stack:</p>
<pre><code>(ocd) bt
#0  Pc : 15500  List char 3562
#1  Pc : 19128  Uncaught char 221</code></pre>
<p>So the last function called is from module <code>List</code> at character 3562,
that is :</p>
<pre><code>let rec assoc x = function
    [] -&gt; raise Not_found
          ^
  | (a,b)::l -&gt; if a = x then b else assoc x l</code></pre>
<p>The function that calls it is in module <code>Uncaught</code>, file <code>uncaught.ml</code>
char 221:</p>
<pre><code>print_string (find_address &quot;INRIA&quot;); print_newline ();;
                                  ^</code></pre>
<p>To sum up: if you&apos;re developping a program you can compile it with the
<code>-g</code> option, to be ready to debug the program if necessary. Hence, to
find a spurious exception you just need to type <code>ocamldebug a.out</code>, then
<code>r</code>, <code>b</code>, and <code>bt</code> gives you the backtrace.</p>
<h3 id="Gettinghelpandinfointhedebugger"> Getting help and info in the debugger</h3>
<p>To get more info about the current status of the debugger you can ask it
directly at the toplevel prompt of the debugger; for instance:</p>
<pre><code>(ocd) info breakpoints
No breakpoint.

(ocd) help break
  1      15396  in List, character 3539
break : Set breakpoint at specified line or function.
Syntax: break function-name
break @ [module] linenum
break @ [module] # characternum</code></pre>
<h3 id="Settingbreakpoints"> Setting break points</h3>
<p>Let&apos;s set up a breakpoint and rerun the entire program from the
beginning (<code>(g)oto 0</code> then <code>(r)un</code>):</p>
<pre><code>(ocd) break @Uncaught 9
Breakpoint 3 at 19112 : file Uncaught, line 9 column 34

(ocd) g 0
Time : 0
Beginning of program.

(ocd) r
Time : 6 - pc : 19112 - module Uncaught
Breakpoint : 1
9 add &quot;IRIA&quot; &quot;Rocquencourt&quot;&lt;|a|&gt;;;</code></pre>
<p>Then, we can step and find what happens when <code>find_address</code> is about to
be called</p>
<pre><code>(ocd) s
Time : 7 - pc : 19012 - module Uncaught
5 let find_address name = &lt;|b|&gt;List.assoc name !l;;

(ocd) p name
name : string = &quot;INRIA&quot;

(ocd) p !l
$1 : (string * string) list = [&quot;IRIA&quot;, &quot;Rocquencourt&quot;]
(ocd)</code></pre>
<p>Now we can guess why <code>List.assoc</code> will fail to find &quot;INRIA&quot; in the
list...</p>
<h3 id="UsingthedebuggerunderXEmacs"> Using the debugger under (X)Emacs</h3>
<p>Note also that under Emacs you call the debugger using <code>ESC-x</code>
<code>camldebug a.out</code>. Then Emacs will set you directly to the file and
character reported by the debugger, and you can step back and forth
using <code>ESC-b</code> and <code>ESC-s</code>, you can set up break points using
<code>CTRL-X       space</code>, and so on...
</p>

            <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
              <div class="navbar-inner">
                <div class="container-fluid">
                  <ul class="nav pull-right">
                    <li><a href="#">Feedback</a></li>
                    <li><a href="#">Contact us</a></li>
                    <li><a href="#">Find us on GitHub</a></li>
                  </ul>
                </div>
              </div>
            </footer>
            <!-- Load javascript from CDN -->
            <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
            <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
  </body>
</html>
