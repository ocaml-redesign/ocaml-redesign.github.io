<!DOCTYPE HTML>

<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title> &ndash; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet">
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet">
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen">
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml"></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/list.html">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
        <div class="container">
      <div class="row">

        <div class="span4">
          <nav id="nav-secondary">
            <ul class="nav nav-list">
              <li class="nav-header"><a href="#">Contents</a></li>
<ul>
 <li><a href='#Indentationofprograms'> Indentation of programs</a>
  <ul>
   <li><a href='#Howtocommentprograms'> How to comment programs</a>
   </li>
   <li><a href='#Howtochooseidentifiers'> How to choose identifiers</a>
   </li>
   <li><a href='#Whentouseparentheseswithinanexpression'> When to use parentheses within an expression</a>
   </li>
   <li><a href='#Patternmatching'> Pattern-matching</a>
   </li>
   <li><a href='#Compilerwarnings'> Compiler warnings</a>
   </li>
  </ul>
 </li>
 <li><a href='#Managingprogramdevelopment'> Managing program development</a>
  <ul>
   <li><a href='#Howtoeditprograms'> How to edit programs</a>
   </li>
  </ul>
 </li>
</ul>

            </ul>
          </nav>
        </div>
        <div id="content-primary" class="span8">
          <div class="content">
            
<h1 id="OCamlProgrammingGuidelines"> OCaml Programming Guidelines</h1><p>
This is a set of reasonable guidelines for formatting OCaml
programs—guidelines which reflect the consensus among veteran OCaml
programmers. Nevertheless, all detailed notifications of possible errors
or omissions will be noted with pleasure. To send your comments using
<a href='https://github.com/ocaml/ocaml.org/issues?state=open'>GitHub issues</a>.
<br />).arguments their from separated not are &#39;&#39;<code>.``` and &#39;&#39;</code>!</p>
<pre><code>symbols the :rule this to exceptions Obvious( .operators character-multi
with confusion avoid will you but readable, more be formulas your will
only not :spaces by separated well symbols operator keep to careful Be
symbols operator write to How  ####

.)space a by followed hence delimiter,
a is `;` since( `]3 ;2 ;1[` and )spaces by surrounded hence operator,
infix an is `::` since( `::` the around spaces with `l :: x` Write
lists write to How  ####
</code></pre>
<p>
.<code>&gt;-</code> and <code>|</code> by nicely off set are patterns &gt;<br/>

the while ,<code>with</code> and <code>match</code> by off set are matched being &gt;<br/>

expressions the Moreover, .tuple a construct to not parallel, &gt;<br/>

in values several match to is point The :<strong>Justification</strong> &gt;<br/></p>
<p>... &gt;- y x, |<br/>

... &gt;- 1 x, |<br/>

... &gt;- _ 1, |<br/>

with y x, match<br/></p>
<p>.simultaneously<br/>

values several matching when tuples-n around parentheses<br/>

omit to okay s&#39;It :<strong>simultaneously values several Matching</strong>   -
ocaml</p>
<pre><code>

.`=` and `let` between nicely off set is pattern &gt;
the Moreover, .tuple a construct to not simultaneously, &gt;
values several define to is point The :**Justification** &gt;
 &gt;

.`... = y x, let` write can you ,`...       = )y x,( let` 
of place In :**pair a of components the of Definition** *    
:**exceptions accepted Commonly** *

...`)z y, x,( = triplet   let` ,`)2 1,(` :space a by followed
each are )delimiters( therein commas the and parenthesized is tuple A
pairs write to How  ####

.readable be to them want you if programs your in same the Do .read
to easier texts written make to spaces by words separate to typography
in forward step great a been has It .symbols operator surround
should spaces and symbol, delimiter a follow always should space A
Delimiters  ####

 &gt;
!necessary as often as it press keyboard, &gt;
the on find to key easiest the is bar space the ;spaces with programs &gt;
your of words separate to hesitate never :**law spaces Pseudo** &gt;
 &gt;
conventions Lexical  ###
guidelines formatting Program ##

 &gt;
.readability jeopardize never and mind, in modifications &gt;
future keep always writing, its simplify So .times 100 read and times, &gt;
ten modified once, written is program A :**law programs Writing** &gt;
 &gt;

.)debugging
first the with starting( program the of readings and modifications
many uncountably the during future the in times hundred a return
will today, program simpler a get to &quot;wasting&quot; are you time the All

.readability optimize to hard work you
if time of lot a save you why reason the s&#39;That .them reading spent time
the to compared neglectable is programs the typing spend you time The
readable and simple Be  ###
programs write to guidelines General ##

.Lescanne Pierre Moth, Toby Starynkevitch, Basile
Maltey, Francois Petazzoni, Bruno Verlyck, Bruno Leroy, Xavier Doligez,
Damien Garrigue, Jacques Maranget, Luc Rauglaudre, de Daniel :page this
of critique the in participated already have who those all to Thanks

.)edu.berkeley.math@datta:mailto(]Datta
Ruchira[ :French from translation Original
</code></pre>
<p>
Example: write <code>x + 1</code> or <code>x + !y</code>.</p>
<blockquote>
<p><strong>Justification</strong>: If you left out the spaces then <code>x+1</code> would be
understood, but <code>x+!y</code> would change its meaning since</p>
<pre><code>+!`&#39;&#39; would
be interpreted as a multi-character operator.

**Criticism**: The absence of spaces around an operator improves the
readability of formulas when you use it to reflect the relative
precedences of operators. For example `x*y + 2*z` makes it very
obvious that multiplication takes precedence over addition.

**Response**: This is a bad idea, a chimera, because nothing in the
language ensures that the spaces properly reflect the meaning of the
formula. For example `x * z-1` means `(x * z) - 1`, and not
`x * (z - 1)` as the proposed interpretation of spaces would seem to
suggest. Besides, the problem of multi-character symbols would keep
you from using this convention in a uniform way: you couldn&#39;t leave
out the spaces around the multiplication to write `x*!y + 2*!z`.
Finally, this playing with the spaces is a subtle and flimsy
convention, a subliminal message which is difficult to grasp on
reading. If you want to make the precedences obvious, use the
expressive means brought to you by the language: write parentheses.

**Additional justification**: Systematically surrounding operators
with spaces simplify the treatment of infix operators which are no
more a complex particular case; in effect, whereas you can write `(+)`
without spaces, you evidently cannot write `(*)` since `(*` is read as
the beginning of a comment. You must write at least one space as in
“`( *)`”, although an extra space after `*` is definitively preferable
if you want to avoid that `*)` could be read, in some contexts, as the
end of a comment. All those difficulties are easily avoided if you
adopt the simple rule proposed here: keep operator symbols well
separated by spaces.&lt;br /&gt;
 In fact you will quickly feel that this rule is not so difficult to
follow: the space bar is the greatest and best situated key of the
keyboard, it is the easiest to enter and you cannot miss it!
</code></pre>
</blockquote>
<h4 id="Howtowritelongcharacterstrings"> How to write long character strings</h4><p>
Indent long character strings with the convention in force at that line
plus an indication of string continuation at the end of each line (a <code>\</code>
character at the end of the line that omits white spaces on the
beginning of next line):</p>
<pre><code class='ocaml'><script>mld533012d72e513c4b044391e9a981421 = 'let universal_declaration =\n  &#34;-1- Programs are born and remain free and equal under the law;\n\\n   distinctions can only be based on the common good.&#34; in\n  ...\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> universal_declaration <span class='k'>=</span>
  <span class='s'>&#34;-1- Programs are born and remain free and equal under the law;\n\
   distinctions can only be based on the common good.&#34;</span> <span class='k'>in</span>
  <span class='o'>...</span>
</code></pre>
<h2 id="Indentationofprograms"> Indentation of programs</h2>
<blockquote>
<p><strong>Landin&#39;s pseudo law</strong>: Treat the indentation of your programs as if
it determines the meaning of your programs.</p>
</blockquote>
<p>I would add to this law: carefully treat the indentation of programs
because in some cases it really gives the meaning of the program!</p>
<p>The indentation of programs is an art which excites many strong
opinions. Here several indentation styles are given which are drawn from
experience and which have not been severely criticized.</p>
<p>When a justification for the adopted style has seemed obvious to me, I
have indicated it. On the other hand, criticisms are also noted.</p>
<p>So each time, you have to choose between the different styles
suggested.<br />bench, the on back handiwork your put Always* &gt;
 &gt;
program to How  ###
guidelines Programming ##</p>
<pre><code>u :: t :: 1 + z ::
y :: x
in &#39;&#39;expression  
large``  
= u let
ocaml</code></pre>
<p>:example For .operators all to extend guidelines These</p>
<pre><code>u / )t * z + y + x(
in &#39;&#39;expression  
large``  
= u let
ocaml</code></pre>
<p>write</p>
<pre><code>)&#39;&#39;expression    
large``( /
)t * z + y + x(
ocaml</code></pre>
<p>expression unreadable the
of place In .operators of combination a of case the in operation one in
written be to large too expressions those bind must certainly most You</p>
<pre><code>t + z + y + x
in &#39;&#39;expression   
large``  
= t let
ocaml</code></pre>
<p>write</p>
<pre><code>&#39;&#39;expression  
large`` +
z + y + x
ocaml</code></pre>
<p>of place In .line the indent to having to preferable is construction
<code>in let</code> a of help the with &#39;&#39;expression large</p>
<pre><code> the define to
sequence, operation an such in &#39;&#39;expression large</code></pre>
<p> a of case the In</p>
<p> &gt;
.line this on continues operation the &gt;
that clear is it line, the starts operator the When :<strong>Justification</strong> &gt;
 &gt;</p>
<pre><code>u + t +
z + y + x
ocaml</code></pre>
<p>:example For .operation the of rest the indent t&#39;don and
operator, the with line the next the start operator, same the to calls
multiple of presence the in or arguments, complex takes operator an When
operations indent to How  ###</p>
<p> &gt;
.meaningful is function the &gt;
to given name the if particular in clearer, Much :<strong>Justification</strong> &gt;
 &gt;</p>
<pre><code>l f map.List
in blabla  
blabla  
blabla  
= x f let
ocaml</code></pre>
<p>write</p>
<pre><code>l  
)blabla    
blabla    
blabla    
&gt;- x function(  
map.List
ocaml</code></pre>
<p>of place In .well as binding <code>let</code> a by function the
define function, complex a is argument whose iterator an of case the In
:functions anonymous Naming  ####</p>
<pre><code>...
in u t z y x f  
= temp let
in &#39;&#39;expression  
large other``  
= u and
&#39;&#39;expression  
large``  
= t let
ocaml</code></pre>
<p>write</p>
<pre><code>...
in &#39;&#39;expression    
large other``    
&#39;&#39;expression    
large``    
z y x f  
= temp let
ocaml</code></pre>
<p>of place In
:arguments complex Naming  ####</p>
<p> &gt;
.evaluation of order the define explicitly &gt;
to necessary fact in is binding <code>let</code> the effects, side produces &gt;
arguments the of evaluation the If :<strong>justification Additional</strong> &gt;
 &gt;
.well as readable more is code the meaningful, is expressions &gt;
the to given name the if ;problem indentation No :<strong>Justification</strong> &gt;
 &gt;</p>
<p>.construction
<code>let</code> a by argument &#39;&#39;large</p>
<pre><code> the define cases these in :expressions
complex of consist which arguments avoid possible, as far As

.argument an of start the at lines change and line, same the on
arguments small Write .)convention chosen the to according spaces 2 or
1( function the of name the to respect with expressions the indent must
You .line same the on fit t&#39;can which --well as arguments complicated
very or-- arguments many with functions for except arises problem No
:name s&#39;function the to Indentation  ####
calls function indent to How  ###

 &gt;
.)!place first the in arrows the align to not better is it then &gt;
time, that at alignment up give often we ... so and change to lines &gt;
the all of indentations the lead can case supplementary a of addition &gt;
the( program the maintain to harder it makes This :**Justification** &gt;
 &gt;
```
3 &gt;-           _ |  
2 &gt;- _ name_Long |  
1 &gt;-          C1 |  
function = f let
ocaml```

:fragment following the in exemplify as practice,
bad considered is matching pattern a of arrows the of alignment Careful
.clauses matching-pattern in symbols `&gt;-` the of alignment *beastly* No  ####

 &gt;
...doubtful &gt;
is value aesthetic The .margin the into bump You :**Justification** &gt;
 &gt;
```
...  
... &gt;- ][ |  
function = x f rec let
ocaml```

:keyword `let` the under line the indent to choose but
```
...              
... &gt;- ][ |              
function = x f rec let
ocaml```

:write t&#39;Don .right the to pushed been previously has which `function`
or `match` keyword the under normally indenting in consists This
.analyses case and functions of indentation *beastly* No  ####
constructs matching-pattern of indentation Bad  ###
```
accu succ &gt;- v Var |
lam2 )lam1 accu lambda_size( lambda_size &gt;- )lam2 lam1,( App |
body )accu succ( lambda_size &gt;- )body x,( Abs |
function = accu lambda_size rec let

accu succ &gt;- v Var |  
lam2 )lam1 accu lambda_size( lambda_size &gt;- )lam2 lam1,( App |  
body )accu succ( lambda_size &gt;- )body x,( Abs |  
function = accu lambda_size rec let
ocaml```

.styles recommanded for above
See .)excepted evidently being functions anonymous for one the( matching
pattern for rules preceding the obey which styles reasonable several to
rise gives `rec let` or `let` by defined functions in matching-Pattern
functions named in matching Pattern  ####
```
list_lambda  
)1 &gt;- v Var |   
lam2 )lam1 0 lambda_size( lambda_size &gt;- )lam2 lam1,( App |   
body 0 lambda_size + 1 &gt;- )body x,( Abs |   
function(  
map
ocaml```

:keyword
`function` the to respect with indented are ,`function` by starting
functions, anonymous of matching pattern ,`try` or `match` to Similarly
functions anonymous in matching Pattern  ####

 &gt;
!programs OCaml &gt;
your in bugs more adding without money more get to rule this use case &gt;
this in :code of lines of number the to proportionally paid are you &gt;
unless rule, this for reason good any see t&#39;don I :**Justitification** &gt;
 &gt;
.readability to good &gt;
any add not does rule the ,)matchings complex in clauses simple or( &gt;
matchings pattern simple for ;enough compact not be May :**Criticism** &gt;
 &gt;
```
)2 - n ( fib + )1 - n( fib     
&gt;- n |  
1     
&gt;- 1 |  
1     
&gt;- 0 |  
function = fib rec let
ocaml```

.matching pattern any of clause any to
systematically rule this apply and further step one go programmers Other
```
1   
&gt;- v Var |
ocaml```

:this like clause last the indent then will They .overflows expressions
one as soon as clauses, all to rule this generalize programmers Some
```
&gt;- v Var |
lam2 lambda_size + lam1 lambda_size   
&gt;- )lam2 lam1,( App |
body lambda_size + 1   
&gt;- )body x,( Abs |
with lam match
ocaml```

.arrow the after line the cut large,
too is arrow matching pattern the of right the on expression the If
clauses inside expressions Indenting  ####

 &gt;
.construct the of part matching pattern the enters program the &gt;
that shows itself by line a on ,`with` keyword The :**Justification** &gt;
 &gt;
```
... &gt;- &quot;implemented yet not&quot; Failure |
... &gt;- found_Not |
with
... if  
in x f = y let  
try
ocaml```

:itself by line a on `with` put line, one beyond extends expression
preceding the If .line the of end the at `with` keyword the Put
```
... &gt;- &quot;implemented yet not&quot; Failure |
... &gt;- found_Not |
with x f try

1 &gt;- v Var |
lam2 lambda_size + lam1 lambda_size &gt;- )lam2 lam1,( App |
body lambda_size + 1 &gt;- )body x,( Abs |
with lam match
ocaml```

:construct
the of beginning the with clauses the align `try` a or `match` a For
`try` or `match`  ####

.aligned be not should clauses matching pattern of Arrows

.clause
the of pattern the of beginning the from starting normally, indent Then
.clause corresponding the of arrow the after immediately line the break
must you line, the on fit to large too is clause a in expression an If

.one first the *including* clause, each begins which
bar vertical the of level the at clauses matching-pattern the all Align

 &gt;
.)“doubtful” &gt;
of instead “awful” say would people some( dubious doubtful is value &gt;
aesthetic Last, .syntax different slightly a with exception an as &gt;
clause first the writing clauses, of set whole the for syntax same the &gt;
use to not insists also It .rule indentation correct the to exception &gt;
useless a thus is It .necessitate would line new normal a than &gt;
greater is that indentation an gets case first the : unnatural seems &gt;
indentation the bar first the omit you If :**criticism to Answer** &gt;
 &gt;
.it write to need no is &gt;
there hence, :mandatory not is bar vertical first The :**Criticism** &gt;
 &gt;

.one first the *including*
bar, vertical a by introduced are clauses matching-pattern the All
principles General  ####
constructs matching-pattern indent to How  ###

``` &gt; &gt;
e2 else ) &gt; &gt;
e1     &gt; &gt;
( then cond if &gt; &gt;
ocaml``` &gt; &gt;
 &gt; &gt;
small is `e2` but `) (` requires `e1` where mixture A &gt; &gt;
 &gt; &gt;
``` &gt; &gt;
) &gt; &gt;
e2   &gt; &gt;
( else ) &gt; &gt;
e1   &gt; &gt;
( then cond if &gt; &gt;
ocaml``` &gt; &gt;
 &gt; &gt;
delimiters `) (` are there If &gt; &gt;
 &gt; &gt;
``` &gt; &gt;
e2   &gt; &gt;
else &gt; &gt;
e1   &gt; &gt;
then cond if &gt; &gt;
ocaml``` &gt; &gt;
 &gt; &gt;
:large are expressions the all If &gt; &gt;
 &gt; &gt;
``` &gt; &gt;
e2 else &gt; &gt;
e1   &gt; &gt;
then cond if &gt; &gt;
ocaml``` &gt; &gt;
 &gt; &gt;
:small `e2` and large are `cond` and `e1` If &gt; &gt;
 &gt; &gt;
``` &gt; &gt;
e2   &gt; &gt;
else e1 then cond if &gt; &gt;
ocaml``` &gt; &gt;
 &gt; &gt;
:large `e2` but small, are `cond` and `e1` If &gt; &gt;
 &gt; &gt;
 &gt;
.`in ... = e let` &gt;
a with them binding simply from us keeps which effects, side have &gt;
do question in expressions the which in case the consider we now So &gt;
 &gt;
 &gt; &gt;
.comprehension to aid an as acts &gt; &gt;
naming the benefit, side a As .readable most the is which line one &gt; &gt;
on indentation simple the back get you way This :**Justification** &gt; &gt;
 &gt; &gt;
 &gt;
.line &gt;
a on fit to big too re&#39;they when `in ... = e let` with conditional &gt;
the within them binding advocate we ,)effects side without( &gt;
functional purely are conditional a up making expressions the If &gt;
``` &gt;
e2 else e1 then cond if &gt;
ocaml``` &gt;
 &gt;
:line one on them write simply small, are `e2` and `e1` ,`cond` If &gt;
 &gt;

.up them make which expressions
the of sizes the on depends conditionals of indentation the fact In

``` &gt;
end   &gt;
e2     &gt;
begin else end   &gt;
e1     &gt;
begin   &gt;
then cond if &gt;
ocaml``` &gt;
 &gt;
:line of beginning at `begin` first alternatively Or &gt;
``` &gt;
) &gt;
e2   &gt;
( else ) &gt;
e1   &gt;
( then cond if &gt;
ocaml``` &gt;
 &gt;
:line of end at `(` style &gt;
 &gt;

:used are
styles several conditional, a of branches the delimiting of case the In

.expressions these for delimiters `)` `(` or `end`
`begin` of presence the especially and question in expressions the of
size the to according branches, single for possible are styles Several
branches Single  ####

.systematically it use and style your choose again, Yet

 &gt;
?condition first the for case special a Why .conditions &gt;
the all of treatment the in consistency of Lack :**Criticism** &gt;
 &gt;
.performed is test another or continued &gt;
is condition the whether know to line of end the to look to have &gt;
not do you Morever, .mind to it bring to `if else` and indentation &gt;
use so languages, many in keyword a is `elsif` :**Justification** &gt;
 &gt;
```
... cond3 if else
... cond2 if else
... cond1 if
ocaml```

:`else` keyword the by line
each starting conditionals, multiple for method another suggest Some
```
... then cond3 if
else end  
e2    
begin then cond2 if
else end  
e1    
begin then cond if
ocaml```

:write ,)instance for statements include they when( enclosed
be to have conditions multiple of branches the in expressions If
```
e4
else e3 then cond3 if
else e2 then cond2 if
else e1 then cond1 if
ocaml```

:example
for write allow, expressions the and conditions the of sizes the If

 &gt;
.stop tab same the to aligned all &gt;
clauses, matching-pattern to treatment Analogous :**Justification** &gt;
 &gt;
```
... cond3 if
... cond2 if
... cond1 if
ocaml```

:indentation
of level same the at branches multiple with conditions Write
branches Multiple  ####
` ... else ...   then ... if` indent to How  ###

 &gt;
.consistency of Lack :**Criticism** &gt;
 &gt;
```
)expr_new expr,_new( expression_Mult
in
&#39;e2 &#39;e1 expression_Add  
in e2 expression_derive = &#39;e2 and  
e1 expression_derive = &#39;e1 let  
= expr_new let
in ... = e2 let
in ... = e1 let
ocaml```

:computation the of expression final the
apart set to line one on alone `in` keyword the write some :Variation

 &gt;
.assumptions the all for level indentation same the whence text, &gt;
mathematical a in assumptions of set a to analogous is constructs &gt;
in” ... “let of series a that suggested is It :**Justification** &gt;
 &gt;
```
...
in ... = n let
in ... = expr1 let
ocaml```

:level indentation same the at placed be should definitions these that
implies rule preceding the definitions, `let` of series a of case the In
```
expr1 + expr1
in ... = expr1 let
ocaml```

:line the of end the at written is it introduces
which `in` keyword the and ,`let` keyword the as level same the
to indented is `let` by introduced definition a following expression The
constructs `in ... let` indent to How  ###


 &gt;
.quickly too margin right the into run You :**Criticism** &gt;
 &gt;
.definition to definition from pass to easier s&#39;it so nicely, &gt;
off set is definition the of line first The :**Justification** &gt;
 &gt;
```
...    
&gt;- found_Not |    
with x g try    
in ... = tmp let    
= x f let
ocaml```

.function defined the of name the under just justified is body The *


 &gt;
.indentation normal the to exception unpleasant An :**Criticism** &gt;
 &gt;
.definition following &gt;
the to on pass to easy still s&#39;it so done, is definition the when &gt;
stop patterns the separating bars vertical The :**Justification** &gt;
 &gt;
```
...
&gt;- D |
&gt;- C |
function = x f let
ocaml```

.matching-pattern of case the in justified-left is body The *

:example for acceptable, are conventions Other

 &gt;
.indentation of amount the to exception No :**Justification** &gt;
 &gt;
```
1 + tmp  
in 0 &gt;- x |    
1 &gt;- C |    
with x match    
= tmp let  
= x g let

...  
&gt;- D |  
&gt;- C |  
function = x f let
ocaml```

:spaces 2 or 1 of indentation regular a With

.better definition the off set
to specially case this treat to okay s&#39;it However, .normally indented
generally is module a in globally defined function a of body The
definitions `;; ... let` global indent to How  ###

 &gt;
.unnatural and hard is which indent, to tabulations use always should &gt;
you since method this use to impossible almost seems It :**Answer** &gt;
 &gt;
.amount indentation the customize easily to &gt;
glad is reader the and correct remains indentation overall The .stops &gt;
tabs the changing by less or more indent to program the of readers &gt;
the allow to just is tabulations using of purpose The :**Criticism** &gt;
 &gt;
.program &gt;
the indent to spaces and tabulations both used programmer the if &gt;
wrong, completely becomes also can it ;completely changes program the &gt;
of indentation the another, and display one Between :**Justification** &gt;
 &gt;

.recommended
*not* absolutely is )9 character ASCII( character tab the Using
stops tab Using  ###

.program the throughout
it with stick and indent to amount an Pick .spaces 2 or 1 generally
is program the of lines successive between indentation in change The
indent to much How  ###

 &gt;
.correct keep to difficult is and readable &gt;
not is indentation The .code the in lost gets one screenful, a Beyond &gt;
.independently them handle and subproblems into it divide to time &gt;
s&#39;it screenful, one beyond goes function a When :**Justification** &gt;
 &gt;

.unreasonable is
this beyond go To .three most very the at two, cases exceptional in or
,)lines 70 about of( screenful one within fit always should function A
page the of Height  ###

 &gt;
.sheet standard a on font legible a in it print to and displays all &gt;
on code the read to possible it makes width This :**Justification** &gt;
 &gt;

.wide columns 80 is page The
page the of Width  ###

.application whole the throughout systematically
it use then indentation, of style accepted generally a Choose
indentation of Consistency  ###

.below first the is rule absolute only The 
</code></pre>
<blockquote><p>
 and then polish it and re-polish it.*</p>
</blockquote>
<h4 id="Writesimpleandclearprograms"> Write simple and clear programs</h4><p>
When this is done, reread, simplify and clarify. At every stage of
creation, use your head!</p>
<h4 id="Subdivideyourprogramsintolittlefunctions"> Subdivide your programs into little functions</h4><p>
Small functions are easier to master.</p>
<h4 id="Factoroutsnippetsofrepeatedcodebydefiningtheminseparatefunctions"> Factor out snippets of repeated code by defining them in separate functions</h4><p>
The sharing of code obtained in this way facilitates maintenance since
every correction or improvement automatically spreads throughout the
program. Besides, the simple act of isolating and naming a snippet of
code sometimes lets you identify an unsuspected feature.</p>
<h4 id="Nevercopypastecodewhenprogramming"> Never copy-paste code when programming</h4><p>
Pasting code almost surely indicates introducing a default of code
sharing and neglecting to identify and write a useful auxiliary
function; hence, it means that some code sharing is lost in the program.
Loosing code sharing implies that you will have more problems afterwards
for maintenance: a bug in the pasted code has to be corrected at each
occurrence of the bug in each copy of the code!</p>
<p>Moreover, it is difficult to identify that the same set of 10 lines of
code is repeated 20 times throughout the program. By contrast, if an
auxiliary function defines those 10 lines, it is fairly easy to see and
find where those lines are used: that&#39;s simply where the function is
called. If code is copy-pasted all over the place then the program is
more difficult to understand.</p>
<p>In conclusion, copy-pasting code leads to programs that are more
difficult to read and more difficult to maintain: it has to be banished.</p>
<h3 id="Howtocommentprograms"> How to comment programs</h3><h4 id="Don39thesitatetocommentwhenthere39sadifficulty"> Don&#39;t hesitate to comment when there&#39;s a difficulty</h4>
<h4 id="Ifthere39snodifficultythere39snopointincommenting"> If there&#39;s no difficulty, there&#39;s no point in commenting</h4><h4 id="Avoidcommentsinthebodiesoffunctions"> Avoid comments in the bodies of functions</h4>
<h4 id="Preferonecommentatthebeginningofthefunction"> Prefer one comment at the beginning of the function...</h4><p>
...which explains how the algorithm that is used works. Once more, if
there is no difficulty, there is no point in commenting.</p>
<h4 id="Avoidnocuouscomments"> Avoid nocuous comments</h4><p>
A <em>nocuous</em> comment is a comment that does not add any value, i.e. no
non-trivial information. The nocuous comment is evidently not of
interest; it is a nuisance since it uselessly distracts the reader. It
is often used to fulfill some strange criteria related to the so-called
<em>software metrology</em>, for instance the ratio <em>number of comments</em> /
<em>number of lines of code</em> that perfectly measures a ratio that I don&#39;t
know the theoretical or practical interpretation. Absolutely avoid
nocuous comments.</p>
<p>An example of what to avoid: the following comment uses technical words
and is thus masquerade into a real comment when it has no additional
information of interest;</p>
<pre><code class='ocaml'><script>ml7c79a3dc68031e871b4aa9ed7bc71e6f = '(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -&#62; printf &#34;%s&#34; s\n  | Abs l -&#62; printf &#34;\\ %a&#34; print_lambda l\n  | App (l1, l2) -&#62;\n     printf &#34;(%a %a)&#34; print_lambda l1 print_lambda l2\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='com2'>(*</span>
<span class='com2'>  Function print_lambda<span class='ic'>:</span></span>
<span class='com2'>  print a lambda<span class='ic'>-</span>expression given <span class='ic'>as</span> argument<span class='ic'>.</span></span>
<span class='com2'></span>
<span class='com2'>  Arguments<span class='ic'>:</span> lam<span class='ic'>,</span> any lambda<span class='ic'>-</span>expression<span class='ic'>.</span></span>
<span class='com2'>  Returns<span class='ic'>:</span> nothing<span class='ic'>.</span></span>
<span class='com2'></span>
<span class='com2'>  Remark<span class='ic'>:</span> print_lambda can only be used <span class='ic'>for</span> its side effect<span class='ic'>.</span></span>
<span class='com2'>*)</span><!-- end comment -->
<span class='k'>let rec</span> print_lambda lam <span class='k'>=</span>
  <span class='k'>match</span> lam <span class='k'>with</span>
  <span class='o'>|</span> Var s <span class='k'>-></span> printf <span class='s'>&#34;%s&#34;</span> s
  <span class='o'>|</span> Abs l <span class='k'>-></span> printf <span class='s'>&#34;\\ %a&#34;</span> print_lambda l
  <span class='o'>|</span> App (l1<span class='o'>,</span> l2) <span class='k'>-></span>
     printf <span class='s'>&#34;(%a %a)&#34;</span> print_lambda l1 print_lambda l2
</code></pre>
<h4 id="Usageinmoduleinterface"> Usage in module interface</h4><p>

The function&#39;s usage must appear in the interface of the module which
exports it, not in the program which implements it. Choose comments as
in the OCaml system&#39;s interface modules, which will subsequently allow
the documentation of the interface module to be extracted automatically
if need be.</p>
<h4 id="Useassertions"> Use assertions</h4><p>
Use assertions as much as possible: they let you avoid verbose comments,
while allowing a useful verification upon execution.</p>
<p>For example, the conditions for the arguments of a function to be valid
are usefully verified by assertions.</p>
<pre><code class='ocaml'><script>mlbe19a7d3d9716c25335c1bbf26d6b63e = 'let f x =\n  assert (x &#62;= 0);\n  ...\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> f x <span class='k'>=</span>
  <span class='k'>assert</span> (x <span class='o'>&#62;=</span> 0)<span class='o'>;</span>
  <span class='o'>...</span>
</code></pre>
<p>
Note as well that an assertion is often preferable to a comment because
it&#39;s more trustworthy: an assertion is forced to be pertinent because it
is verified upon each execution, while a comment can quickly become
obsolete and then becomes actually detrimental to the comprehension of
the program.</p>
<h4 id="Commentslinebylineinimperativecode"> Comments line by line in imperative code</h4><p>
When writing difficult code, and particularly in case of highly
imperative code with a lot of memory modifications (physical mutations
in data structures), it is sometime mandatory to comment inside the body
of functions to explain the implementation of the algorithm encoded
here, or to follow successive modifications of invariants that the
function must maintain. Once more, if there is some difficulty
commenting is mandatory, for each program line if necessary.</p>
<h3 id="Howtochooseidentifiers"> How to choose identifiers</h3><p>
It&#39;s hard to choose identifiers whose name evokes the meaning of the
corresponding portion of the program. This is why you must devote
particular care to this, emphasizing clarity and regularity of
nomenclature.</p>
<h4 id="Don39tuseabbreviationsforglobalnames"> Don&#39;t use abbreviations for global names</h4><p>
Global identifiers (including especially the names of functions) can be
long, because it&#39;s important to understand what purpose they serve far
from their definition.</p>
<h4 id="SeparatewordsbyunderscoresintofstringnotintOfString"> Separate words by underscores: (<code>int_of_string</code>, not <code>intOfString</code>)</h4><p>
Case modifications are meaningful in OCaml: in effect capitalized words
are reserved for constructors and module names in OCaml; in contrast
regular variables (functions or identifiers) must start by a lowercase
letter. Those rules prevent proper usage of case modification for words
separation in identifiers: the first word starts the identifier, hence
it must be lower case and it is forbidden to choose <code>IntOfString</code> as the
name of a function.</p>
<h4 id="Alwaysgivethesamenametofunctionargumentswhichhavethesamemeaning"> Always give the same name to function arguments which have the same meaning</h4><p>
If necessary, make this nomenclature explicit in a comment at the top of
the file); if there are several arguments with the same meaning then
attach numeral suffixes to them.</p>
<h4 id="Localidentifierscanbebriefandshouldbereusedfromonefunctiontoanother"> Local identifiers can be brief, and should be reused from one function to another</h4><p>
This augments regularity of style. Avoid using identifiers whose
appearance can lead to confusion such as <code>l</code> or <code>O</code>, easy to confuse
with <code>1</code> and <code>0</code>.</p>
<p>Example:</p>
<pre><code class='ocaml'><script>mld20f2f6ef0bb58de53fa4a5b39c5f1f6 = 'let add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> add_expression expr1 expr2 <span class='k'>=</span> <span class='o'>...</span>
<span class='k'>let</span> print_expression expr <span class='k'>=</span> <span class='o'>...</span>
</code></pre>
<p>
An exception to the recommendation not to use capitalization to separate
words within identifiers is tolerated in the case of interfacing with
existing libraries which use this naming convention: this lets OCaml
users of the library to orient themselves in the original library
documentation more easily.</p>
<h3 id="Whentouseparentheseswithinanexpression"> When to use parentheses within an expression</h3><p>
Parentheses are meaningful: they indicate the necessity of using an
unusual precedence. So they should be used wisely and not sprinkled
randomly throughout programs. To this end, you should know the usual
precedences, that is, the combinations of operations which do not
require parentheses. Quite fortunately this is not complicated if you
know a little mathematics or strive to follow the following rules:</p>
<h4 id="Arithmeticoperatorsthesamerulesasinmathematics"> Arithmetic operators: the same rules as in mathematics</h4><p>
For example: <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>.</p>
<h4 id="Functionapplicationthesamerulesasthoseinmathematicsforusageoftrigonometricfunctions"> Function application: the same rules as those in mathematics for usage of <em>trigonometric functions</em></h4><p>
In mathematics you write <code>sin x</code> to mean <code>sin (x)</code>. In the same way
<code>sin x + cos x</code> means <code>(sin x) + (cos x)</code> not <code>sin (x + (cos x))</code>. Use
the same conventions in OCaml: write <code>f x + g x</code> to mean
<code>(f x) + (g x)</code>.<br />.file the of top the at systematically it open ,<code>Format</code>
use you when So .etc ,<code>float_print</code> ,<code>int_print</code> ,<code>string_print</code>
functions printing usual the redefines module This .printing
indented automatically provides module <code>Format</code> the example, For
.functions of set important an of versions other brings and environment,
the modifies which module a open to normal it consider can You
closed them leaving than rather modules open use to When  ####</p>
<pre><code>... succ map.Array ...
... succ map.List ...
...
in 1 - v length.Array = lim let
...
in 1 - name length.String = lim let
ocaml</code></pre>
<p> &gt;
.errors semantic detect-to-difficult to rise gives &gt;
and ambiguous is identifiers unqualified of use The :<strong>Justification</strong> &gt;
 &gt;</p>
<p>.names module meaningful but short prefer will you Thus .notation
identifier qualified the instead using directives, <code>open</code> Avoid
modules Opening  ####</p>
<p>.etc exceptions, types, functions,
:module the by defined things the document must you interface, each For</p>
<p>.interface an write explicitly must you module, each For</p>
<p>.modules coherent into programs your subdivide must You
modules into Subdividing  ####
modules use to How  ###</p>
<pre><code>end
e4  
;e3  
begin else end
e2  
;e1  
begin then cond if
ocaml</code></pre>
<p>:delimited be must conditional a of
part <code>else</code> or <code>then</code> the in appears which sequence a way, same the In
<code>if</code> of branches inside Sequences  ####</p>
<pre><code>...
&gt;- 2 |
end  
... |  
with y match begin  
&gt;- 1 |
with x match
ocaml</code></pre>
<p>:example For .)construct matching-pattern enclosed
the with associated be automatically will construct matching-pattern
enclosing the of clauses subsequent otherwise( construct embedded
this delimit to necessary absolutely is it clause, matching-pattern
a in appears construct <code>with ... try</code> or <code>with ... match</code> a When
construct <code>match</code> a in construct <code>match</code>  ####</p>
<p>.constructs <code>else     then if</code>
within embedded sequences or constructs matching-pattern
concerns essentially constructs of delimiting explicit This</p>
<p>.way systematic, is, that
consistent, a in it do you if acceptable is parentheses using However
.parentheses than rather <code>end</code> and <code>begin</code> keywords the delimiters
as use programs, in constructs syntactic delimit to necessary is it When
programs in constructs delimit to How  ###</p>
<p>.<code>)x &amp;&amp; false( || true</code> means <code>x &amp;&amp; false || true</code>
,<code>)x * 2( + 1</code> means <code>x * 2 + 1</code> as just So, .multiplication to
&#39;&#39;and<code> the and addition to analogous is operator &#39;&#39;or</code> boolean the
case, this in parens overuse to tendency a have mathematicians Although
mathematics of those are operators boolean the of precedences relative The  ####</p>
<p>.<code>)3 &gt; x( &amp;&amp; ))2 + x( &lt; )x f((</code>
means <code>3 &gt; x &amp;&amp; 2 + x &lt; x f</code> way same the In .<code>)2 + x( &lt; )x f(</code>
means <code>2 + x &lt; x f</code> expression the )interpretation sensible
other no( reasons type For .<code>)x g( &lt; )x f(</code> means <code>x g &lt; x f</code> why
is This .apply rules preceding the so operators, infix are Comparisons
operators boolean and Comparisons  ####</p>
<p>.<code>)&#39;s ^ s( failwith</code> <em>not</em> ,<code>&#39;s ^ )s failwith(</code> means <code>&#39;s ^ s failwith</code>
and ,<code>)x g( @ )x f(</code> means <code>x g @ x f</code> ,<code>)x g( :: )x f(</code> means
<code>x g :: x f</code> :<strong>operators )infix( all to</strong> generalizes convention This
<br />
If you don&#39;t open <code>Format</code> you could miss the qualification of a
printing function, and this could be perfectly silent, since many
<code>Format</code>&#39;s functions have a correspondent in the default environment
(<code>Pervasives</code>). Mixing printing functions from <code>Format</code> and <code>Pervasives</code>
leads to subtle bugs in the display, that are difficult to trace. For
instance:</p>
<pre><code class='ocaml'><script>ml71f1bf03fdc659a459a3a02f697e3ee8 = 'let f () =\n  Format.print_string &#34;Hello World!&#34;; print_newline ()\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> f () <span class='k'>=</span>
  <span class='m'>Format</span><span class='o'>.</span>print_string <span class='s'>&#34;Hello World!&#34;</span><span class='o'>;</span> print_newline ()
</code></pre>
<p>
is bogus since it does not call <code>Format.print_newline</code> to flush the
pretty-printer queue and output <code>&quot;Hello World!&quot;</code>. Instead
<code>&quot;Hello World!&quot;</code> is stuck into the pretty-printer queue, while
<code>Pervasives.print_newline</code> outputs a carriage return on the standard
output ... If <code>Format</code> is printing on a file and standard output is the
terminal, the user will have a bad time finding that a carriage return
is missing in the file (and the display of material on the file is
strange, since boxes that should be closed by <code>Format.print_newline</code> are
still open), while a spurious carriage return appeared on the screen!</p>
<p>For the same reason, open large libraries such as the one with
arbitrary-precision integers so as not to burden the program which uses
them.</p>
<pre><code class='ocaml'><script>ml032a164e4ff984d8bd1af3dfac87c4d8 = 'open Num\n\nlet rec fib n =\n  if n &#60;= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>open</span> Num

<span class='k'>let rec</span> fib n <span class='k'>=</span>
  <span class='k'>if</span> n <span class='o'>&#60;=</span> 2 <span class='k'>then</span> Int 1 <span class='k'>else</span> fib (n <span class='o'>-</span> 1) <span class='o'>+/</span> fib (n <span class='o'>-</span> 2)
</code></pre>
<blockquote>
<p><strong>Justification</strong>: The program would be less readable if you had to
qualify all the identifiers.</p>
</blockquote>
<p>In a program where type definitions are shared, it is good to gather
these definitions into one or more module(s) without implementations
(containing only types). Then it&#39;s acceptable to systematically open the
module which exports the shared type definitions.</p>
<h3 id="Patternmatching"> Pattern-matching</h3><h4 id="Neverbeafraidofoverusingpatternmatching"> Never be afraid of over-using pattern-matching!</h4>
<h4 id="Ontheotherhandbecarefultoavoidnonexhaustivepatternmatchingconstructs"> On the other hand, be careful to avoid non-exhaustive pattern-matching constructs</h4><p>
Complete them with care, without using a “catch-all” clause such as
<code>| _ -&gt; ...</code> or <code>| x -&gt; ...</code> when it&#39;s possible to do without it (for
example when matching a concrete type defined within the program). See
also the next section: compiler warnings.</p>
<h3 id="Compilerwarnings"> Compiler warnings</h3><p>
Compiler warnings are meant to prevent potential errors; this is why you
absolutely must heed them and correct your programs if compiling them
produces such warnings. Besides, programs whose compilation produces
warnings have an odor of amateurism which certainly doesn&#39;t suit your
own work!</p>
<h4 id="Patternmatchingwarnings"> Pattern-matching warnings</h4><p>
Warnings about pattern-matching must be treated with the upmost care:</p>
<ul>
 <li>Those concerning useless clauses should of course be eliminated.</li>
</ul>

<ul>
 <li>For non-exhaustive pattern-matching you must complete the
 corresponding pattern-matching construct, without adding a default
 case <pre><code>catch-all&#39;&#39;, such as `| _ -&gt; ... `, but with an explicit
 list of the constructors not examined by the rest of the construct,
 for example `| Cn _ | Cn1 _ -&gt; ... `.</code></pre>
 </li>
</ul>

<blockquote>
<p><strong>Justification</strong>: It&#39;s not really any more complicated to write
it this way, and this allows the program to evolve more safely. In
effect the addition of a new constructor to the datatype being
matched will produce an alert anew, which will allow the
programmer to add a clause corresponding to the new constructor if
that is warranted. On the contrary, the</p>
<pre><code>catch-all&#39;&#39; clause
will make the function compile silently and it might be thought
that the function is correct as the new constructor will be
handled by the default case.
</code></pre>
</blockquote>
<ul>
 <li>Non-exhaustive pattern-matches induced by clauses with guards must
 also be corrected. A typical case consists in suppressing a
 redundant guard.</li>
</ul>

<h4 id="Destructuringletbindings"> De-structuring <code>let</code> bindings</h4><p>
[Translator&#39;s note: a</p>
<pre><code>de-structuring `let` binding&#39;&#39; is one which
binds several names to several expressions simultaneously. You pack all
the names you want bound into a collection such as a tuple or a list,
and you correspondingly pack all the expressions into a collective
expression. When the `let` binding is evaluated, it unpacks the
collections on both sides and binds each expression to its corresponding
name. For example, `let x, y = 1, 2` is a de-structuring `let` binding
which performs both the bindings `let x = 1` and `let y = 2`
simultaneously.]&lt;br /&gt;
The `let` binding is not limited to simple identifier definitions: you
can use it with more complex or simpler patterns. For instance

* `let` with complex patterns:&lt;br /&gt;
 `let [x; y] as l = ...`&lt;br /&gt;
 simultaneously defines a list `l` and its two elements `x` and `y`.
* `let` with simple pattern:&lt;br /&gt;
 `let _ = ...` does not define anything, it just evaluate the
 expression on the right hand side of the `=` symbol.

####  The de-structuring `let` must be exhaustive
Only use de-structuring `let` bindings in the case where the
pattern-matching is exhaustive (the pattern can never fail to match).
Typically, you will thus be limited to definitions of product types
(tuples or records) or definitions of variant type with a single case.
In any other case, you should use an explicit `match   ... with`
construct.

* `let ... in`: de-structuring `let` that give a warning must be
 replaced by an explicit pattern matching. For instance, instead of
 `let [x; y] as l = List.map succ     (l1 @ l2) in expression` write:

```ocaml
match List.map succ (l1 @ l2) with
| [x; y] as l -&gt; expression
| _ -&gt; assert false
```


* Global definition with de-structuring lets should be rewritten with
 explicit pattern matching and tuples:

```ocaml
let x, y, l =
  match List.map succ (l1 @ l2) with
  | [x; y] as l -&gt; x, y, l
  | _ -&gt; assert false
```


&gt; 
&gt; **Justification**: There is no way to make the pattern-matching
&gt; exhaustive if you use general de-structuring `let` bindings.
&gt; 

####  Sequence warnings and `let _ = ...`
When the compiler emits a warning about the type of an expression in a
sequence, you have to explicitly indicate that you want to ignore the
result of this expression. To this end:

* use a vacuous binding and suppress the sequence warning of

```ocaml
List.map f l;
print_newline ()
```
write

```ocaml
let _ = List.map f l in
print_newline ()
```


* you can also use the predefined function `ignore : &#39;a     -&gt; unit`
 that ignores its argument to return `unit`.

```ocaml
ignore (List.map f l);
print_newline ()
```


* In any case, the best way to suppress this warning is to understand
 why it is emitted by the compiler: the compiler warns you because
 your code computes a result that is useless since this result is
 just deleted after computation. Hence, if useful at all, this
 computation is performed only for its side-effects; hence it should
 return unit.&lt;br /&gt;
 Most of the time, the warning indicates the use of the wrong
 function, a probable confusion between the side-effect only version
 of a function (which is a procedure whose result is irrelevant) with
 its functional counterpart (whose result is meaningful).&lt;br /&gt;
 In the example mentioned above, the first situation prevailed, and
 the programmer should have called `iter` instead of `map`, and
 simply write

```ocaml
List.iter f l;
print_newline ()
```
In actual programs, the suitable (side-effect only) function may not
exist and has to be written: very often, a careful separation of the
procedural part from the functional part of the function at hand
elegantly solves the problem, and the resulting program just looks
better afterwards! For instance, you would turn the problematic
definition:

```ocaml
let add x y =
  if x &gt; 1 then print_int x;
  print_newline ();
  x + y;;
```
into the clearer separate definitions and change old calls to `add`
accordingly.



In any case, use the `let _ = ...` construction exactly in those cases
where you want to ignore a result. Don&#39;t systematically replace
sequences with this construction.

&gt; 
&gt; **Justification**: Sequences are much clearer! Compare `e1; e2; e3` to
&gt; 
&gt; ```ocaml
&gt; let _ = e1 in
&gt; let _ = e2 in
&gt; e3
&gt; ```

###  The `hd` and `tl` functions
Don&#39;t use the `hd` and `tl` functions, but pattern-match the list
argument explicitly.

&gt; 
&gt; **Justification**: This is just as brief as and much clearer than
&gt; using `hd` and `tl` which must of necessity be protected by
&gt; `try... with...` to catch the exception which might be raised by these
&gt; functions.
&gt; 

###  Loops
####  `for` loops
To simply traverse an array or a string, use a `for` loop.

```ocaml
for i = 0 to Array.length v - 1 do
  ...
done
```
If the loop is complex or returns a result, use a recursive function.

```ocaml
let find_index e v =
  let rec loop i =
    if i &gt;= Array.length v then raise Not_found else
    if v.(i) = e then i else loop (i + 1) in
  loop 0;;
```
&gt; 
&gt; **Justification**: The recursive function lets you code any loop
&gt; whatsoever simply, even a complex one, for example with multiple exit
&gt; points or with strange index steps (steps depending on a data value
&gt; for example).
&gt; 
&gt; Besides, the recursive loop avoids the use of mutables whose value can
&gt; be modified in any part of the body of the loop whatsoever (or even
&gt; outside): on the contrary the recursive loop explicitly takes as
&gt; arguments the values susceptible to change during the recursive calls.
&gt; 

####  `while` loops
&gt; 
&gt; **While loops law**: Beware: usually a while loop is wrong, unless its
&gt; loop invariant has been explicitly written.
&gt; 

The main use of the `while` loop is the infinite loop
`while true do     ...`. You get out of it through an exception,
generally on termination of the program.

Other `while` loops are hard to use, unless they come from canned
programs from algorithms courses where they were proved.

&gt; 
&gt; **Justification**: `while` loops require one or more mutables in order
&gt; that the loop condition change value and the loop finally terminate.
&gt; To prove their correctness, you must therefore discover the loop
&gt; invariants, an interesting but difficult sport.
&gt; 

###  Exceptions
Don&#39;t be afraid to define your own exceptions in your programs, but on
the other hand use as much as possible the exceptions predefined by the
system. For example every search function which fails should raise the
predefined exception `Not_found`. Be careful to handle the exceptions
which may be raised by a function call with the help of a
`try ... with`.

Handling all exceptions by `try     ... with _ -&gt;` is usually reserved
for the main function of the program. If you need to catch all
exceptions to maintain an invariant of an algorithm, be careful to name
the exception and re-raise it, after having reset the invariant.
Typically:

```ocaml
let ic = open_in ...
and oc = open_out ... in
try
  treatment ic oc;
  close_in ic; close_out oc
with x -&gt; close_in ic; close_out oc; raise x
```
&gt; 
&gt; **Justification**: `try ... with _     -&gt;` silently catches all
&gt; exceptions, even those which have nothing to do with the computation
&gt; at hand (for example an interruption will be captured and the
&gt; computation will continue anyway!).
&gt; 

###  Data structures
One of the great strengths of OCaml is the power of the data structures
which can be defined and the simplicity of manipulating them. So you
must take advantage of this to the fullest extent; don&#39;t hesitate to
define your own data structures. In particular, don&#39;t systematically
represent enumerations by whole numbers, nor enumerations with two cases
by booleans. Examples:

```ocaml
type figure =
   | Triangle | Square | Circle | Parallelogram
type convexity =
   | Convex | Concave | Other
type type_of_definition =
   | Recursive | Non_recursive
```
&gt; 
&gt; **Justification**: A boolean value often prevents intuitive
&gt; understanding of the corresponding code. For example, if
&gt; `type_of_definition` is coded by a boolean, what does `true` signify?
&gt; A “normal” definition (that is, non-recursive) or a recursive
&gt; definition?
&gt; 
&gt; In the case of an enumerated type encode by an integer, it is very
&gt; difficult to limit the range of acceptable integers: one must define
&gt; construction functions that will ensure the mandatory invariants of
&gt; the program (and verify afterwards that no values has been built
&gt; directly), or add assertions in the program and guards in pattern
&gt; matchings. This is not good practice, when the definition of a sum
&gt; type elegantly solves this problem, with the additional benefit of
&gt; firing the full power of pattern matching and compiler&#39;s verifications
&gt; of exhaustiveness.
&gt; 
&gt; **Criticism**: For binary enumerations, one can systematically define
&gt; predicates whose names carry the semantics of the boolean that
&gt; implements the type. For instance, we can adopt the convention that a
&gt; predicate ends by the letter `p`. Then, in place of defining a new sum
&gt; type for `type_of_definition`, we will use a predicate function
&gt; `recursivep` that returns true if the definition is recursive.
&gt; 
&gt; **Answer**: This method is specific to binary enumeration and cannot
&gt; be easily extended; moreover it is not well suited to pattern
&gt; matching. For instance, for definitions encoded by
&gt; `| Let of bool * string * expression` a typical pattern matching would
&gt; look like:
&gt; 
&gt; ```ocaml
&gt; | Let (_, v, e) as def -&gt;
&gt;    if recursivep def then code_for_recursive_case
&gt;    else code_for_non_recursive_case
&gt; ```
&gt; 
&gt; or, if `recursivep` can be applied to booleans:
&gt; 
&gt; ```ocaml
&gt; | Let (b, v, e) -&gt;
&gt;    if recursivep def then code_for_recursive_case
&gt;    else code_for_non_recursive_case
&gt; ```
&gt; 
&gt; contrast with an explicit encoding:
&gt; 
&gt; ```ocaml
&gt; | Let (Recursive, v, e) -&gt; code_for_recursive_case
&gt; | Let (Non_recursive, v, e) -&gt; code_for_non_recursive_case
&gt; ```
&gt; 
&gt; The difference between the two programs is subtle and you may think
&gt; that this is just a matter of taste; however the explicit encoding is
&gt; definitively more robust to modifications and fits better with the
&gt; language.
&gt; 

*A contrario*, it is not necessary to systematically define new types
for boolean flags, when the interpretation of constructors `true` and
`false` is clear. The usefulness of the definition of the following
types is then questionable:

```ocaml
type switch = On | Off
type bit = One | Zero
```
The same objection is admissible for enumerated types represented as
integers, when those integers have an evident interpretation with
respect to the data to be represented.

###  When to use mutables
Mutable values are useful and sometimes indispensable to simple and
clear programming. Nevertheless, you must use them with discernment:
OCaml&#39;s normal data structures are immutable. They are to be preferred
for the clarity and safety of programming which they allow.

###  Iterators
OCaml&#39;s iterators are a powerful and useful feature. However you should
not overuse them, nor *a contrario* neglect them: they are provided to
you by libraries and have every chance of being correct and
well-thought-out by the author of the library. So it&#39;s useless to
reinvent them.

So write

```ocaml
let square_elements elements = List.map carre elements
```
rather than:

```ocaml
let rec square_elements = function
  | [] -&gt; []
  | elem :: elements -&gt; square elem :: square_elements elements
```
On the other hand avoid writing:

```ocaml
let iterator f x l =
  List.fold_right (List.fold_left f) [List.map x l] l
```
even though you get:

```ocaml
  let iterator f x l =
    List.fold_right (List.fold_left f) [List.map x l] l;;
  iterator (fun l x -&gt; x :: l) (fun l -&gt; List.rev l) [[1; 2; 3]]
```
In case of express need, you must be careful to add an explanatory
comment: in my opinion it&#39;s absolutely necessary!

###  How to optimize programs
&gt; 
&gt; **Pseudo law of optimization**: No optimization *a priori*.&lt;br /&gt;
&gt;  No optimization *a posteriori* either.
&gt; 

Above all program simply and clearly. Don&#39;t start optimizing until the
program bottleneck has been identified (in general a few routines). Then
optimization consists above all of changing *the complexity* of the
algorithm used. This often happens through redefining the data
structures being manipulated and completely rewriting the part of the
program which poses a problem.

&gt; 
&gt; **Justification**: Clarity and correctness of programs take
&gt; precedence. Besides, in a substantial program, it is practically
&gt; impossible to identify *a priori* the parts of the program whose
&gt; efficiency is of prime importance.
&gt; 

###  How to choose between classes and modules
You should use OCaml classes when you need inheritance, that is,
incremental refinement of data and their functionality.

You should use conventional data structures (in particular, variant
types) when you need pattern-matching.

You should modules when the data structures are fixed and their
functionality is equally fixed or it&#39;s enough to add new functions in
the programs which use them.

###  Clarity of OCaml code
The OCaml language includes powerful constructs which allow simple and
clear programming. The main problem to obtain crystal clear programs it
to use them appropriately.

The language features numerous programming styles (or programming
paradigms): imperative programming (based on the notion of state and
assignment), functional programming (based on the notion of function,
function results, and calculus), object oriented programming (based of
the notion of objects encapsulating a state and some procedures or
methods that can modify the state). The first work of the programmer is
to choose the programming paradigm that fits the best the problem at
hand. When using one of those programming paradigms, the difficulty is
to use the language construct that expresses in the most natural and
easiest way the computation that implements the algorithm.

####  Style dangers
Concerning programming styles, one can usually observe the two
symmetrical problematic behaviors: on the one hand, the </code></pre>
<p>all
imperative&#39;&#39; way (<em>systematic</em> usage of loops and assignment), and on
the other hand the</p>
<pre><code>purely functional&#39;&#39; way (*never* use loops nor
assignments); the </code></pre>
<p>100% object&#39;&#39; style will certainly appear in the
next future, but (fortunately) it is too new to be discussed here.</p>
<ul>
 <li><strong>The <code>Too much imperative&#39;&#39; danger</code></strong>:
  <ul>
   <li>It is a bad idea to use imperative style to code a function that
 is <em>naturally</em> recursive. For instance, to compute the length of
 a list, you should not write:</li>
  </ul>
 </li>
</ul>

<pre><code class='ocaml'><script>ml075d557116f5b1c455b00938cdac366c = 'let list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l &#60;&#62; [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> list_length l <span class='k'>=</span>
  <span class='k'>let</span> l <span class='k'>=</span> ref l <span class='k'>in</span>
  <span class='k'>let</span> res <span class='k'>=</span> ref 0 <span class='k'>in</span>
  <span class='k'>while</span> <span class='o'>!</span>l <span class='o'>&#60;&#62;</span> <span class='o'>[</span><span class='o'>]</span> <span class='k'>do</span>
    incr res<span class='o'>;</span> l <span class='o'>:=</span> <span class='m'>List</span><span class='o'>.</span>tl <span class='o'>!</span>l
  <span class='k'>done</span><span class='o'>;</span>
  <span class='o'>!</span>res<span class='o'>;;</span>
</code></pre>
<p>
in place of the following recursive function, so simple and
clear:</p>
<pre><code class='ocaml'><script>mle141f1e7600693cb943f51b0deef6963 = 'let rec list_length = function\n  | [] -&#62; 0\n  | _ :: l -&#62; 1 + list_length l\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let rec</span> list_length <span class='k'>=</span> <span class='k'>function</span>
  <span class='o'>|</span> <span class='o'>[</span><span class='o'>]</span> <span class='k'>-></span> 0
  <span class='o'>|</span> <span class='o'>_</span> <span class='o'>::</span> l <span class='k'>-></span> 1 <span class='o'>+</span> list_length l
</code></pre>
<p>
(For those that would contest the equivalence of those two
versions, see the <a href='#equivalenceprogrammes'>note below</a>).</p>
<pre><code class='ocaml'><script>mlcce3fea4e268f2b1a3ffcdd3b3b0fdca = '-   Another common “over imperative error” in the imperative world\n    is not to systematically choose the simple `for` loop to iter on\n    the element of a vector, but instead to use a complex `while`\n    loop, with one or two references (too many useless assignments,\n    too many opportunity for errors).\n-   This category of programmer consider that the `mutable` keyword\n    in the record type definitions should be implicit.\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='o'>-</span>   Another common “over imperative error” <span class='k'>in</span> the imperative world
    is not <span class='k'>to</span> systematically choose the simple `<span class='k'>for</span>` loop <span class='k'>to</span> iter on
    the element <span class='k'>of</span> a vector<span class='o'>,</span> but instead <span class='k'>to</span> use a complex `<span class='k'>while</span>`
    loop<span class='o'>,</span> <span class='k'>with</span> one <span class='k'>or</span> two references (too many useless assignments<span class='o'>,</span>
    too many opportunity <span class='k'>for</span> errors)<span class='o'>.</span>
<span class='o'>-</span>   This category <span class='k'>of</span> programmer consider that the `<span class='k'>mutable</span>` keyword
    <span class='k'>in</span> the record <span class='k'>type</span> definitions should be implicit<span class='o'>.</span>
</code></pre>
<ul>
 <li><strong>The “Too much functional” danger</strong>:
  <ul>
   <li>The programmer that suffers from this disease carefully avoids
 to use arrays and assignment. In the most severe forms, one
 observe a complete denial of writing any imperative
 construction, even in case it is evidently the most elegant way
 to solve the problem.
   </li>
   <li>Characteristic symptoms: systematic rewriting of <code>for</code> loops
 with recursive functions, usage of lists in contexts where
 imperative data structures seem to be mandatory to anyone,
 passing numerous global parameters of the problem to every
 functions, even if a global reference would be perfect to avoid
 these spurious parameters that are mainly invariants that must
 be passed all over the place.
   </li>
   <li>This programmer think that the <code>mutable</code> keyword in the record
 types definitions should be suppressed from the language.</li>
  </ul>
 </li>
</ul>

<h4 id="OCamlcodegenerallyconsideredunreadable"> OCaml code generally considered unreadable</h4><p>
The OCaml language includes powerful constructs which allow simple and
clear programming. However the power of these constructs also lets you
write uselessly complicated code, to the point where you get a perfectly
unreadable program.</p>
<p>Here are a number of known ways:</p>
<ul>
 <li>Use useless (hence nocive for readability) <code>if then else</code>, as in</li>
</ul>

<pre><code class='ocaml'><script>mla6d60d0f5bb83535c64e508369ca5ca9 = 'let flush_ps () =\n  if not !psused then psused := true\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> flush_ps () <span class='k'>=</span>
  <span class='k'>if</span> not <span class='o'>!</span>psused <span class='k'>then</span> psused <span class='o'>:=</span> <span class='o'>true</span>
</code></pre>
<p>
or (more subtle)</p>
<pre><code class='ocaml'><script>mlda177231c0e36a9674a1e29b432b8d0a = 'let sync b =\n  if !last_is_dvi &#60;&#62; b then last_is_dvi := b\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> sync b <span class='k'>=</span>
  <span class='k'>if</span> <span class='o'>!</span>last_is_dvi <span class='o'>&#60;&#62;</span> b <span class='k'>then</span> last_is_dvi <span class='o'>:=</span> b
</code></pre>
<ul>
 <li>Code one construct with another. For example code a <code>let ... in</code> by
 the application of an anonymous function to an argument. You would
 write<br /></li>
</ul>

<pre><code class='ocaml'><script>mlcf771795e4e0deecd62aa015b5a033ce = '(fun x y -&#62; x + y)\n   e1 e2\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span>(<span class='k'>fun</span> x y <span class='k'>-></span> x <span class='o'>+</span> y)
   e1 e2
</code></pre>
<p>
instead of simply writing</p>
<pre><code class='ocaml'><script>mlab29d8b7560bc2a52b02a2528126c757 = 'let x = e1\nand y = e2 in\nx + y\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> x <span class='k'>=</span> e1
<span class='k'>and</span> y <span class='k'>=</span> e2 <span class='k'>in</span>
x <span class='o'>+</span> y
</code></pre>
<ul>
 <li>Systematically code sequences with <code>let in</code> bindings.</li>
</ul>

<ul>
 <li>Mix computations and side effects, particularly in function calls.
 Recall that the order of evaluation of arguments in a function call
 is unspecified, which implies that you must not mix side effects and
 computations in function calls. However, when there is only one
 argument you might take advantage of this to perform a side effect
 within the argument, which is extremely troublesome for the reader
 albeit without danger to the program semantics. To be absolutely
 forbidden.</li>
</ul>

<ul>
 <li>Misuse of iterators and higher-order functions (i.e. overuse or
 under-use them). For example it&#39;s better to use <code>List.map</code> or
 <code>List.iter</code> than to write their equivalents in-line using specific
 recursive functions of your own. Even worse, you don&#39;t use
 <code>List.map</code> or <code>List.iter</code> but write their equivalents in terms of
 <code>List.fold_right</code> and <code>List.fold_left</code>.</li>
</ul>

<ul>
 <li>Another efficient way to write unreadable code is to mix all or some
 of these methods. For example:</li>
</ul>

<pre><code class='ocaml'><script>ml4b47b0c981c97a3045347db5f7345d3d = '(fun u -&#62; print_string &#34;world&#34;; print_string u)\n  (let temp = print_string &#34;Hello&#34;; &#34;!&#34; in\n   ((fun x -&#62; print_string x; flush stdout) &#34; &#34;;\n    temp));;\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span>(<span class='k'>fun</span> u <span class='k'>-></span> print_string <span class='s'>&#34;world&#34;</span><span class='o'>;</span> print_string u)
  (<span class='k'>let</span> temp <span class='k'>=</span> print_string <span class='s'>&#34;Hello&#34;</span><span class='o'>;</span> <span class='s'>&#34;!&#34;</span> <span class='k'>in</span>
   ((<span class='k'>fun</span> x <span class='k'>-></span> print_string x<span class='o'>;</span> flush stdout) <span class='s'>&#34; &#34;</span><span class='o'>;</span>
    temp))<span class='o'>;;</span>
</code></pre>
<p>If you naturally write the program <code>print_string &quot;Hello world!&quot;</code> in this
way, you can without a doubt submit your work to the <a href='mailto:Pierre.Weis@inria.fr'>Obfuscated OCaml
Contest</a>.</p>
<h2 id="Managingprogramdevelopment"> Managing program development</h2><p>
We give here tips from veteran OCaml programmers, which have served in
developing the compilers which are good examples of large complex
programs developed by small teams.</p>
<h3 id="Howtoeditprograms"> How to edit programs</h3><p>
Many developers nurture a kind of veneration towards the Emacs editor
(gnu-emacs in general) which they use to write their programs. The
editor interfaces well with the language since it is capable of syntax
coloring OCaml source code (rendering different categories of words in
color, coloring keywords for example).</p>
<p>The following two commands are considered indispensable:</p>
<ul>
 <li><code>CTRL-C-CTRL-C</code> or <code>Meta-X compile</code>: launches re-compilation from
 within the editor (using the <code>make</code> command).
 </li>
 <li><code> CTRL-X-` </code>: puts the cursor in the file and at the exact place
 where the OCaml compiler has signaled an error.</li>
</ul>

<p>Developers describe thus how to use these features: <code>CTRL-C-CTRL-C</code>
combination recompiles the whole application; in case of errors, a
succession of <code> CTRL-X-` </code> commands permits correction of all the
errors signaled; the cycle begins again with a new re-compilation
launched by <code>CTRL-C-CTRL-C</code>.</p>
<h4 id="Otheremacstricks"> Other emacs tricks</h4><p>
The <code>ESC-/</code> command (dynamic-abbrev-expand) automatically completes the
word in front of the cursor with one of the words present in one of the
files being edited. Thus this lets you always choose meaningful
identifiers without the tedium of having to type extended names in your
programs: the <code>ESC-/</code> easily completes the identifier after typing the
first letters. In case it brings up the wrong completion, each
subsequent <code>ESC-/</code> proposes an alternate completion.</p>
<p>Under Unix, the <code>CTRL-C-CTRL-C</code> or <code>Meta-X     compile</code> combination,
followed by <code> CTRL-X-` </code> is also used to find all occurrences of a
certain string in a OCaml program. Instead of launching <code>make</code> to
recompile, you launch the <code>grep</code> command; then all the</p>
<pre><code class='error'>messages&#39;&#39; from `grep` are compatible with the </code></pre>
<p> CTRL-X-</p>
<pre><code> `` usage
which automatically takes you to the file and the place where the string
is found.

###  How to edit with the interactive system
Under Unix: use the line editor </code></pre>
<p>ledit</p>
<pre><code> which offers great editing
capabilities ``à la emacs&#39;&#39; (including </code></pre>
<p>ESC-/</p>
<pre><code>!), as well as a history
mechanism which lets you retrieve previously typed commands and even
retrieve commands from one session in another. </code></pre>
<p>ledit</p>
<pre><code> is written in
OCaml and can be freely down-loaded
[here](ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz).

###  How to compile
The </code></pre>
<p>make</p>
<pre><code> utility is indispensable for managing the compilation and
re-compilation of programs. Sample </code></pre>
<p>make</p>
<pre><code> files can be found on [The
Hump](http://caml.inria.fr//cgi-bin/hump.en.cgi). You can also consult
the </code></pre>
<p>Makefiles</p>
<pre><code> for the OCaml compilers.

###  How to develop as a team: version control
Users of the [Git](http://git-scm.com/) software version control system
are never run out of good things to say about the productivity gains it
brings. This system supports managing development by a team of
programmers while imposing consistency among them, and also maintains a
log of changes made to the software.&lt;br /&gt;
 Git also supports simultaneous development by several teams, possibly
dispersed among several sites linked on the Net.

An anonymous Git read-only mirror [contains the working sources of the
OCaml compilers](https://github.com/ocaml/ocaml), and the sources of
other software related to OCaml.

###  Notes
####  Imperative and functional versions of </code></pre>
<p>list_length</p>
<pre><code>The two versions of </code></pre>
<p>list_length</p>
<pre><code> are not completely equivalent in term
of complexity, since the imperative version uses a constant amount of
stack room to execute, whereas the functional version needs to store
return addresses of suspended recursive calls (whose maximum number is
equal to the length of the list argument). If you want to retrieve a
constant space requirement to run the functional program you just have
to write a function that is recursive in its tail (or *tail-rec*), that
is a function that just ends by a recursive call (which is not the case
here since a call to </code></pre>
<p>+</p>
<pre><code> has to be perform after the recursive call has
returned). Just use an accumulator for intermediate results, as in:

```ocaml
let list_length l =
  let rec loop accu = function
    | [] -&gt; accu
    | _ :: l -&gt; loop (accu + 1) l in
  loop 0 l
```
This way, you get a program that has the same computational properties
as the imperative program with the additional clarity and natural
looking of an algorithm that performs pattern matching and recursive
calls to handle an argument that belongs to a recursive sum data type.


</code></pre>

          </div>
        </div>
      </div>
    </div>
    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-right">
            <li><a href="#">Feedback</a></li>
            <li><a href="#">Contact us</a></li>
            <li><a href="#">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
  </body>
</html>
