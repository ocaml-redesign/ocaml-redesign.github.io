<!DOCTYPE HTML>

<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title> &ndash; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet">
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet">
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen">
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <script type="text/javascript">
      function octry(x){
        if(document.getElementById('buttons').innerHTML=='') {
          t = document.getElementById('tryocaml');
          js = document.createElement("script"); js.type = "text/javascript"; js.src = "/try-ocaml.js";
          t.appendChild(js);
        } else {
          t = document.getElementById('tryocaml');
          t.style.display = 'block';
          document.getElementById('console').value = x;
          document.getElementById('console').focus();
          document.getElementById('console').select();
        }
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml"></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/pkg/">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
        <div class="container">
      <div class="row">

        <div class="span4">
          <nav id="nav-secondary">
            <ul class="nav nav-list">
              <li class="nav-header"><a href="#">Contents</a></li>
<ul>
 <li><a href='#Generalguidelinestowriteprograms'> General guidelines to write programs</a>
  <ul>
   <li><a href='#Besimpleandreadable'> Be simple and readable</a>
   </li>
  </ul>
 </li>
 <li><a href='#Programformattingguidelines'> Program formatting guidelines</a>
  <ul>
   <li><a href='#Lexicalconventions'> Lexical conventions</a>
   </li>
  </ul>
 </li>
 <li><a href='#Indentationofprograms'> Indentation of programs</a>
  <ul>
   <li><a href='#Consistencyofindentation'> Consistency of indentation</a>
   </li>
   <li><a href='#Widthofthepage'> Width of the page</a>
   </li>
   <li><a href='#Heightofthepage'> Height of the page</a>
   </li>
   <li><a href='#Howmuchtoindent'> How much to indent</a>
   </li>
   <li><a href='#Usingtabstops'> Using tab stops</a>
   </li>
   <li><a href='#Howtoindentgloballetdefinitions'> How to indent global <code>let ... ;;</code> definitions</a>
   </li>
   <li><a href='#Howtoindentletinconstructs'> How to indent <code>let ... in</code> constructs</a>
   </li>
   <li><a href='#Howtoindentifthenelse'> How to indent <code>if ... then   ... else ... </code></a>
   </li>
   <li><a href='#Howtoindentpatternmatchingconstructs'> How to indent pattern-matching constructs</a>
   </li>
   <li><a href='#Badindentationofpatternmatchingconstructs'> Bad indentation of pattern-matching constructs</a>
   </li>
   <li><a href='#Howtoindentfunctioncalls'> How to indent function calls</a>
   </li>
  </ul>
 </li>
 <li><a href='#Programmingguidelines'> Programming guidelines</a>
  <ul>
   <li><a href='#Howtoprogram'> How to program</a>
   </li>
   <li><a href='#Howtocommentprograms'> How to comment programs</a>
   </li>
   <li><a href='#Howtochooseidentifiers'> How to choose identifiers</a>
   </li>
   <li><a href='#Whentouseparentheseswithinanexpression'> When to use parentheses within an expression</a>
   </li>
   <li><a href='#Howtodelimitconstructsinprograms'> How to delimit constructs in programs</a>
   </li>
   <li><a href='#Howtousemodules'> How to use modules</a>
   </li>
   <li><a href='#Patternmatching'> Pattern-matching</a>
   </li>
   <li><a href='#Compilerwarnings'> Compiler warnings</a>
   </li>
  </ul>
 </li>
 <li><a href='#Managingprogramdevelopment'> Managing program development</a>
  <ul>
   <li><a href='#Howtoeditprograms'> How to edit programs</a>
   </li>
  </ul>
 </li>
</ul>

            </ul>
          </nav>
        </div>


          <div id='main-contents' class="content">
            
<h1 id="OCamlProgrammingGuidelines"> OCaml Programming Guidelines</h1><p>
This is a set of reasonable guidelines for formatting OCaml
programs—guidelines which reflect the consensus among veteran OCaml
programmers. Nevertheless, all detailed notifications of possible errors
or omissions will be noted with pleasure. To send your comments using
<a href='https://github.com/ocaml/ocaml.org/issues?state=open'>GitHub issues</a>.
<br />
Original translation from French: <a href='mailto:datta@math.berkeley.edu'>Ruchira
Datta</a>.</p>
<p>Thanks to all those who have already participated in the critique of
this page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien
Doligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,
Basile Starynkevitch, Toby Moth, Pierre Lescanne.</p>
<h2 id="Generalguidelinestowriteprograms"> General guidelines to write programs</h2><h3 id="Besimpleandreadable"> Be simple and readable</h3><p>

The time you spend typing the programs is neglectable compared to the
time spent reading them. That&#39;s the reason why you save a lot of time if
you work hard to optimize readability.</p>
<p>All the time you are &quot;wasting&quot; to get a simpler program today, will
return a hundred times in the future during the uncountably many
modifications and readings of the program (starting with the first
debugging).</p>
<blockquote>
<p><strong>Writing programs law</strong>: A program is written once, modified ten
times, and read 100 times. So simplify its writing, always keep future
modifications in mind, and never jeopardize readability.</p>
</blockquote>
<h2 id="Programformattingguidelines"> Program formatting guidelines</h2><h3 id="Lexicalconventions"> Lexical conventions</h3>
<blockquote>
<p><strong>Pseudo spaces law</strong>: never hesitate to separate words of your
programs with spaces; the space bar is the easiest key to find on the
keyboard, press it as often as necessary!</p>
</blockquote>
<h4 id="Delimiters"> Delimiters</h4><p>
A space should always follow a delimiter symbol, and spaces should
surround operator symbols. It has been a great step forward in
typography to separate words by spaces to make written texts easier to
read. Do the same in your programs if you want them to be readable.</p>
<h4 id="Howtowritepairs"> How to write pairs</h4><p>
A tuple is parenthesized and the commas therein (delimiters) are each
followed by a space: <code>(1, 2)</code>, <code>let   triplet = (x, y, z)</code>...</p>
<ul>
 <li><strong>Commonly accepted exceptions</strong>:
  <ul>
   <li><strong>Definition of the components of a pair</strong>: In place of
 <code>let (x, y) =       ...</code>, you can write <code>let x, y = ...</code>.</li>
  </ul>
 </li>
</ul>

<blockquote>
<p><strong>Justification</strong>: The point is to define several values
simultaneously, not to construct a tuple. Moreover, the
pattern is set off nicely between <code>let</code> and <code>=</code>.</p>
</blockquote>
<pre><code class='ocaml'><span class='o'>-</span>   <span class='o'>**</span>Matching several values simultaneously<span class='o'>**:</span> It's okay <span class='k'>to</span> omit
    parentheses around n<span class='o'>-</span>tuples <span class='k'>when</span> matching several values
    simultaneously<span class='o'>.</span>

        <span class='k'>match</span> x<span class='o'>,</span> y <span class='k'>with</span>
        <span class='o'>|</span> 1<span class='o'>,</span> <span class='o'>_</span> <span class='k'>-></span> <span class='o'>...</span>
        <span class='o'>|</span> x<span class='o'>,</span> 1 <span class='k'>-></span> <span class='o'>...</span>
        <span class='o'>|</span> x<span class='o'>,</span> y <span class='k'>-></span> <span class='o'>...</span>

    <span class='o'>&#62;</span> <span class='o'>**</span>Justification<span class='o'>**:</span> The point is <span class='k'>to</span> <span class='k'>match</span> several values <span class='k'>in</span>
    <span class='o'>&#62;</span> parallel<span class='o'>,</span> not <span class='k'>to</span> construct a tuple<span class='o'>.</span> Moreover<span class='o'>,</span> the expressions
    <span class='o'>&#62;</span> being matched are set off by `<span class='k'>match</span>` <span class='k'>and</span> `<span class='k'>with</span>`<span class='o'>,</span> <span class='k'>while</span> the
    <span class='o'>&#62;</span> patterns are set off nicely by `<span class='o'>|</span>` <span class='k'>and</span> `<span class='k'>-></span>`<span class='o'>.</span>
<a href="javascript:octry('-   **Matching several values simultaneously**: It&#39;s okay to omit\n    parentheses around n-tuples when matching several values\n    simultaneously.\n\n        match x, y with\n        | 1, _ -&#62; ...\n        | x, 1 -&#62; ...\n        | x, y -&#62; ...\n\n    &#62; **Justification**: The point is to match several values in\n    &#62; parallel, not to construct a tuple. Moreover, the expressions\n    &#62; being matched are set off by `match` and `with`, while the\n    &#62; patterns are set off nicely by `|` and `-&#62;`.\n');">[try]</a></code></pre>
<h4 id="Howtowritelists"> How to write lists</h4><p>

Write <code>x :: l</code> with spaces around the <code>::</code> (since <code>::</code> is an infix
operator, hence surrounded by spaces) and <code>[1; 2; 3]</code> (since <code>;</code> is a
delimiter, hence followed by a space).</p>
<h4 id="Howtowriteoperatorsymbols"> How to write operator symbols</h4><p>
Be careful to keep operator symbols well separated by spaces: not only
will your formulas be more readable, but you will avoid confusion with
multi-character operators. (Obvious exceptions to this rule: the symbols
<code>!`&#39;&#39; and </code>.</p>
<pre><code>&#39;&#39; are not separated from their arguments.)
Example: write </code></pre>
<p>x + 1<code> or </code>x + !y</p>
<pre><code>.

&gt; 
&gt; **Justification**: If you left out the spaces then </code></pre>
<p>x+1</p>
<pre><code> would be
&gt; understood, but </code></pre>
<p>x+!y<code> would change its meaning since ```+!</code>&#39;&#39; would</p>
<blockquote><p>
be interpreted as a multi-character operator.</p>
<p><strong>Criticism</strong>: The absence of spaces around an operator improves the
readability of formulas when you use it to reflect the relative
precedences of operators. For example <code>x*y + 2*z</code> makes it very
obvious that multiplication takes precedence over addition.</p>
<p><strong>Response</strong>: This is a bad idea, a chimera, because nothing in the
language ensures that the spaces properly reflect the meaning of the
formula. For example <code>x * z-1</code> means <code>(x * z) - 1</code>, and not
<code>x * (z - 1)</code> as the proposed interpretation of spaces would seem to
suggest. Besides, the problem of multi-character symbols would keep
you from using this convention in a uniform way: you couldn&#39;t leave
out the spaces around the multiplication to write <code>x*!y + 2*!z</code>.
Finally, this playing with the spaces is a subtle and flimsy
convention, a subliminal message which is difficult to grasp on
reading. If you want to make the precedences obvious, use the
expressive means brought to you by the language: write parentheses.</p>
<p><strong>Additional justification</strong>: Systematically surrounding operators
with spaces simplify the treatment of infix operators which are no
more a complex particular case; in effect, whereas you can write <code>(+)</code>
without spaces, you evidently cannot write <code>(*)</code> since <code>(*</code> is read as
the beginning of a comment. You must write at least one space as in
“<code>( *)</code>”, although an extra space after <code>*</code> is definitively preferable
if you want to avoid that <code>*)</code> could be read, in some contexts, as the
end of a comment. All those difficulties are easily avoided if you
adopt the simple rule proposed here: keep operator symbols well
separated by spaces.<br />
 In fact you will quickly feel that this rule is not so difficult to
follow: the space bar is the greatest and best situated key of the
keyboard, it is the easiest to enter and you cannot miss it!</p>
</blockquote>
<h4 id="Howtowritelongcharacterstrings"> How to write long character strings</h4><p>
Indent long character strings with the convention in force at that line
plus an indication of string continuation at the end of each line (a <code>\</code>
character at the end of the line that omits white spaces on the
beginning of next line):</p>
<pre><code class='ocaml'><span class='k'>let</span> universal_declaration <span class='k'>=</span>
  <span class='s'>&#34;-1- Programs are born and remain free and equal under the law;\n\
   distinctions can only be based on the common good.&#34;</span> <span class='k'>in</span>
  <span class='o'>...</span>
<a href="javascript:octry('let universal_declaration =\n  &#34;-1- Programs are born and remain free and equal under the law;\n\\n   distinctions can only be based on the common good.&#34; in\n  ...\n');">[try]</a></code></pre>
<h2 id="Indentationofprograms"> Indentation of programs</h2>
<blockquote>
<p><strong>Landin&#39;s pseudo law</strong>: Treat the indentation of your programs as if
it determines the meaning of your programs.</p>
</blockquote>
<p>I would add to this law: carefully treat the indentation of programs
because in some cases it really gives the meaning of the program!</p>
<p>The indentation of programs is an art which excites many strong
opinions. Here several indentation styles are given which are drawn from
experience and which have not been severely criticized.</p>
<p>When a justification for the adopted style has seemed obvious to me, I
have indicated it. On the other hand, criticisms are also noted.</p>
<p>So each time, you have to choose between the different styles
suggested.<br />
 The only absolute rule is the first below.</p>
<h3 id="Consistencyofindentation"> Consistency of indentation</h3><p>
Choose a generally accepted style of indentation, then use it
systematically throughout the whole application.</p>
<h3 id="Widthofthepage"> Width of the page</h3><p>
The page is 80 columns wide.</p>
<blockquote>
<p><strong>Justification</strong>: This width makes it possible to read the code on
all displays and to print it in a legible font on a standard sheet.</p>
</blockquote>
<h3 id="Heightofthepage"> Height of the page</h3><p>
A function should always fit within one screenful (of about 70 lines),
or in exceptional cases two, at the very most three. To go beyond this
is unreasonable.</p>
<blockquote>
<p><strong>Justification</strong>: When a function goes beyond one screenful, it&#39;s
time to divide it into subproblems and handle them independently.
Beyond a screenful, one gets lost in the code. The indentation is not
readable and is difficult to keep correct.</p>
</blockquote>
<h3 id="Howmuchtoindent"> How much to indent</h3><p>
The change in indentation between successive lines of the program is
generally 1 or 2 spaces. Pick an amount to indent and stick with it
throughout the program.</p>
<h3 id="Usingtabstops"> Using tab stops</h3><p>
Using the tab character (ASCII character 9) is absolutely <em>not</em>
recommended.</p>
<blockquote>
<p><strong>Justification</strong>: Between one display and another, the indentation of
the program changes completely; it can also becomes completely wrong,
if the programmer used both tabulations and spaces to indent the
program.</p>
<p><strong>Criticism</strong>: The purpose of using tabulations is just to allow the
readers of the program to indent more or less by changing the tabs
stops. The overall indentation remains correct and the reader is glad
to easily customize the indentation amount.</p>
<p><strong>Answer</strong>: It seems almost impossible to use this method since you
should always use tabulations to indent, which is hard and unnatural.</p>
</blockquote>
<h3 id="Howtoindentgloballetdefinitions"> How to indent global <code>let ... ;;</code> definitions</h3><p>
The body of a function defined globally in a module is generally
indented normally. However, it&#39;s okay to treat this case specially to
set off the definition better.</p>
<p>With a regular indentation of 1 or 2 spaces:</p>
<pre><code class='ocaml'><span class='k'>let</span> f x <span class='k'>=</span> <span class='k'>function</span>
  <span class='o'>|</span> C <span class='k'>-></span>
  <span class='o'>|</span> D <span class='k'>-></span>
  <span class='o'>...</span>

<span class='k'>let</span> g x <span class='k'>=</span>
  <span class='k'>let</span> tmp <span class='k'>=</span>
    <span class='k'>match</span> x <span class='k'>with</span>
    <span class='o'>|</span> C <span class='k'>-></span> 1
    <span class='o'>|</span> x <span class='k'>-></span> 0 <span class='k'>in</span>
  tmp <span class='o'>+</span> 1
<a href="javascript:octry('let f x = function\n  | C -&#62;\n  | D -&#62;\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -&#62; 1\n    | x -&#62; 0 in\n  tmp + 1\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: No exception to the amount of indentation.</p>
</blockquote>
<p>Other conventions are acceptable, for example:</p>
<ul>
 <li>The body is left-justified in the case of pattern-matching.</li>
</ul>

<pre><code class='ocaml'><span class='k'>let</span> f x <span class='k'>=</span> <span class='k'>function</span>
<span class='o'>|</span> C <span class='k'>-></span>
<span class='o'>|</span> D <span class='k'>-></span>
<span class='o'>...</span>
<a href="javascript:octry('let f x = function\n| C -&#62;\n| D -&#62;\n...\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: The vertical bars separating the patterns stop
when the definition is done, so it&#39;s still easy to pass on to the
following definition.</p>
<p><strong>Criticism</strong>: An unpleasant exception to the normal indentation.</p>
</blockquote>
<ul>
 <li>The body is justified just under the name of the defined function.</li>
</ul>

<pre><code class='ocaml'><span class='k'>let</span> f x <span class='k'>=</span>
    <span class='k'>let</span> tmp <span class='k'>=</span> <span class='o'>...</span> <span class='k'>in</span>
    <span class='k'>try</span> g x <span class='k'>with</span>
    <span class='o'>|</span> Not_found <span class='k'>-></span>
    <span class='o'>...</span>
<a href="javascript:octry('let f x =\n    let tmp = ... in\n    try g x with\n    | Not_found -&#62;\n    ...\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: The first line of the definition is set off
nicely, so it&#39;s easier to pass from definition to definition.</p>
<p><strong>Criticism</strong>: You run into the right margin too quickly.</p>
</blockquote>
<h3 id="Howtoindentletinconstructs"> How to indent <code>let ... in</code> constructs</h3><p>
The expression following a definition introduced by <code>let</code> is indented to
the same level as the keyword <code>let</code>, and the keyword <code>in</code> which
introduces it is written at the end of the line:</p>
<pre><code class='ocaml'><span class='k'>let</span> expr1 <span class='k'>=</span> <span class='o'>...</span> <span class='k'>in</span>
expr1 <span class='o'>+</span> expr1
<a href="javascript:octry('let expr1 = ... in\nexpr1 + expr1\n');">[try]</a></code></pre>
<p>
In the case of a series of <code>let</code> definitions, the preceding rule implies
that these definitions should be placed at the same indentation level:</p>
<pre><code class='ocaml'><span class='k'>let</span> expr1 <span class='k'>=</span> <span class='o'>...</span> <span class='k'>in</span>
<span class='k'>let</span> n <span class='k'>=</span> <span class='o'>...</span> <span class='k'>in</span>
<span class='o'>...</span>
<a href="javascript:octry('let expr1 = ... in\nlet n = ... in\n...\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: It is suggested that a series of “let ... in”
constructs is analogous to a set of assumptions in a mathematical
text, whence the same indentation level for all the assumptions.</p>
</blockquote>
<p>Variation: some write the keyword <code>in</code> alone on one line to set apart
the final expression of the computation:</p>
<pre><code class='ocaml'><span class='k'>let</span> e1 <span class='k'>=</span> <span class='o'>...</span> <span class='k'>in</span>
<span class='k'>let</span> e2 <span class='k'>=</span> <span class='o'>...</span> <span class='k'>in</span>
<span class='k'>let</span> new_expr <span class='k'>=</span>
  <span class='k'>let</span> e1' <span class='k'>=</span> derive_expression e1
  <span class='k'>and</span> e2' <span class='k'>=</span> derive_expression e2 <span class='k'>in</span>
  Add_expression e1' e2'
<span class='k'>in</span>
Mult_expression (new_expr<span class='o'>,</span> new_expr)
<a href="javascript:octry('let e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1&#39; = derive_expression e1\n  and e2&#39; = derive_expression e2 in\n  Add_expression e1&#39; e2&#39;\nin\nMult_expression (new_expr, new_expr)\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Criticism</strong>: Lack of consistency.</p>
</blockquote>
<h3 id="Howtoindentifthenelse"> How to indent <code>if ... then   ... else ... </code></h3><h4 id="Multiplebranches"> Multiple branches</h4><p>

Write conditions with multiple branches at the same level of
indentation:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond1 <span class='o'>...</span>
<span class='k'>if</span> cond2 <span class='o'>...</span>
<span class='k'>if</span> cond3 <span class='o'>...</span>
<a href="javascript:octry('if cond1 ...\nif cond2 ...\nif cond3 ...\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: Analogous treatment to pattern-matching clauses,
all aligned to the same tab stop.</p>
</blockquote>
<p>If the sizes of the conditions and the expressions allow, write for
example:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond1 <span class='k'>then</span> e1 <span class='k'>else</span>
<span class='k'>if</span> cond2 <span class='k'>then</span> e2 <span class='k'>else</span>
<span class='k'>if</span> cond3 <span class='k'>then</span> e3 <span class='k'>else</span>
e4
<a href="javascript:octry('if cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n');">[try]</a></code></pre>
<p>
If expressions in the branches of multiple conditions have to be
enclosed (when they include statements for instance), write:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span> <span class='k'>begin</span>
    e1
  <span class='k'>end</span> <span class='k'>else</span>
<span class='k'>if</span> cond2 <span class='k'>then</span> <span class='k'>begin</span>
    e2
  <span class='k'>end</span> <span class='k'>else</span>
<span class='k'>if</span> cond3 <span class='k'>then</span> <span class='o'>...</span>
<a href="javascript:octry('if cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n');">[try]</a></code></pre>
<p>
Some suggest another method for multiple conditionals, starting each
line by the keyword <code>else</code>:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond1 <span class='o'>...</span>
<span class='k'>else</span> <span class='k'>if</span> cond2 <span class='o'>...</span>
<span class='k'>else</span> <span class='k'>if</span> cond3 <span class='o'>...</span>
<a href="javascript:octry('if cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: <code>elsif</code> is a keyword in many languages, so use
indentation and <code>else if</code> to bring it to mind. Morever, you do not
have to look to the end of line to know whether the condition is
continued or another test is performed.</p>
<p><strong>Criticism</strong>: Lack of consistency in the treatment of all the
conditions. Why a special case for the first condition?</p>
</blockquote>
<p>Yet again, choose your style and use it systematically.</p>
<h4 id="Singlebranches"> Single branches</h4><p>
Several styles are possible for single branches, according to the size
of the expressions in question and especially the presence of <code>begin</code>
<code>end</code> or <code>(</code> <code>)</code> delimiters for these expressions.</p>
<p>In the case of delimiting the branches of a conditional, several styles
are used:</p>
<blockquote>
<p>style <code>(</code> at end of line:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span> (
  e1
) <span class='k'>else</span> (
  e2
)
<a href="javascript:octry('if cond then (\n  e1\n) else (\n  e2\n)\n');">[try]</a></code></pre>
<p>
Or alternatively first <code>begin</code> at beginning of line:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span>
  <span class='k'>begin</span>
    e1
  <span class='k'>end</span> <span class='k'>else</span> <span class='k'>begin</span>
    e2
  <span class='k'>end</span>
<a href="javascript:octry('if cond then\n  begin\n    e1\n  end else begin\n    e2\n  end\n');">[try]</a></code></pre>
</blockquote>
<p>In fact the indentation of conditionals depends on the sizes of the
expressions which make them up.</p>
<blockquote>
<p>If <code>cond</code>, <code>e1</code> and <code>e2</code> are small, simply write them on one line:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span> e1 <span class='k'>else</span> e2
<a href="javascript:octry('if cond then e1 else e2\n');">[try]</a></code></pre>
<p>
If the expressions making up a conditional are purely functional
(without side effects), we advocate binding them within the
conditional with <code>let e = ... in</code> when they&#39;re too big to fit on a
line.</p>
<blockquote>
<p><strong>Justification</strong>: This way you get back the simple indentation on
one line which is the most readable. As a side benefit, the naming
acts as an aid to comprehension.</p>
</blockquote>
<p>So now we consider the case in which the expressions in question do
have side effects, which keeps us from simply binding them with a
<code>let e = ... in</code>.</p>
<blockquote>
<p>If <code>e1</code> and <code>cond</code> are small, but <code>e2</code> large:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span> e1 <span class='k'>else</span>
  e2
<a href="javascript:octry('if cond then e1 else\n  e2\n');">[try]</a></code></pre>
<p>If <code>e1</code> and <code>cond</code> are large and <code>e2</code> small:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span>
  e1
<span class='k'>else</span> e2
<a href="javascript:octry('if cond then\n  e1\nelse e2\n');">[try]</a></code></pre>
<p>If all the expressions are large:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span>
  e1
<span class='k'>else</span>
  e2
<a href="javascript:octry('if cond then\n  e1\nelse\n  e2\n');">[try]</a></code></pre>
<p>If there are <code>( )</code> delimiters</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span> (
  e1
) <span class='k'>else</span> (
  e2
)
<a href="javascript:octry('if cond then (\n  e1\n) else (\n  e2\n)\n');">[try]</a></code></pre>
<p>A mixture where <code>e1</code> requires <code>( )</code> but <code>e2</code> is small</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span> (
    e1
) <span class='k'>else</span> e2
<a href="javascript:octry('if cond then (\n    e1\n) else e2\n');">[try]</a></code></pre>
</blockquote>
</blockquote>
<h3 id="Howtoindentpatternmatchingconstructs"> How to indent pattern-matching constructs</h3><h4 id="Generalprinciples"> General principles</h4><p>

All the pattern-matching clauses are introduced by a vertical bar,
<em>including</em> the first one.</p>
<blockquote>
<p><strong>Criticism</strong>: The first vertical bar is not mandatory: hence, there
is no need to write it.</p>
<p><strong>Answer to criticism</strong>: If you omit the first bar the indentation
seems unnatural : the first case gets an indentation that is greater
than a normal new line would necessitate. It is thus a useless
exception to the correct indentation rule. It also insists not to use
the same syntax for the whole set of clauses, writing the first clause
as an exception with a slightly different syntax. Last, aesthetic
value is doubtful dubious (some people would say “awful” instead of
“doubtful”).</p>
</blockquote>
<p>Align all the pattern-matching clauses at the level of the vertical bar
which begins each clause, <em>including</em> the first one.</p>
<p>If an expression in a clause is too large to fit on the line, you must
break the line immediately after the arrow of the corresponding clause.
Then indent normally, starting from the beginning of the pattern of the
clause.</p>
<p>Arrows of pattern matching clauses should not be aligned.</p>
<h4 id="matchortry"> <code>match</code> or <code>try</code></h4><p>
For a <code>match</code> or a <code>try</code> align the clauses with the beginning of the
construct:</p>
<pre><code class='ocaml'><span class='k'>match</span> lam <span class='k'>with</span>
<span class='o'>|</span> Abs (x<span class='o'>,</span> body) <span class='k'>-></span> 1 <span class='o'>+</span> size_lambda body
<span class='o'>|</span> App (lam1<span class='o'>,</span> lam2) <span class='k'>-></span> size_lambda lam1 <span class='o'>+</span> size_lambda lam2
<span class='o'>|</span> Var v <span class='k'>-></span> 1

<span class='k'>try</span> f x <span class='k'>with</span>
<span class='o'>|</span> Not_found <span class='k'>-></span> <span class='o'>...</span>
<span class='o'>|</span> Failure <span class='s'>&#34;not yet implemented&#34;</span> <span class='k'>-></span> <span class='o'>...</span>
<a href="javascript:octry('match lam with\n| Abs (x, body) -&#62; 1 + size_lambda body\n| App (lam1, lam2) -&#62; size_lambda lam1 + size_lambda lam2\n| Var v -&#62; 1\n\ntry f x with\n| Not_found -&#62; ...\n| Failure &#34;not yet implemented&#34; -&#62; ...\n');">[try]</a></code></pre>
<p>
Put the keyword <code>with</code> at the end of the line. If the preceding
expression extends beyond one line, put <code>with</code> on a line by itself:</p>
<pre><code class='ocaml'><span class='k'>try</span>
  <span class='k'>let</span> y <span class='k'>=</span> f x <span class='k'>in</span>
  <span class='k'>if</span> <span class='o'>...</span>
<span class='k'>with</span>
<span class='o'>|</span> Not_found <span class='k'>-></span> <span class='o'>...</span>
<span class='o'>|</span> Failure <span class='s'>&#34;not yet implemented&#34;</span> <span class='k'>-></span> <span class='o'>...</span>
<a href="javascript:octry('try\n  let y = f x in\n  if ...\nwith\n| Not_found -&#62; ...\n| Failure &#34;not yet implemented&#34; -&#62; ...\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: The keyword <code>with</code>, on a line by itself shows that
the program enters the pattern matching part of the construct.</p>
</blockquote>
<h4 id="Indentingexpressionsinsideclauses"> Indenting expressions inside clauses</h4><p>
If the expression on the right of the pattern matching arrow is too
large, cut the line after the arrow.</p>
<pre><code class='ocaml'><span class='k'>match</span> lam <span class='k'>with</span>
<span class='o'>|</span> Abs (x<span class='o'>,</span> body) <span class='k'>-></span>
   1 <span class='o'>+</span> size_lambda body
<span class='o'>|</span> App (lam1<span class='o'>,</span> lam2) <span class='k'>-></span>
   size_lambda lam1 <span class='o'>+</span> size_lambda lam2
<span class='o'>|</span> Var v <span class='k'>-></span>
<a href="javascript:octry('match lam with\n| Abs (x, body) -&#62;\n   1 + size_lambda body\n| App (lam1, lam2) -&#62;\n   size_lambda lam1 + size_lambda lam2\n| Var v -&#62;\n');">[try]</a></code></pre>
<p>
Some programmers generalize this rule to all clauses, as soon as one
expressions overflows. They will then indent the last clause like this:</p>
<pre><code class='ocaml'><span class='o'>|</span> Var v <span class='k'>-></span>
   1
<a href="javascript:octry('| Var v -&#62;\n   1\n');">[try]</a></code></pre>
<p>
Other programmers go one step further and apply this rule systematically
to any clause of any pattern matching.</p>
<pre><code class='ocaml'><span class='k'>let rec</span> fib <span class='k'>=</span> <span class='k'>function</span>
  <span class='o'>|</span> 0 <span class='k'>-></span>
     1
  <span class='o'>|</span> 1 <span class='k'>-></span>
     1
  <span class='o'>|</span> n <span class='k'>-></span>
     fib (n <span class='o'>-</span> 1) <span class='o'>+</span> fib ( n <span class='o'>-</span> 2)
<a href="javascript:octry('let rec fib = function\n  | 0 -&#62;\n     1\n  | 1 -&#62;\n     1\n  | n -&#62;\n     fib (n - 1) + fib ( n - 2)\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Criticism</strong>: May be not compact enough; for simple pattern matchings
(or simple clauses in complex matchings), the rule does not add any
good to readability.</p>
<p><strong>Justitification</strong>: I don&#39;t see any good reason for this rule, unless
you are paid proportionally to the number of lines of code: in this
case use this rule to get more money without adding more bugs in your
OCaml programs!</p>
</blockquote>
<h4 id="Patternmatchinginanonymousfunctions"> Pattern matching in anonymous functions</h4><p>
Similarly to <code>match</code> or <code>try</code>, pattern matching of anonymous functions,
starting by <code>function</code>, are indented with respect to the <code>function</code>
keyword:</p>
<pre><code class='ocaml'>map
  (<span class='k'>function</span>
   <span class='o'>|</span> Abs (x<span class='o'>,</span> body) <span class='k'>-></span> 1 <span class='o'>+</span> size_lambda 0 body
   <span class='o'>|</span> App (lam1<span class='o'>,</span> lam2) <span class='k'>-></span> size_lambda (size_lambda 0 lam1) lam2
   <span class='o'>|</span> Var v <span class='k'>-></span> 1)
  lambda_list
<a href="javascript:octry('map\n  (function\n   | Abs (x, body) -&#62; 1 + size_lambda 0 body\n   | App (lam1, lam2) -&#62; size_lambda (size_lambda 0 lam1) lam2\n   | Var v -&#62; 1)\n  lambda_list\n');">[try]</a></code></pre>
<h4 id="Patternmatchinginnamedfunctions"> Pattern matching in named functions</h4><p>

Pattern-matching in functions defined by <code>let</code> or <code>let rec</code> gives rise
to several reasonable styles which obey the preceding rules for pattern
matching (the one for anonymous functions being evidently excepted). See
above for recommanded styles.</p>
<pre><code class='ocaml'><span class='k'>let rec</span> size_lambda accu <span class='k'>=</span> <span class='k'>function</span>
  <span class='o'>|</span> Abs (x<span class='o'>,</span> body) <span class='k'>-></span> size_lambda (succ accu) body
  <span class='o'>|</span> App (lam1<span class='o'>,</span> lam2) <span class='k'>-></span> size_lambda (size_lambda accu lam1) lam2
  <span class='o'>|</span> Var v <span class='k'>-></span> succ accu

<span class='k'>let rec</span> size_lambda accu <span class='k'>=</span> <span class='k'>function</span>
<span class='o'>|</span> Abs (x<span class='o'>,</span> body) <span class='k'>-></span> size_lambda (succ accu) body
<span class='o'>|</span> App (lam1<span class='o'>,</span> lam2) <span class='k'>-></span> size_lambda (size_lambda accu lam1) lam2
<span class='o'>|</span> Var v <span class='k'>-></span> succ accu
<a href="javascript:octry('let rec size_lambda accu = function\n  | Abs (x, body) -&#62; size_lambda (succ accu) body\n  | App (lam1, lam2) -&#62; size_lambda (size_lambda accu lam1) lam2\n  | Var v -&#62; succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -&#62; size_lambda (succ accu) body\n| App (lam1, lam2) -&#62; size_lambda (size_lambda accu lam1) lam2\n| Var v -&#62; succ accu\n');">[try]</a></code></pre>
<h3 id="Badindentationofpatternmatchingconstructs"> Bad indentation of pattern-matching constructs</h3>
<h4 id="Nobeastlyindentationoffunctionsandcaseanalyses"> No <em>beastly</em> indentation of functions and case analyses.</h4><p>
This consists in indenting normally under the keyword <code>match</code> or
<code>function</code> which has previously been pushed to the right. Don&#39;t write:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> f x <span class='k'>=</span> <span class='k'>function</span>
              <span class='o'>|</span> <span class='o'>[</span><span class='o'>]</span> <span class='k'>-></span> <span class='o'>...</span>
              <span class='o'>...</span>
<a href="javascript:octry('let rec f x = function\n              | [] -&#62; ...\n              ...\n');">[try]</a></code></pre>
<p>
but choose to indent the line under the <code>let</code> keyword:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> f x <span class='k'>=</span> <span class='k'>function</span>
  <span class='o'>|</span> <span class='o'>[</span><span class='o'>]</span> <span class='k'>-></span> <span class='o'>...</span>
  <span class='o'>...</span>
<a href="javascript:octry('let rec f x = function\n  | [] -&#62; ...\n  ...\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: You bump into the margin. The aesthetic value is
doubtful...</p>
</blockquote>
<h4 id="Nobeastlyalignmentofthegtsymbolsinpatternmatchingclauses"> No <em>beastly</em> alignment of the <code>-&gt;</code> symbols in pattern-matching clauses.</h4><p>
Careful alignment of the arrows of a pattern matching is considered bad
practice, as exemplify in the following fragment:</p>
<pre><code class='ocaml'><span class='k'>let</span> f <span class='k'>=</span> <span class='k'>function</span>
  <span class='o'>|</span> C1          <span class='k'>-></span> 1
  <span class='o'>|</span> Long_name <span class='o'>_</span> <span class='k'>-></span> 2
  <span class='o'>|</span> <span class='o'>_</span>           <span class='k'>-></span> 3
<a href="javascript:octry('let f = function\n  | C1          -&#62; 1\n  | Long_name _ -&#62; 2\n  | _           -&#62; 3\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: This makes it harder to maintain the program (the
addition of a supplementary case can lead the indentations of all the
lines to change and so ... we often give up alignment at that time,
then it is better not to align the arrows in the first place!).</p>
</blockquote>
<h3 id="Howtoindentfunctioncalls"> How to indent function calls</h3><h4 id="Indentationtothefunction39sname"> Indentation to the function&#39;s name:</h4><p>

No problem arises except for functions with many arguments --or very
complicated arguments as well-- which can&#39;t fit on the same line. You
must indent the expressions with respect to the name of the function (1
or 2 spaces according to the chosen convention). Write small arguments
on the same line, and change lines at the start of an argument.</p>
<p>As far as possible, avoid arguments which consist of complex
expressions: in these cases define the</p>
<pre><code>large&#39;&#39; argument by a `let`
construction.

&gt; 
&gt; **Justification**: No indentation problem; if the name given to the
&gt; expressions is meaningful, the code is more readable as well.
&gt; 
&gt; **Additional justification**: If the evaluation of the arguments
&gt; produces side effects, the `let` binding is in fact necessary to
&gt; explicitly define the order of evaluation.
&gt; 

####  Naming complex arguments:
In place of

```ocaml
let temp =
  f x y z
    </code></pre>
<p>large</p>
<pre><code>expression&#39;&#39;
``other large
expression&#39;&#39; in</code></pre>
<p>...</p>
<pre><code>write

</code></pre>
<p>ocaml
let t =</p>
<pre><code class='large'>  expression&#39;&#39;
and u =
  </code></pre>
<p>other large
  expression&#39;&#39; in
let temp =
  f x y z t u in
...</p>
<pre><code>####  Naming anonymous functions:
In the case of an iterator whose argument is a complex function, define
the function by a `let` binding as well. In place of

</code></pre>
<p>ocaml
List.map
  (function x -&gt;</p>
<pre><code>blabla
blabla
blabla)</code></pre>
<p>  l</p>
<pre><code>write

</code></pre>
<p>ocaml
let f x =
  blabla
  blabla
  blabla in
List.map f l</p>
<pre><code>&gt; 
&gt; **Justification**: Much clearer, in particular if the name given to
&gt; the function is meaningful.
&gt; 

###  How to indent operations
When an operator takes complex arguments, or in the presence of multiple
calls to the same operator, start the next the line with the operator,
and don&#39;t indent the rest of the operation. For example:

</code></pre>
<p>ocaml
x + y + z</p>
<ul>
 <li>t + u
<pre><code>&gt; 
&gt; **Justification**: When the operator starts the line, it is clear that
&gt; the operation continues on this line.
&gt; </code></pre>
 </li>
</ul>

<p>In the case of a</p>
<pre><code>large expression&#39;&#39; in such an operation sequence,
to define the </code></pre>
<p>large expression&#39;&#39; with the help of a <code>let in</code>
construction is preferable to having to indent the line. In place of</p>
<pre><code class='ocaml'>x <span class='o'>+</span> y <span class='o'>+</span> z
<span class='o'>+</span> ``large
  expression''
<a href="javascript:octry('x + y + z\n+ ``large\n  expression&#39;&#39;\n');">[try]</a></code></pre>
<p>
write</p>
<pre><code class='ocaml'><span class='k'>let</span> t <span class='k'>=</span>
  ``large
   expression'' <span class='k'>in</span>
x <span class='o'>+</span> y <span class='o'>+</span> z <span class='o'>+</span> t
<a href="javascript:octry('let t =\n  ``large\n   expression&#39;&#39; in\nx + y + z + t\n');">[try]</a></code></pre>
<p>
You most certainly must bind those expressions too large to be written
in one operation in the case of a combination of operators. In place of
the unreadable expression</p>
<pre><code class='ocaml'>(x <span class='o'>+</span> y <span class='o'>+</span> z <span class='o'>*</span> t)
<span class='o'>/</span> (``large
    expression'')
<a href="javascript:octry('(x + y + z * t)\n/ (``large\n    expression&#39;&#39;)\n');">[try]</a></code></pre>
<p>
write</p>
<pre><code class='ocaml'><span class='k'>let</span> u <span class='k'>=</span>
  ``large
  expression'' <span class='k'>in</span>
(x <span class='o'>+</span> y <span class='o'>+</span> z <span class='o'>*</span> t) <span class='o'>/</span> u
<a href="javascript:octry('let u =\n  ``large\n  expression&#39;&#39; in\n(x + y + z * t) / u\n');">[try]</a></code></pre>
<p>
These guidelines extend to all operators. For example:</p>
<pre><code class='ocaml'><span class='k'>let</span> u <span class='k'>=</span>
  ``large
  expression'' <span class='k'>in</span>
x <span class='o'>::</span> y
<span class='o'>::</span> z <span class='o'>+</span> 1 <span class='o'>::</span> t <span class='o'>::</span> u
<a href="javascript:octry('let u =\n  ``large\n  expression&#39;&#39; in\nx :: y\n:: z + 1 :: t :: u\n');">[try]</a></code></pre>
<h2 id="Programmingguidelines"> Programming guidelines</h2>
<h3 id="Howtoprogram"> How to program</h3><blockquote>
<p><em>Always put your handiwork back on the bench,<br />
 and then polish it and re-polish it.</em></p>
</blockquote>
<h4 id="Writesimpleandclearprograms"> Write simple and clear programs</h4><p>
When this is done, reread, simplify and clarify. At every stage of
creation, use your head!</p>
<h4 id="Subdivideyourprogramsintolittlefunctions"> Subdivide your programs into little functions</h4><p>
Small functions are easier to master.</p>
<h4 id="Factoroutsnippetsofrepeatedcodebydefiningtheminseparatefunctions"> Factor out snippets of repeated code by defining them in separate functions</h4><p>
The sharing of code obtained in this way facilitates maintenance since
every correction or improvement automatically spreads throughout the
program. Besides, the simple act of isolating and naming a snippet of
code sometimes lets you identify an unsuspected feature.</p>
<h4 id="Nevercopypastecodewhenprogramming"> Never copy-paste code when programming</h4><p>
Pasting code almost surely indicates introducing a default of code
sharing and neglecting to identify and write a useful auxiliary
function; hence, it means that some code sharing is lost in the program.
Loosing code sharing implies that you will have more problems afterwards
for maintenance: a bug in the pasted code has to be corrected at each
occurrence of the bug in each copy of the code!</p>
<p>Moreover, it is difficult to identify that the same set of 10 lines of
code is repeated 20 times throughout the program. By contrast, if an
auxiliary function defines those 10 lines, it is fairly easy to see and
find where those lines are used: that&#39;s simply where the function is
called. If code is copy-pasted all over the place then the program is
more difficult to understand.</p>
<p>In conclusion, copy-pasting code leads to programs that are more
difficult to read and more difficult to maintain: it has to be banished.</p>
<h3 id="Howtocommentprograms"> How to comment programs</h3><h4 id="Don39thesitatetocommentwhenthere39sadifficulty"> Don&#39;t hesitate to comment when there&#39;s a difficulty</h4>
<h4 id="Ifthere39snodifficultythere39snopointincommenting"> If there&#39;s no difficulty, there&#39;s no point in commenting</h4><h4 id="Avoidcommentsinthebodiesoffunctions"> Avoid comments in the bodies of functions</h4>
<h4 id="Preferonecommentatthebeginningofthefunction"> Prefer one comment at the beginning of the function...</h4><p>
...which explains how the algorithm that is used works. Once more, if
there is no difficulty, there is no point in commenting.</p>
<h4 id="Avoidnocuouscomments"> Avoid nocuous comments</h4><p>
A <em>nocuous</em> comment is a comment that does not add any value, i.e. no
non-trivial information. The nocuous comment is evidently not of
interest; it is a nuisance since it uselessly distracts the reader. It
is often used to fulfill some strange criteria related to the so-called
<em>software metrology</em>, for instance the ratio <em>number of comments</em> /
<em>number of lines of code</em> that perfectly measures a ratio that I don&#39;t
know the theoretical or practical interpretation. Absolutely avoid
nocuous comments.</p>
<p>An example of what to avoid: the following comment uses technical words
and is thus masquerade into a real comment when it has no additional
information of interest;</p>
<pre><code class='ocaml'><span class='com2'>(*</span>
<span class='com2'>  Function print_lambda<span class='ic'>:</span></span>
<span class='com2'>  print a lambda<span class='ic'>-</span>expression given <span class='ic'>as</span> argument<span class='ic'>.</span></span>
<span class='com2'></span>
<span class='com2'>  Arguments<span class='ic'>:</span> lam<span class='ic'>,</span> any lambda<span class='ic'>-</span>expression<span class='ic'>.</span></span>
<span class='com2'>  Returns<span class='ic'>:</span> nothing<span class='ic'>.</span></span>
<span class='com2'></span>
<span class='com2'>  Remark<span class='ic'>:</span> print_lambda can only be used <span class='ic'>for</span> its side effect<span class='ic'>.</span></span>
<span class='com2'>*)</span><!-- end comment -->
<span class='k'>let rec</span> print_lambda lam <span class='k'>=</span>
  <span class='k'>match</span> lam <span class='k'>with</span>
  <span class='o'>|</span> Var s <span class='k'>-></span> printf <span class='s'>&#34;%s&#34;</span> s
  <span class='o'>|</span> Abs l <span class='k'>-></span> printf <span class='s'>&#34;\\ %a&#34;</span> print_lambda l
  <span class='o'>|</span> App (l1<span class='o'>,</span> l2) <span class='k'>-></span>
     printf <span class='s'>&#34;(%a %a)&#34;</span> print_lambda l1 print_lambda l2
<a href="javascript:octry('(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -&#62; printf &#34;%s&#34; s\n  | Abs l -&#62; printf &#34;\\ %a&#34; print_lambda l\n  | App (l1, l2) -&#62;\n     printf &#34;(%a %a)&#34; print_lambda l1 print_lambda l2\n');">[try]</a></code></pre>
<h4 id="Usageinmoduleinterface"> Usage in module interface</h4><p>

The function&#39;s usage must appear in the interface of the module which
exports it, not in the program which implements it. Choose comments as
in the OCaml system&#39;s interface modules, which will subsequently allow
the documentation of the interface module to be extracted automatically
if need be.</p>
<h4 id="Useassertions"> Use assertions</h4><p>
Use assertions as much as possible: they let you avoid verbose comments,
while allowing a useful verification upon execution.</p>
<p>For example, the conditions for the arguments of a function to be valid
are usefully verified by assertions.</p>
<pre><code class='ocaml'><span class='k'>let</span> f x <span class='k'>=</span>
  <span class='k'>assert</span> (x <span class='o'>&#62;=</span> 0)<span class='o'>;</span>
  <span class='o'>...</span>
<a href="javascript:octry('let f x =\n  assert (x &#62;= 0);\n  ...\n');">[try]</a></code></pre>
<p>
Note as well that an assertion is often preferable to a comment because
it&#39;s more trustworthy: an assertion is forced to be pertinent because it
is verified upon each execution, while a comment can quickly become
obsolete and then becomes actually detrimental to the comprehension of
the program.</p>
<h4 id="Commentslinebylineinimperativecode"> Comments line by line in imperative code</h4><p>
When writing difficult code, and particularly in case of highly
imperative code with a lot of memory modifications (physical mutations
in data structures), it is sometime mandatory to comment inside the body
of functions to explain the implementation of the algorithm encoded
here, or to follow successive modifications of invariants that the
function must maintain. Once more, if there is some difficulty
commenting is mandatory, for each program line if necessary.</p>
<h3 id="Howtochooseidentifiers"> How to choose identifiers</h3><p>
It&#39;s hard to choose identifiers whose name evokes the meaning of the
corresponding portion of the program. This is why you must devote
particular care to this, emphasizing clarity and regularity of
nomenclature.</p>
<h4 id="Don39tuseabbreviationsforglobalnames"> Don&#39;t use abbreviations for global names</h4><p>
Global identifiers (including especially the names of functions) can be
long, because it&#39;s important to understand what purpose they serve far
from their definition.</p>
<h4 id="SeparatewordsbyunderscoresintofstringnotintOfString"> Separate words by underscores: (<code>int_of_string</code>, not <code>intOfString</code>)</h4><p>
Case modifications are meaningful in OCaml: in effect capitalized words
are reserved for constructors and module names in OCaml; in contrast
regular variables (functions or identifiers) must start by a lowercase
letter. Those rules prevent proper usage of case modification for words
separation in identifiers: the first word starts the identifier, hence
it must be lower case and it is forbidden to choose <code>IntOfString</code> as the
name of a function.</p>
<h4 id="Alwaysgivethesamenametofunctionargumentswhichhavethesamemeaning"> Always give the same name to function arguments which have the same meaning</h4><p>
If necessary, make this nomenclature explicit in a comment at the top of
the file); if there are several arguments with the same meaning then
attach numeral suffixes to them.</p>
<h4 id="Localidentifierscanbebriefandshouldbereusedfromonefunctiontoanother"> Local identifiers can be brief, and should be reused from one function to another</h4><p>
This augments regularity of style. Avoid using identifiers whose
appearance can lead to confusion such as <code>l</code> or <code>O</code>, easy to confuse
with <code>1</code> and <code>0</code>.</p>
<p>Example:</p>
<pre><code class='ocaml'><span class='k'>let</span> add_expression expr1 expr2 <span class='k'>=</span> <span class='o'>...</span>
<span class='k'>let</span> print_expression expr <span class='k'>=</span> <span class='o'>...</span>
<a href="javascript:octry('let add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n');">[try]</a></code></pre>
<p>
An exception to the recommendation not to use capitalization to separate
words within identifiers is tolerated in the case of interfacing with
existing libraries which use this naming convention: this lets OCaml
users of the library to orient themselves in the original library
documentation more easily.</p>
<h3 id="Whentouseparentheseswithinanexpression"> When to use parentheses within an expression</h3><p>
Parentheses are meaningful: they indicate the necessity of using an
unusual precedence. So they should be used wisely and not sprinkled
randomly throughout programs. To this end, you should know the usual
precedences, that is, the combinations of operations which do not
require parentheses. Quite fortunately this is not complicated if you
know a little mathematics or strive to follow the following rules:</p>
<h4 id="Arithmeticoperatorsthesamerulesasinmathematics"> Arithmetic operators: the same rules as in mathematics</h4><p>
For example: <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>.</p>
<h4 id="Functionapplicationthesamerulesasthoseinmathematicsforusageoftrigonometricfunctions"> Function application: the same rules as those in mathematics for usage of <em>trigonometric functions</em></h4><p>
In mathematics you write <code>sin x</code> to mean <code>sin (x)</code>. In the same way
<code>sin x + cos x</code> means <code>(sin x) + (cos x)</code> not <code>sin (x + (cos x))</code>. Use
the same conventions in OCaml: write <code>f x + g x</code> to mean
<code>(f x) + (g x)</code>.<br />
This convention generalizes <strong>to all (infix) operators</strong>: <code>f x :: g x</code>
means <code>(f x) :: (g x)</code>, <code>f x @ g x</code> means <code>(f x) @ (g x)</code>, and
<code>failwith s ^ s&#39;</code> means <code>(failwith s) ^ s&#39;</code>, <em>not</em> <code>failwith (s ^ s&#39;)</code>.</p>
<h4 id="Comparisonsandbooleanoperators"> Comparisons and boolean operators</h4><p>
Comparisons are infix operators, so the preceding rules apply. This is
why <code>f x &lt; g x</code> means <code>(f x) &lt; (g x)</code>. For type reasons (no other
sensible interpretation) the expression <code>f x &lt; x + 2</code> means
<code>(f x) &lt; (x + 2)</code>. In the same way <code>f x &lt; x + 2 &amp;&amp; x &gt; 3</code> means
<code>((f x) &lt; (x + 2)) &amp;&amp; (x &gt; 3)</code>.</p>
<h4 id="Therelativeprecedencesofthebooleanoperatorsarethoseofmathematics"> The relative precedences of the boolean operators are those of mathematics</h4><p>
Although mathematicians have a tendency to overuse parens in this case,
the boolean <code>or&#39;&#39; operator is analogous to addition and the </code>and&#39;&#39;
to multiplication. So, just as <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>,
<code>true || false &amp;&amp; x</code> means <code>true || (false &amp;&amp; x)</code>.</p>
<h3 id="Howtodelimitconstructsinprograms"> How to delimit constructs in programs</h3><p>
When it is necessary to delimit syntactic constructs in programs, use as
delimiters the keywords <code>begin</code> and <code>end</code> rather than parentheses.
However using parentheses is acceptable if you do it in a consistent,
that is, systematic, way.</p>
<p>This explicit delimiting of constructs essentially concerns
pattern-matching constructs or sequences embedded within
<code>if then     else</code> constructs.</p>
<h4 id="matchconstructinamatchconstruct"> <code>match</code> construct in a <code>match</code> construct</h4><p>
When a <code>match ... with</code> or <code>try ... with</code> construct appears in a
pattern-matching clause, it is absolutely necessary to delimit this
embedded construct (otherwise subsequent clauses of the enclosing
pattern-matching construct will automatically be associated with the
enclosed pattern-matching construct). For example:</p>
<pre><code class='ocaml'><span class='k'>match</span> x <span class='k'>with</span>
<span class='o'>|</span> 1 <span class='k'>-></span>
  <span class='k'>begin</span> <span class='k'>match</span> y <span class='k'>with</span>
  <span class='o'>|</span> <span class='o'>...</span>
  <span class='k'>end</span>
<span class='o'>|</span> 2 <span class='k'>-></span>
<span class='o'>...</span>
<a href="javascript:octry('match x with\n| 1 -&#62;\n  begin match y with\n  | ...\n  end\n| 2 -&#62;\n...\n');">[try]</a></code></pre>
<h4 id="Sequencesinsidebranchesofif"> Sequences inside branches of <code>if</code></h4><p>

In the same way, a sequence which appears in the <code>then</code> or <code>else</code> part
of a conditional must be delimited:</p>
<pre><code class='ocaml'><span class='k'>if</span> cond <span class='k'>then</span> <span class='k'>begin</span>
  e1<span class='o'>;</span>
  e2
<span class='k'>end</span> <span class='k'>else</span> <span class='k'>begin</span>
  e3<span class='o'>;</span>
  e4
<span class='k'>end</span>
<a href="javascript:octry('if cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n');">[try]</a></code></pre>
<h3 id="Howtousemodules"> How to use modules</h3>
<h4 id="Subdividingintomodules"> Subdividing into modules</h4><p>
You must subdivide your programs into coherent modules.</p>
<p>For each module, you must explicitly write an interface.</p>
<p>For each interface, you must document the things defined by the module:
functions, types, exceptions, etc.</p>
<h4 id="Openingmodules"> Opening modules</h4><p>
Avoid <code>open</code> directives, using instead the qualified identifier
notation. Thus you will prefer short but meaningful module names.</p>
<blockquote>
<p><strong>Justification</strong>: The use of unqualified identifiers is ambiguous and
gives rise to difficult-to-detect semantic errors.</p>
</blockquote>
<pre><code class='ocaml'><span class='k'>let</span> lim <span class='k'>=</span> <span class='m'>String</span><span class='o'>.</span>length name <span class='o'>-</span> 1 <span class='k'>in</span>
<span class='o'>...</span>
<span class='k'>let</span> lim <span class='k'>=</span> <span class='m'>Array</span><span class='o'>.</span>length v <span class='o'>-</span> 1 <span class='k'>in</span>
<span class='o'>...</span>
<span class='o'>...</span> <span class='m'>List</span><span class='o'>.</span>map succ <span class='o'>...</span>
<span class='o'>...</span> <span class='m'>Array</span><span class='o'>.</span>map succ <span class='o'>...</span>
<a href="javascript:octry('let lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n');">[try]</a></code></pre>
<h4 id="Whentouseopenmodulesratherthanleavingthemclosed"> When to use open modules rather than leaving them closed</h4><p>

You can consider it normal to open a module which modifies the
environment, and brings other versions of an important set of functions.
For example, the <code>Format</code> module provides automatically indented
printing. This module redefines the usual printing functions
<code>print_string</code>, <code>print_int</code>, <code>print_float</code>, etc. So when you use
<code>Format</code>, open it systematically at the top of the file.<br />
If you don&#39;t open <code>Format</code> you could miss the qualification of a
printing function, and this could be perfectly silent, since many
<code>Format</code>&#39;s functions have a correspondent in the default environment
(<code>Pervasives</code>). Mixing printing functions from <code>Format</code> and <code>Pervasives</code>
leads to subtle bugs in the display, that are difficult to trace. For
instance:</p>
<pre><code class='ocaml'><span class='k'>let</span> f () <span class='k'>=</span>
  <span class='m'>Format</span><span class='o'>.</span>print_string <span class='s'>&#34;Hello World!&#34;</span><span class='o'>;</span> print_newline ()
<a href="javascript:octry('let f () =\n  Format.print_string &#34;Hello World!&#34;; print_newline ()\n');">[try]</a></code></pre>
<p>
is bogus since it does not call <code>Format.print_newline</code> to flush the
pretty-printer queue and output <code>&quot;Hello World!&quot;</code>. Instead
<code>&quot;Hello World!&quot;</code> is stuck into the pretty-printer queue, while
<code>Pervasives.print_newline</code> outputs a carriage return on the standard
output ... If <code>Format</code> is printing on a file and standard output is the
terminal, the user will have a bad time finding that a carriage return
is missing in the file (and the display of material on the file is
strange, since boxes that should be closed by <code>Format.print_newline</code> are
still open), while a spurious carriage return appeared on the screen!</p>
<p>For the same reason, open large libraries such as the one with
arbitrary-precision integers so as not to burden the program which uses
them.</p>
<pre><code class='ocaml'><span class='k'>open</span> Num

<span class='k'>let rec</span> fib n <span class='k'>=</span>
  <span class='k'>if</span> n <span class='o'>&#60;=</span> 2 <span class='k'>then</span> Int 1 <span class='k'>else</span> fib (n <span class='o'>-</span> 1) <span class='o'>+/</span> fib (n <span class='o'>-</span> 2)
<a href="javascript:octry('open Num\n\nlet rec fib n =\n  if n &#60;= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n');">[try]</a></code></pre>
<blockquote>
<p><strong>Justification</strong>: The program would be less readable if you had to
qualify all the identifiers.</p>
</blockquote>
<p>In a program where type definitions are shared, it is good to gather
these definitions into one or more module(s) without implementations
(containing only types). Then it&#39;s acceptable to systematically open the
module which exports the shared type definitions.</p>
<h3 id="Patternmatching"> Pattern-matching</h3><h4 id="Neverbeafraidofoverusingpatternmatching"> Never be afraid of over-using pattern-matching!</h4>
<h4 id="Ontheotherhandbecarefultoavoidnonexhaustivepatternmatchingconstructs"> On the other hand, be careful to avoid non-exhaustive pattern-matching constructs</h4><p>
Complete them with care, without using a “catch-all” clause such as
<code>| _ -&gt; ...</code> or <code>| x -&gt; ...</code> when it&#39;s possible to do without it (for
example when matching a concrete type defined within the program). See
also the next section: compiler warnings.</p>
<h3 id="Compilerwarnings"> Compiler warnings</h3><p>
Compiler warnings are meant to prevent potential errors; this is why you
absolutely must heed them and correct your programs if compiling them
produces such warnings. Besides, programs whose compilation produces
warnings have an odor of amateurism which certainly doesn&#39;t suit your
own work!</p>
<h4 id="Patternmatchingwarnings"> Pattern-matching warnings</h4><p>
Warnings about pattern-matching must be treated with the upmost care:</p>
<ul>
 <li>Those concerning useless clauses should of course be eliminated.</li>
</ul>

<ul>
 <li>For non-exhaustive pattern-matching you must complete the
 corresponding pattern-matching construct, without adding a default
 case <pre><code>catch-all&#39;&#39;, such as `| _ -&gt; ... `, but with an explicit
 list of the constructors not examined by the rest of the construct,
 for example `| Cn _ | Cn1 _ -&gt; ... `.</code></pre>
 </li>
</ul>

<blockquote>
<p><strong>Justification</strong>: It&#39;s not really any more complicated to write
it this way, and this allows the program to evolve more safely. In
effect the addition of a new constructor to the datatype being
matched will produce an alert anew, which will allow the
programmer to add a clause corresponding to the new constructor if
that is warranted. On the contrary, the</p>
<pre><code>catch-all&#39;&#39; clause
will make the function compile silently and it might be thought
that the function is correct as the new constructor will be
handled by the default case.
</code></pre>
</blockquote>
<ul>
 <li>Non-exhaustive pattern-matches induced by clauses with guards must
 also be corrected. A typical case consists in suppressing a
 redundant guard.</li>
</ul>

<h4 id="Destructuringletbindings"> De-structuring <code>let</code> bindings</h4><p>
[Translator&#39;s note: a</p>
<pre><code>de-structuring `let` binding&#39;&#39; is one which
binds several names to several expressions simultaneously. You pack all
the names you want bound into a collection such as a tuple or a list,
and you correspondingly pack all the expressions into a collective
expression. When the `let` binding is evaluated, it unpacks the
collections on both sides and binds each expression to its corresponding
name. For example, `let x, y = 1, 2` is a de-structuring `let` binding
which performs both the bindings `let x = 1` and `let y = 2`
simultaneously.]
The `let` binding is not limited to simple identifier definitions: you
can use it with more complex or simpler patterns. For instance

* `let` with complex patterns:
 `let [x; y] as l = ...`
 simultaneously defines a list `l` and its two elements `x` and `y`.
* `let` with simple pattern:
 `let _ = ...` does not define anything, it just evaluate the
 expression on the right hand side of the `=` symbol.

####  The de-structuring `let` must be exhaustive
Only use de-structuring `let` bindings in the case where the
pattern-matching is exhaustive (the pattern can never fail to match).
Typically, you will thus be limited to definitions of product types
(tuples or records) or definitions of variant type with a single case.
In any other case, you should use an explicit `match   ... with`
construct.

* `let ... in`: de-structuring `let` that give a warning must be
 replaced by an explicit pattern matching. For instance, instead of
 `let [x; y] as l = List.map succ     (l1 @ l2) in expression` write:

```ocaml
match List.map succ (l1 @ l2) with
| [x; y] as l -&gt; expression
| _ -&gt; assert false
```


* Global definition with de-structuring lets should be rewritten with
 explicit pattern matching and tuples:

```ocaml
let x, y, l =
  match List.map succ (l1 @ l2) with
  | [x; y] as l -&gt; x, y, l
  | _ -&gt; assert false
```


&gt; 
&gt; **Justification**: There is no way to make the pattern-matching
&gt; exhaustive if you use general de-structuring `let` bindings.
&gt; 

####  Sequence warnings and `let _ = ...`
When the compiler emits a warning about the type of an expression in a
sequence, you have to explicitly indicate that you want to ignore the
result of this expression. To this end:

* use a vacuous binding and suppress the sequence warning of

```ocaml
List.map f l;
print_newline ()
```
write

```ocaml
let _ = List.map f l in
print_newline ()
```


* you can also use the predefined function `ignore : &#39;a     -&gt; unit`
 that ignores its argument to return `unit`.

```ocaml
ignore (List.map f l);
print_newline ()
```


* In any case, the best way to suppress this warning is to understand
 why it is emitted by the compiler: the compiler warns you because
 your code computes a result that is useless since this result is
 just deleted after computation. Hence, if useful at all, this
 computation is performed only for its side-effects; hence it should
 return unit.
 Most of the time, the warning indicates the use of the wrong
 function, a probable confusion between the side-effect only version
 of a function (which is a procedure whose result is irrelevant) with
 its functional counterpart (whose result is meaningful).
 In the example mentioned above, the first situation prevailed, and
 the programmer should have called `iter` instead of `map`, and
 simply write

```ocaml
List.iter f l;
print_newline ()
```
In actual programs, the suitable (side-effect only) function may not
exist and has to be written: very often, a careful separation of the
procedural part from the functional part of the function at hand
elegantly solves the problem, and the resulting program just looks
better afterwards! For instance, you would turn the problematic
definition:

```ocaml
let add x y =
  if x &gt; 1 then print_int x;
  print_newline ();
  x + y;;
```
into the clearer separate definitions and change old calls to `add`
accordingly.



In any case, use the `let _ = ...` construction exactly in those cases
where you want to ignore a result. Don&#39;t systematically replace
sequences with this construction.

&gt; 
&gt; **Justification**: Sequences are much clearer! Compare `e1; e2; e3` to
&gt; 
&gt; ```ocaml
&gt; let _ = e1 in
&gt; let _ = e2 in
&gt; e3
&gt; ```

###  The `hd` and `tl` functions
Don&#39;t use the `hd` and `tl` functions, but pattern-match the list
argument explicitly.

&gt; 
&gt; **Justification**: This is just as brief as and much clearer than
&gt; using `hd` and `tl` which must of necessity be protected by
&gt; `try... with...` to catch the exception which might be raised by these
&gt; functions.
&gt; 

###  Loops
####  `for` loops
To simply traverse an array or a string, use a `for` loop.

```ocaml
for i = 0 to Array.length v - 1 do
  ...
done
```
If the loop is complex or returns a result, use a recursive function.

```ocaml
let find_index e v =
  let rec loop i =
    if i &gt;= Array.length v then raise Not_found else
    if v.(i) = e then i else loop (i + 1) in
  loop 0;;
```
&gt; 
&gt; **Justification**: The recursive function lets you code any loop
&gt; whatsoever simply, even a complex one, for example with multiple exit
&gt; points or with strange index steps (steps depending on a data value
&gt; for example).
&gt; 
&gt; Besides, the recursive loop avoids the use of mutables whose value can
&gt; be modified in any part of the body of the loop whatsoever (or even
&gt; outside): on the contrary the recursive loop explicitly takes as
&gt; arguments the values susceptible to change during the recursive calls.
&gt; 

####  `while` loops
&gt; 
&gt; **While loops law**: Beware: usually a while loop is wrong, unless its
&gt; loop invariant has been explicitly written.
&gt; 

The main use of the `while` loop is the infinite loop
`while true do     ...`. You get out of it through an exception,
generally on termination of the program.

Other `while` loops are hard to use, unless they come from canned
programs from algorithms courses where they were proved.

&gt; 
&gt; **Justification**: `while` loops require one or more mutables in order
&gt; that the loop condition change value and the loop finally terminate.
&gt; To prove their correctness, you must therefore discover the loop
&gt; invariants, an interesting but difficult sport.
&gt; 

###  Exceptions
Don&#39;t be afraid to define your own exceptions in your programs, but on
the other hand use as much as possible the exceptions predefined by the
system. For example every search function which fails should raise the
predefined exception `Not_found`. Be careful to handle the exceptions
which may be raised by a function call with the help of a
`try ... with`.

Handling all exceptions by `try     ... with _ -&gt;` is usually reserved
for the main function of the program. If you need to catch all
exceptions to maintain an invariant of an algorithm, be careful to name
the exception and re-raise it, after having reset the invariant.
Typically:

```ocaml
let ic = open_in ...
and oc = open_out ... in
try
  treatment ic oc;
  close_in ic; close_out oc
with x -&gt; close_in ic; close_out oc; raise x
```
&gt; 
&gt; **Justification**: `try ... with _     -&gt;` silently catches all
&gt; exceptions, even those which have nothing to do with the computation
&gt; at hand (for example an interruption will be captured and the
&gt; computation will continue anyway!).
&gt; 

###  Data structures
One of the great strengths of OCaml is the power of the data structures
which can be defined and the simplicity of manipulating them. So you
must take advantage of this to the fullest extent; don&#39;t hesitate to
define your own data structures. In particular, don&#39;t systematically
represent enumerations by whole numbers, nor enumerations with two cases
by booleans. Examples:

```ocaml
type figure =
   | Triangle | Square | Circle | Parallelogram
type convexity =
   | Convex | Concave | Other
type type_of_definition =
   | Recursive | Non_recursive
```
&gt; 
&gt; **Justification**: A boolean value often prevents intuitive
&gt; understanding of the corresponding code. For example, if
&gt; `type_of_definition` is coded by a boolean, what does `true` signify?
&gt; A “normal” definition (that is, non-recursive) or a recursive
&gt; definition?
&gt; 
&gt; In the case of an enumerated type encode by an integer, it is very
&gt; difficult to limit the range of acceptable integers: one must define
&gt; construction functions that will ensure the mandatory invariants of
&gt; the program (and verify afterwards that no values has been built
&gt; directly), or add assertions in the program and guards in pattern
&gt; matchings. This is not good practice, when the definition of a sum
&gt; type elegantly solves this problem, with the additional benefit of
&gt; firing the full power of pattern matching and compiler&#39;s verifications
&gt; of exhaustiveness.
&gt; 
&gt; **Criticism**: For binary enumerations, one can systematically define
&gt; predicates whose names carry the semantics of the boolean that
&gt; implements the type. For instance, we can adopt the convention that a
&gt; predicate ends by the letter `p`. Then, in place of defining a new sum
&gt; type for `type_of_definition`, we will use a predicate function
&gt; `recursivep` that returns true if the definition is recursive.
&gt; 
&gt; **Answer**: This method is specific to binary enumeration and cannot
&gt; be easily extended; moreover it is not well suited to pattern
&gt; matching. For instance, for definitions encoded by
&gt; `| Let of bool * string * expression` a typical pattern matching would
&gt; look like:
&gt; 
&gt; ```ocaml
&gt; | Let (_, v, e) as def -&gt;
&gt;    if recursivep def then code_for_recursive_case
&gt;    else code_for_non_recursive_case
&gt; ```
&gt; 
&gt; or, if `recursivep` can be applied to booleans:
&gt; 
&gt; ```ocaml
&gt; | Let (b, v, e) -&gt;
&gt;    if recursivep def then code_for_recursive_case
&gt;    else code_for_non_recursive_case
&gt; ```
&gt; 
&gt; contrast with an explicit encoding:
&gt; 
&gt; ```ocaml
&gt; | Let (Recursive, v, e) -&gt; code_for_recursive_case
&gt; | Let (Non_recursive, v, e) -&gt; code_for_non_recursive_case
&gt; ```
&gt; 
&gt; The difference between the two programs is subtle and you may think
&gt; that this is just a matter of taste; however the explicit encoding is
&gt; definitively more robust to modifications and fits better with the
&gt; language.
&gt; 

*A contrario*, it is not necessary to systematically define new types
for boolean flags, when the interpretation of constructors `true` and
`false` is clear. The usefulness of the definition of the following
types is then questionable:

```ocaml
type switch = On | Off
type bit = One | Zero
```
The same objection is admissible for enumerated types represented as
integers, when those integers have an evident interpretation with
respect to the data to be represented.

###  When to use mutables
Mutable values are useful and sometimes indispensable to simple and
clear programming. Nevertheless, you must use them with discernment:
OCaml&#39;s normal data structures are immutable. They are to be preferred
for the clarity and safety of programming which they allow.

###  Iterators
OCaml&#39;s iterators are a powerful and useful feature. However you should
not overuse them, nor *a contrario* neglect them: they are provided to
you by libraries and have every chance of being correct and
well-thought-out by the author of the library. So it&#39;s useless to
reinvent them.

So write

```ocaml
let square_elements elements = List.map carre elements
```
rather than:

```ocaml
let rec square_elements = function
  | [] -&gt; []
  | elem :: elements -&gt; square elem :: square_elements elements
```
On the other hand avoid writing:

```ocaml
let iterator f x l =
  List.fold_right (List.fold_left f) [List.map x l] l
```
even though you get:

```ocaml
  let iterator f x l =
    List.fold_right (List.fold_left f) [List.map x l] l;;
  iterator (fun l x -&gt; x :: l) (fun l -&gt; List.rev l) [[1; 2; 3]]
```
In case of express need, you must be careful to add an explanatory
comment: in my opinion it&#39;s absolutely necessary!

###  How to optimize programs
&gt; 
&gt; **Pseudo law of optimization**: No optimization *a priori*.
&gt;  No optimization *a posteriori* either.
&gt; 

Above all program simply and clearly. Don&#39;t start optimizing until the
program bottleneck has been identified (in general a few routines). Then
optimization consists above all of changing *the complexity* of the
algorithm used. This often happens through redefining the data
structures being manipulated and completely rewriting the part of the
program which poses a problem.

&gt; 
&gt; **Justification**: Clarity and correctness of programs take
&gt; precedence. Besides, in a substantial program, it is practically
&gt; impossible to identify *a priori* the parts of the program whose
&gt; efficiency is of prime importance.
&gt; 

###  How to choose between classes and modules
You should use OCaml classes when you need inheritance, that is,
incremental refinement of data and their functionality.

You should use conventional data structures (in particular, variant
types) when you need pattern-matching.

You should modules when the data structures are fixed and their
functionality is equally fixed or it&#39;s enough to add new functions in
the programs which use them.

###  Clarity of OCaml code
The OCaml language includes powerful constructs which allow simple and
clear programming. The main problem to obtain crystal clear programs it
to use them appropriately.

The language features numerous programming styles (or programming
paradigms): imperative programming (based on the notion of state and
assignment), functional programming (based on the notion of function,
function results, and calculus), object oriented programming (based of
the notion of objects encapsulating a state and some procedures or
methods that can modify the state). The first work of the programmer is
to choose the programming paradigm that fits the best the problem at
hand. When using one of those programming paradigms, the difficulty is
to use the language construct that expresses in the most natural and
easiest way the computation that implements the algorithm.

####  Style dangers
Concerning programming styles, one can usually observe the two
symmetrical problematic behaviors: on the one hand, the </code></pre>
<p>all
imperative&#39;&#39; way (<em>systematic</em> usage of loops and assignment), and on
the other hand the</p>
<pre><code>purely functional&#39;&#39; way (*never* use loops nor
assignments); the </code></pre>
<p>100% object&#39;&#39; style will certainly appear in the
next future, but (fortunately) it is too new to be discussed here.</p>
<ul>
 <li><strong>The <code>Too much imperative&#39;&#39; danger</code></strong>:
  <ul>
   <li>It is a bad idea to use imperative style to code a function that
 is <em>naturally</em> recursive. For instance, to compute the length of
 a list, you should not write:</li>
  </ul>
 </li>
</ul>

<pre><code class='ocaml'><span class='k'>let</span> list_length l <span class='k'>=</span>
  <span class='k'>let</span> l <span class='k'>=</span> ref l <span class='k'>in</span>
  <span class='k'>let</span> res <span class='k'>=</span> ref 0 <span class='k'>in</span>
  <span class='k'>while</span> <span class='o'>!</span>l <span class='o'>&#60;&#62;</span> <span class='o'>[</span><span class='o'>]</span> <span class='k'>do</span>
    incr res<span class='o'>;</span> l <span class='o'>:=</span> <span class='m'>List</span><span class='o'>.</span>tl <span class='o'>!</span>l
  <span class='k'>done</span><span class='o'>;</span>
  <span class='o'>!</span>res<span class='o'>;;</span>
<a href="javascript:octry('let list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l &#60;&#62; [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n');">[try]</a></code></pre>
<p>
in place of the following recursive function, so simple and
clear:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> list_length <span class='k'>=</span> <span class='k'>function</span>
  <span class='o'>|</span> <span class='o'>[</span><span class='o'>]</span> <span class='k'>-></span> 0
  <span class='o'>|</span> <span class='o'>_</span> <span class='o'>::</span> l <span class='k'>-></span> 1 <span class='o'>+</span> list_length l
<a href="javascript:octry('let rec list_length = function\n  | [] -&#62; 0\n  | _ :: l -&#62; 1 + list_length l\n');">[try]</a></code></pre>
<p>
(For those that would contest the equivalence of those two
versions, see the <a href='#equivalenceprogrammes'>note below</a>).</p>
<pre><code class='ocaml'><span class='o'>-</span>   Another common “over imperative error” <span class='k'>in</span> the imperative world
    is not <span class='k'>to</span> systematically choose the simple `<span class='k'>for</span>` loop <span class='k'>to</span> iter on
    the element <span class='k'>of</span> a vector<span class='o'>,</span> but instead <span class='k'>to</span> use a complex `<span class='k'>while</span>`
    loop<span class='o'>,</span> <span class='k'>with</span> one <span class='k'>or</span> two references (too many useless assignments<span class='o'>,</span>
    too many opportunity <span class='k'>for</span> errors)<span class='o'>.</span>
<span class='o'>-</span>   This category <span class='k'>of</span> programmer consider that the `<span class='k'>mutable</span>` keyword
    <span class='k'>in</span> the record <span class='k'>type</span> definitions should be implicit<span class='o'>.</span>
<a href="javascript:octry('-   Another common “over imperative error” in the imperative world\n    is not to systematically choose the simple `for` loop to iter on\n    the element of a vector, but instead to use a complex `while`\n    loop, with one or two references (too many useless assignments,\n    too many opportunity for errors).\n-   This category of programmer consider that the `mutable` keyword\n    in the record type definitions should be implicit.\n');">[try]</a></code></pre>
<ul>
 <li><strong>The “Too much functional” danger</strong>:
  <ul>
   <li>The programmer that suffers from this disease carefully avoids
 to use arrays and assignment. In the most severe forms, one
 observe a complete denial of writing any imperative
 construction, even in case it is evidently the most elegant way
 to solve the problem.
   </li>
   <li>Characteristic symptoms: systematic rewriting of <code>for</code> loops
 with recursive functions, usage of lists in contexts where
 imperative data structures seem to be mandatory to anyone,
 passing numerous global parameters of the problem to every
 functions, even if a global reference would be perfect to avoid
 these spurious parameters that are mainly invariants that must
 be passed all over the place.
   </li>
   <li>This programmer think that the <code>mutable</code> keyword in the record
 types definitions should be suppressed from the language.</li>
  </ul>
 </li>
</ul>

<h4 id="OCamlcodegenerallyconsideredunreadable"> OCaml code generally considered unreadable</h4><p>
The OCaml language includes powerful constructs which allow simple and
clear programming. However the power of these constructs also lets you
write uselessly complicated code, to the point where you get a perfectly
unreadable program.</p>
<p>Here are a number of known ways:</p>
<ul>
 <li>Use useless (hence nocive for readability) <code>if then else</code>, as in</li>
</ul>

<pre><code class='ocaml'><span class='k'>let</span> flush_ps () <span class='k'>=</span>
  <span class='k'>if</span> not <span class='o'>!</span>psused <span class='k'>then</span> psused <span class='o'>:=</span> <span class='o'>true</span>
<a href="javascript:octry('let flush_ps () =\n  if not !psused then psused := true\n');">[try]</a></code></pre>
<p>
or (more subtle)</p>
<pre><code class='ocaml'><span class='k'>let</span> sync b <span class='k'>=</span>
  <span class='k'>if</span> <span class='o'>!</span>last_is_dvi <span class='o'>&#60;&#62;</span> b <span class='k'>then</span> last_is_dvi <span class='o'>:=</span> b
<a href="javascript:octry('let sync b =\n  if !last_is_dvi &#60;&#62; b then last_is_dvi := b\n');">[try]</a></code></pre>
<ul>
 <li>Code one construct with another. For example code a <code>let ... in</code> by
 the application of an anonymous function to an argument. You would
 write<br /></li>
</ul>

<pre><code class='ocaml'>(<span class='k'>fun</span> x y <span class='k'>-></span> x <span class='o'>+</span> y)
   e1 e2
<a href="javascript:octry('(fun x y -&#62; x + y)\n   e1 e2\n');">[try]</a></code></pre>
<p>
instead of simply writing</p>
<pre><code class='ocaml'><span class='k'>let</span> x <span class='k'>=</span> e1
<span class='k'>and</span> y <span class='k'>=</span> e2 <span class='k'>in</span>
x <span class='o'>+</span> y
<a href="javascript:octry('let x = e1\nand y = e2 in\nx + y\n');">[try]</a></code></pre>
<ul>
 <li>Systematically code sequences with <code>let in</code> bindings.</li>
</ul>

<ul>
 <li>Mix computations and side effects, particularly in function calls.
 Recall that the order of evaluation of arguments in a function call
 is unspecified, which implies that you must not mix side effects and
 computations in function calls. However, when there is only one
 argument you might take advantage of this to perform a side effect
 within the argument, which is extremely troublesome for the reader
 albeit without danger to the program semantics. To be absolutely
 forbidden.</li>
</ul>

<ul>
 <li>Misuse of iterators and higher-order functions (i.e. overuse or
 under-use them). For example it&#39;s better to use <code>List.map</code> or
 <code>List.iter</code> than to write their equivalents in-line using specific
 recursive functions of your own. Even worse, you don&#39;t use
 <code>List.map</code> or <code>List.iter</code> but write their equivalents in terms of
 <code>List.fold_right</code> and <code>List.fold_left</code>.</li>
</ul>

<ul>
 <li>Another efficient way to write unreadable code is to mix all or some
 of these methods. For example:</li>
</ul>

<pre><code class='ocaml'>(<span class='k'>fun</span> u <span class='k'>-></span> print_string <span class='s'>&#34;world&#34;</span><span class='o'>;</span> print_string u)
  (<span class='k'>let</span> temp <span class='k'>=</span> print_string <span class='s'>&#34;Hello&#34;</span><span class='o'>;</span> <span class='s'>&#34;!&#34;</span> <span class='k'>in</span>
   ((<span class='k'>fun</span> x <span class='k'>-></span> print_string x<span class='o'>;</span> flush stdout) <span class='s'>&#34; &#34;</span><span class='o'>;</span>
    temp))<span class='o'>;;</span>
<a href="javascript:octry('(fun u -&#62; print_string &#34;world&#34;; print_string u)\n  (let temp = print_string &#34;Hello&#34;; &#34;!&#34; in\n   ((fun x -&#62; print_string x; flush stdout) &#34; &#34;;\n    temp));;\n');">[try]</a></code></pre>
<p>If you naturally write the program <code>print_string &quot;Hello world!&quot;</code> in this
way, you can without a doubt submit your work to the <a href='mailto:Pierre.Weis@inria.fr'>Obfuscated OCaml
Contest</a>.</p>
<h2 id="Managingprogramdevelopment"> Managing program development</h2><p>
We give here tips from veteran OCaml programmers, which have served in
developing the compilers which are good examples of large complex
programs developed by small teams.</p>
<h3 id="Howtoeditprograms"> How to edit programs</h3><p>
Many developers nurture a kind of veneration towards the Emacs editor
(gnu-emacs in general) which they use to write their programs. The
editor interfaces well with the language since it is capable of syntax
coloring OCaml source code (rendering different categories of words in
color, coloring keywords for example).</p>
<p>The following two commands are considered indispensable:</p>
<ul>
 <li><code>CTRL-C-CTRL-C</code> or <code>Meta-X compile</code>: launches re-compilation from
 within the editor (using the <code>make</code> command).
 </li>
 <li><code> CTRL-X-` </code>: puts the cursor in the file and at the exact place
 where the OCaml compiler has signaled an error.</li>
</ul>

<p>Developers describe thus how to use these features: <code>CTRL-C-CTRL-C</code>
combination recompiles the whole application; in case of errors, a
succession of <code> CTRL-X-` </code> commands permits correction of all the
errors signaled; the cycle begins again with a new re-compilation
launched by <code>CTRL-C-CTRL-C</code>.</p>
<h4 id="Otheremacstricks"> Other emacs tricks</h4><p>
The <code>ESC-/</code> command (dynamic-abbrev-expand) automatically completes the
word in front of the cursor with one of the words present in one of the
files being edited. Thus this lets you always choose meaningful
identifiers without the tedium of having to type extended names in your
programs: the <code>ESC-/</code> easily completes the identifier after typing the
first letters. In case it brings up the wrong completion, each
subsequent <code>ESC-/</code> proposes an alternate completion.</p>
<p>Under Unix, the <code>CTRL-C-CTRL-C</code> or <code>Meta-X     compile</code> combination,
followed by <code> CTRL-X-` </code> is also used to find all occurrences of a
certain string in a OCaml program. Instead of launching <code>make</code> to
recompile, you launch the <code>grep</code> command; then all the</p>
<pre><code class='error'>messages&#39;&#39; from `grep` are compatible with the </code></pre>
<p> CTRL-X-</p>
<pre><code> `` usage
which automatically takes you to the file and the place where the string
is found.

###  How to edit with the interactive system
Under Unix: use the line editor </code></pre>
<p>ledit</p>
<pre><code> which offers great editing
capabilities ``à la emacs&#39;&#39; (including </code></pre>
<p>ESC-/</p>
<pre><code>!), as well as a history
mechanism which lets you retrieve previously typed commands and even
retrieve commands from one session in another. </code></pre>
<p>ledit</p>
<pre><code> is written in
OCaml and can be freely down-loaded
[here](ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz).

###  How to compile
The </code></pre>
<p>make</p>
<pre><code> utility is indispensable for managing the compilation and
re-compilation of programs. Sample </code></pre>
<p>make</p>
<pre><code> files can be found on [The
Hump](http://caml.inria.fr//cgi-bin/hump.en.cgi). You can also consult
the </code></pre>
<p>Makefiles</p>
<pre><code> for the OCaml compilers.

###  How to develop as a team: version control
Users of the [Git](http://git-scm.com/) software version control system
are never run out of good things to say about the productivity gains it
brings. This system supports managing development by a team of
programmers while imposing consistency among them, and also maintains a
log of changes made to the software.
 Git also supports simultaneous development by several teams, possibly
dispersed among several sites linked on the Net.

An anonymous Git read-only mirror [contains the working sources of the
OCaml compilers](https://github.com/ocaml/ocaml), and the sources of
other software related to OCaml.

###  Notes
####  Imperative and functional versions of </code></pre>
<p>list_length</p>
<pre><code>The two versions of </code></pre>
<p>list_length</p>
<pre><code> are not completely equivalent in term
of complexity, since the imperative version uses a constant amount of
stack room to execute, whereas the functional version needs to store
return addresses of suspended recursive calls (whose maximum number is
equal to the length of the list argument). If you want to retrieve a
constant space requirement to run the functional program you just have
to write a function that is recursive in its tail (or *tail-rec*), that
is a function that just ends by a recursive call (which is not the case
here since a call to </code></pre>
<p>+</p>
<pre><code> has to be perform after the recursive call has
returned). Just use an accumulator for intermediate results, as in:

```ocaml
let list_length l =
  let rec loop accu = function
    | [] -&gt; accu
    | _ :: l -&gt; loop (accu + 1) l in
  loop 0 l
```
This way, you get a program that has the same computational properties
as the imperative program with the additional clarity and natural
looking of an algorithm that performs pattern matching and recursive
calls to handle an argument that belongs to a recursive sum data type.


</code></pre>

          </div>
        </div>
      </div>
    </div>
    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-right">
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/tree/master/md-pages/learn/tutorials/guidelines.md">Edit</a></li>
            <li><a href="#">Feedback</a></li>
            <li><a href="#">Contact us</a></li>
            <li><a href="#">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script>
      if(document.getElementById('buttons')) octry('')
</script>
  </body>
</html>
