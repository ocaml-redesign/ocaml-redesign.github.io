<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title> &#8211; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" />
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet" />
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen" />
    <link href="/static/css/bootstrap_mod.css" rel="stylesheet" media="screen" />
    <link href="/static/css/opamdoc.css" rel="stylesheet" media="screen" />
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <script type="text/javascript">
      function octry(x){
        if(document.getElementById('buttons').innerHTML=='') {
          t = document.getElementById('tryocaml');
          js = document.createElement("script"); js.type = "text/javascript"; js.src = "/try-ocaml.js";
          t.appendChild(js);
        } else {
          t = document.getElementById('tryocaml');
          t.style.display = 'block';
          document.getElementById('console').value = x;
          document.getElementById('console').focus();
          document.getElementById('console').select();
        }
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml" /></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/pkg/">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
    <div class="container">
  <div class="row">
    

    <div id="content-primary" class="span8">
      <div id='tryocaml' class="content" style='display:none;'>
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style='display:none;'></div>
            <div id="menu-lessons" style='display:none'>
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td id=""></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id='main-contents' class="content">
        <p>Data Types and Matching</p>
<h1 id="DataTypesandMatching"> Data Types and Matching</h1><h2 id="Linkedlists"> Linked lists</h2><p>

As with Perl, OCaml has support for lists built into the language. All
elements of a list in OCaml must be the same type. To write a list, use:</p>
<pre><code class='tryocaml'><span class='keywordsign'>[</span><span class='number'>1</span><span class='keywordsign'>;</span> <span class='number'>2</span><span class='keywordsign'>;</span> <span class='number'>3</span><span class='keywordsign'>]</span>
<a href="javascript:octry('[1; 2; 3]\n');">[try]</a></code></pre>
<p>
(Note semicolons, NOT commas).</p>
<p><code>[]</code> is the empty list.</p>
<p>A list has a <strong>head</strong> (the first element) and a <strong>tail</strong> (the rest of
the elements). The head is an element, and the tail is a list, so in the
above example, the head is the integer <code>1</code> while the tail is the <em>list</em>
<code>[2; 3]</code>.</p>
<p>An alternative way to write a list is to use the <strong>cons</strong> operator
<code>head :: tail</code>. So the following ways to write a list are exactly the
same:</p>
<pre><code class='tryocaml'><span class='keywordsign'>[</span><span class='number'>1</span><span class='keywordsign'>;</span> <span class='number'>2</span><span class='keywordsign'>;</span> <span class='number'>3</span><span class='keywordsign'>]</span>
<span class='number'>1</span> <span class='keywordsign'>::</span> <span class='keywordsign'>[</span><span class='number'>2</span><span class='keywordsign'>;</span> <span class='number'>3</span><span class='keywordsign'>]</span>
<span class='number'>1</span> <span class='keywordsign'>::</span> <span class='number'>2</span> <span class='keywordsign'>::</span> <span class='keywordsign'>[</span><span class='number'>3</span><span class='keywordsign'>]</span>
<span class='number'>1</span> <span class='keywordsign'>::</span> <span class='number'>2</span> <span class='keywordsign'>::</span> <span class='number'>3</span> <span class='keywordsign'>::</span> <span class='operator'>[]</span>
<a href="javascript:octry('[1; 2; 3]\n1 :: [2; 3]\n1 :: 2 :: [3]\n1 :: 2 :: 3 :: []\n');">[try]</a></code></pre>
<p>
Why do I mention the cons operator? Well, it&#39;s useful when we start
doing <em>pattern matching</em> on lists, which I&#39;ll talk about below.</p>
<h3 id="Thetypeofalinkedlist"> The type of a linked list</h3><p>
The type of a linked list of integers is <code>int list</code>, and in general the
type of a linked list of <code>foo</code>s is <code>foo list</code>.</p>
<p>This implies that all the elements of a linked list must have the same
type. But the type can be polymorphic (ie. <code>&#39;a list</code>), which is really
useful if you want to write generic functions which operate on &quot;lists of
anything&quot;. (But note: <code>&#39;a list</code> doesn&#39;t mean that each individual
element has a different type - you still can&#39;t use this to construct a
list containing, say, a mixture of ints and strings. It means that the
type of the elements is anything, but all the same type of anything.)</p>
<p>The <code>length</code> function defined as part of the OCaml <code>List</code> module is a
good example of this. It doesn&#39;t matter if the list contains ints or
strings or objects or small furry animals, the <code>List.length</code> function
can still be called on it. The type of <code>List.length</code> is therefore:</p>
<pre><code class='tryocaml'><span class='constructor'>List</span><span class='keywordsign'>.</span><span class='lower'>length</span> <span class='keywordsign'>:</span> <span class='keywordsign'>&#39;</span><span class='lower'>alist</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>int</span>
<a href="javascript:octry('List.length : \&#39;a list -&#62; int\n');">[try]</a></code></pre>
<h2 id="Structures"> Structures</h2><p>

C and C++ have the concept of a simple <code>struct</code>, short for structure.
Java has classes which can be used to similar effect, albeit much more
laboriously.</p>
<p>Consider this simple C structure:</p>
<pre><code class='tryocaml'><span class='keyword'>struct</span> <span class='lower'>pair_of_ints</span> <span class='keywordsign'>{</span>
  <span class='lower'>int</span> <span class='lower'>a</span><span class='keywordsign'>,</span> <span class='lower'>b</span><span class='keywordsign'>;</span>
<span class='keywordsign'>}</span><span class='keywordsign'>;</span>
<a href="javascript:octry('struct pair_of_ints {\n  int a, b;\n};\n');">[try]</a></code></pre>
<p>
The simplest equivalent to this in OCaml is a <strong>tuple</strong> such as <code>(3, 4)</code>
which has the type <code>int * int</code>. Unlike lists, tuples can contain
elements of different types, so for example <code>(3, &quot;hello&quot;, &#39;x&#39;)</code> has type
<code>int * string * char</code>.</p>
<p>A slightly more complex alternative way of writing a C struct is to use
a <strong>record</strong>. Records, like C structs, allow you to name the elements.
Tuples don&#39;t let you name the elements, but instead you have to remember
the order in which they appear. Here is the equivalent record for our C
struct above:</p>
<pre><code class='tryocaml'><span class='keyword'>type</span> <span class='lower'>pair_of_ints</span> <span class='keywordsign'>=</span> <span class='keywordsign'>{</span> <span class='lower'>a</span> <span class='keywordsign'>:</span> <span class='lower'>int</span><span class='keywordsign'>;</span> <span class='lower'>b</span> <span class='keywordsign'>:</span> <span class='lower'>int</span> <span class='keywordsign'>}</span><span class='keywordsign'>;;</span>
<a href="javascript:octry('type pair_of_ints = { a : int; b : int };;\n');">[try]</a></code></pre>
<p>
That defines the type, and here is how we actually <em>create</em> objects of
this type:</p>
<pre><code class='tryocaml'><span class='keywordsign'>{</span> <span class='lower'>a</span><span class='keywordsign'>=</span><span class='number'>3</span><span class='keywordsign'>;</span> <span class='lower'>b</span><span class='keywordsign'>=</span><span class='number'>5</span> <span class='keywordsign'>}</span>
<a href="javascript:octry('{ a=3; b=5 }\n');">[try]</a></code></pre>
<p>
Note that we use &quot;:&quot; in the type definition and &quot;=&quot; when creating
objects of this type.</p>
<p>Here are some examples of this typed into the toplevel:</p>
<pre><code class='tryocaml'><span class='keyword'>type</span> <span class='lower'>pair_of_ints</span> <span class='keywordsign'>=</span> <span class='keywordsign'>{</span> <span class='lower'>a</span> <span class='keywordsign'>:</span> <span class='lower'>int</span><span class='keywordsign'>;</span> <span class='lower'>b</span> <span class='keywordsign'>:</span> <span class='lower'>int</span> <span class='keywordsign'>}</span><span class='keywordsign'>;;</span>
<span class='keywordsign'>{</span><span class='lower'>a</span><span class='keywordsign'>=</span><span class='number'>3</span><span class='keywordsign'>;</span> <span class='lower'>b</span><span class='keywordsign'>=</span><span class='number'>5</span><span class='keywordsign'>}</span><span class='keywordsign'>;;</span>
<span class='keywordsign'>{</span><span class='lower'>a</span><span class='keywordsign'>=</span><span class='number'>3</span><span class='keywordsign'>}</span><span class='keywordsign'>;;</span>
<a href="javascript:octry('type pair_of_ints = { a : int; b : int };;\n{a=3; b=5};;\n{a=3};;\n');">[try]</a></code></pre>
<p>
So OCaml won&#39;t let you leave some fields in your structure undefined.</p>
<h2 id="Variantsqualifiedunionsandenums"> Variants (qualified unions and enums)</h2><p>
A &quot;qualified union&quot; doesn&#39;t really exist in C, although there is support
in the gcc compiler for it. Here is the pattern which one commonly uses
for a qualified union in C:</p>
<pre><code class='tryocaml'><span class='keyword'>struct</span> <span class='lower'>foo</span> <span class='keywordsign'>{</span>
  <span class='lower'>int</span> <span class='keyword'>type</span><span class='keywordsign'>;</span>
<span class='keywordsign'>#</span><span class='lower'>define</span> <span class='constructor'>TYPE_INT</span> <span class='number'>1</span>
<span class='keywordsign'>#</span><span class='lower'>define</span> <span class='constructor'>TYPE_PAIR_OF_INTS</span> <span class='number'>2</span>
<span class='keywordsign'>#</span><span class='lower'>define</span> <span class='constructor'>TYPE_STRING</span> <span class='number'>3</span>
  <span class='lower'>union</span> <span class='keywordsign'>{</span>
    <span class='lower'>int</span> <span class='lower'>i</span><span class='keywordsign'>;</span>        <span class='infix'>//</span> <span class='constructor'>If</span> <span class='keyword'>type</span> <span class='infix'>==</span> <span class='constructor'>TYPE_INT</span><span class='keywordsign'>.</span>
    <span class='lower'>int</span> <span class='lower'>pair</span><span class='keywordsign'>[</span><span class='number'>2</span><span class='keywordsign'>]</span><span class='keywordsign'>;</span>  <span class='infix'>//</span> <span class='constructor'>If</span> <span class='keyword'>type</span> <span class='infix'>==</span> <span class='constructor'>TYPE_PAIR_OF_INTS</span><span class='keywordsign'>.</span>
    <span class='lower'>char</span> <span class='keywordsign'>*</span><span class='lower'>str</span><span class='keywordsign'>;</span>    <span class='infix'>//</span> <span class='constructor'>If</span> <span class='keyword'>type</span> <span class='infix'>==</span> <span class='constructor'>TYPE_STRING</span><span class='keywordsign'>.</span>
  <span class='keywordsign'>}</span> <span class='lower'>u</span><span class='keywordsign'>;</span>
<span class='keywordsign'>}</span><span class='keywordsign'>;</span>
<a href="javascript:octry('struct foo {\n  int type;\n#define TYPE_INT 1\n#define TYPE_PAIR_OF_INTS 2\n#define TYPE_STRING 3\n  union {\n    int i;        // If type == TYPE_INT.\n    int pair[2];  // If type == TYPE_PAIR_OF_INTS.\n    char *str;    // If type == TYPE_STRING.\n  } u;\n};\n');">[try]</a></code></pre>
<p>
We&#39;ve all seen this I should think, and it&#39;s not a pretty sight. For a
start it&#39;s not safe: the programmer might make a mistake and
accidentally use, say, the <code>u.i</code> field when in fact a string was stored
in the structure. Also the compiler can&#39;t easily check if all possible
types have been examined in a switch statement (you can use an <code>enum</code>
type instead to solve this particular problem). The programmer might
forget to set the <code>type</code> field, which would result in all sorts of fun
and games. Furthermore, it&#39;s cumbersome.</p>
<p>Here is the elegant and concise equivalent in OCaml:</p>
<pre><code class='tryocaml'><span class='keyword'>type</span> <span class='lower'>foo</span> <span class='keywordsign'>=</span> <span class='constructor'>Nothing</span> <span class='keywordsign'>|</span> <span class='constructor'>Int</span> <span class='keyword'>of</span> <span class='lower'>int</span> <span class='keywordsign'>|</span> <span class='constructor'>Pair</span> <span class='keyword'>of</span> <span class='lower'>int</span> <span class='keywordsign'>*</span> <span class='lower'>int</span> <span class='keywordsign'>|</span> <span class='constructor'>String</span> <span class='keyword'>of</span> <span class='lower'>string</span>
<a href="javascript:octry('type foo = Nothing | Int of int | Pair of int * int | String of string\n');">[try]</a></code></pre>
<p>
That&#39;s the type definition. First part of each <code>|</code> separated part is
called the constructor. It can be called anything, as long as it starts
with a capital letter. If the constructor can be used to define a value,
it&#39;s followed by the <code>of type</code> part, where type always starts with a
lowercase letter. In the above example, Nothing is used as a constant
and the other constructors are used with values.</p>
<p>To actually <em>create</em> things of this type you would write:</p>
<pre><code class='tryocaml'><span class='constructor'>Nothing</span>
<span class='constructor'>Int</span> <span class='number'>3</span>
<span class='constructor'>Pair</span> <span class='keywordsign'>(</span><span class='number'>4</span><span class='keywordsign'>,</span> <span class='number'>5</span><span class='keywordsign'>)</span>
<span class='constructor'>String</span> <span class='string'>&#34;hello&#34;</span>
<span class='operator'>...</span>
<a href="javascript:octry('Nothing\nInt 3\nPair (4, 5)\nString &#34;hello&#34;\n...\n');">[try]</a></code></pre>
<p>
Each of these expressions has type <code>foo</code>.</p>
<p>Note that you use <code>of</code> when writing the type definition, but NOT when
writing elements of the type.</p>
<p>By extension, a simple C <code>enum</code> defined as:</p>
<pre><code class='tryocaml'><span class='lower'>enum</span> <span class='lower'>sign</span> <span class='keywordsign'>{</span> <span class='lower'>positive</span><span class='keywordsign'>,</span> <span class='lower'>zero</span><span class='keywordsign'>,</span> <span class='lower'>negative</span> <span class='keywordsign'>}</span><span class='keywordsign'>;</span>
<a href="javascript:octry('enum sign { positive, zero, negative };\n');">[try]</a></code></pre>
<p>
can be written in OCaml as:</p>
<pre><code class='tryocaml'><span class='keyword'>type</span> <span class='lower'>sign</span> <span class='keywordsign'>=</span> <span class='constructor'>Positive</span> <span class='keywordsign'>|</span> <span class='constructor'>Zero</span> <span class='keywordsign'>|</span> <span class='constructor'>Negative</span>
<a href="javascript:octry('type sign = Positive | Zero | Negative\n');">[try]</a></code></pre>
<h3 id="Recursivevariantsusedfortrees"> Recursive variants (used for trees)</h3><p>

Variants can be recursive, and the common use for this is to define tree
structures. This really is where the expressive power of functional
languages come into their own:</p>
<pre><code class='tryocaml'><span class='keyword'>type</span> <span class='lower'>binary_tree</span> <span class='keywordsign'>=</span> <span class='constructor'>Leaf</span> <span class='keyword'>of</span> <span class='lower'>int</span> <span class='keywordsign'>|</span> <span class='constructor'>Tree</span> <span class='keyword'>of</span> <span class='lower'>binary_tree</span> <span class='keywordsign'>*</span> <span class='lower'>binary_tree</span>
<a href="javascript:octry('type binary_tree = Leaf of int | Tree of binary_tree * binary_tree\n');">[try]</a></code></pre>
<p>
Here&#39;re some binary trees. For practice, try drawing them on paper.</p>
<pre><code class='tryocaml'><span class='constructor'>Leaf</span> <span class='number'>3</span>
<span class='constructor'>Tree</span> <span class='keywordsign'>(</span><span class='constructor'>Leaf</span> <span class='number'>3</span><span class='keywordsign'>,</span> <span class='constructor'>Leaf</span> <span class='number'>4</span><span class='keywordsign'>)</span>
<span class='constructor'>Tree</span> <span class='keywordsign'>(</span><span class='constructor'>Tree</span> <span class='keywordsign'>(</span><span class='constructor'>Leaf</span> <span class='number'>3</span><span class='keywordsign'>,</span> <span class='constructor'>Leaf</span> <span class='number'>4</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='constructor'>Leaf</span> <span class='number'>5</span><span class='keywordsign'>)</span>
<span class='constructor'>Tree</span> <span class='keywordsign'>(</span><span class='constructor'>Tree</span> <span class='keywordsign'>(</span><span class='constructor'>Leaf</span> <span class='number'>3</span><span class='keywordsign'>,</span> <span class='constructor'>Leaf</span> <span class='number'>4</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='constructor'>Tree</span> <span class='keywordsign'>(</span><span class='constructor'>Tree</span> <span class='keywordsign'>(</span><span class='constructor'>Leaf</span> <span class='number'>3</span><span class='keywordsign'>,</span> <span class='constructor'>Leaf</span> <span class='number'>4</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='constructor'>Leaf</span> <span class='number'>5</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
<a href="javascript:octry('Leaf 3\nTree (Leaf 3, Leaf 4)\nTree (Tree (Leaf 3, Leaf 4), Leaf 5)\nTree (Tree (Leaf 3, Leaf 4), Tree (Tree (Leaf 3, Leaf 4), Leaf 5))\n');">[try]</a></code></pre>
<h3 id="Parameterizedvariants"> Parameterized variants</h3><p>

The binary tree in the previous section has integers at each leaf, but
what if we wanted to describe the <em>shape</em> of a binary tree, but decide
exactly what to store at each leaf node later? We can do this by using a
parameterized (or polymorphic) variant, like this:</p>
<pre><code class='tryocaml'><span class='keyword'>type</span> <span class='keywordsign'>&#39;</span><span class='lower'>abinary_tree</span> <span class='keywordsign'>=</span> <span class='constructor'>Leaf</span> <span class='keyword'>of</span> <span class='keywordsign'>&#39;</span><span class='lower'>a</span><span class='keywordsign'>|</span> <span class='constructor'>Tree</span> <span class='keyword'>of</span> <span class='keywordsign'>&#39;</span><span class='lower'>abinary_tree</span> <span class='keywordsign'>*</span> <span class='keywordsign'>&#39;</span><span class='lower'>abinary_tree</span>
<a href="javascript:octry('type \&#39;a binary_tree = Leaf of \&#39;a | Tree of \&#39;a binary_tree * \&#39;a binary_tree\n');">[try]</a></code></pre>
<p>
This is a general type. The specific type which stores integers at each
leaf is called <code>int binary_tree</code>. Similarly the specific type which
stores strings at each leaf is called <code>string binary_tree</code>. In the next
example we type some instances into the top-level and allow the type
inference system to show the types for us:</p>
<pre><code class='tryocaml'><span class='constructor'>Leaf</span> <span class='string'>&#34;hello&#34;</span><span class='keywordsign'>;;</span>
<span class='constructor'>Leaf</span> <span class='number'>3.0</span><span class='keywordsign'>;;</span>
<a href="javascript:octry('Leaf &#34;hello&#34;;;\nLeaf 3.0;;\n');">[try]</a></code></pre>
<p>
Notice how the type name is backwards. Compare this to the type names
for lists, eg. <code>int list</code> etc.</p>
<p>In fact it is no coincidence that <code>&#39;a list</code> is written &quot;backwards&quot; in
the same way. Lists are simply parameterized variant types with the
following slightly strange definition:</p>
<pre><code class='tryocaml'>  <span class='keyword'>type</span> <span class='keywordsign'>&#39;</span><span class='lower'>alist</span> <span class='keywordsign'>=</span> <span class='operator'>[]</span> <span class='keywordsign'>|</span> <span class='keywordsign'>::</span> <span class='keyword'>of</span> <span class='keywordsign'>&#39;</span><span class='lower'>a</span><span class='keywordsign'>*</span> <span class='keywordsign'>&#39;</span><span class='lower'>alist</span>   <span class='comment'>(* not real OCaml code *)</span>
<a href="javascript:octry('  type \&#39;a list = [] | :: of \&#39;a * \&#39;a list   (* not real OCaml code *)\n');">[try]</a></code></pre>
<p>
Actually the definition above doesn&#39;t quite compile. Here&#39;s a
pretty-much equivalent definition:</p>
<pre><code class='tryocaml'><span class='keyword'>type</span> <span class='keywordsign'>&#39;</span><span class='lower'>aequiv_list</span> <span class='keywordsign'>=</span> <span class='constructor'>Nil</span> <span class='keywordsign'>|</span> <span class='constructor'>Cons</span> <span class='keyword'>of</span> <span class='keywordsign'>&#39;</span><span class='lower'>a</span><span class='keywordsign'>*</span> <span class='keywordsign'>&#39;</span><span class='lower'>aequiv_list</span><span class='keywordsign'>;;</span>
<span class='constructor'>Nil</span><span class='keywordsign'>;;</span>
<span class='constructor'>Cons</span><span class='keywordsign'>(</span><span class='number'>1</span><span class='keywordsign'>,</span> <span class='constructor'>Nil</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
<span class='constructor'>Cons</span><span class='keywordsign'>(</span><span class='number'>1</span><span class='keywordsign'>,</span> <span class='constructor'>Cons</span><span class='keywordsign'>(</span><span class='number'>2</span><span class='keywordsign'>,</span> <span class='constructor'>Nil</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
<a href="javascript:octry('type \&#39;a equiv_list = Nil | Cons of \&#39;a * \&#39;a equiv_list;;\nNil;;\nCons(1, Nil);;\nCons(1, Cons(2, Nil));;\n');">[try]</a></code></pre>
<p>
Recall earlier that we said lists could be written two ways, either with
the simple syntactic sugar of <code>[1; 2; 3]</code> or more formally as
<code>1 :: 2 :: 3 :: []</code>. If you look at the definition for <code>&#39;a list</code> above,
you may be able to see the reason for the formal definition.</p>
<h2 id="Listsstructuresandvariantssummary"> Lists, structures and variants - summary</h2><p>
OCaml name Example type definition Example usage</p>
<pre><code class='tryocaml'><span class='lower'>list</span>            <span class='lower'>int</span> <span class='lower'>list</span>                               <span class='keywordsign'>[</span><span class='number'>1</span><span class='keywordsign'>;</span> <span class='number'>2</span><span class='keywordsign'>;</span> <span class='number'>3</span><span class='keywordsign'>]</span>
<span class='lower'>tuple</span>           <span class='lower'>int</span> <span class='keywordsign'>*</span> <span class='lower'>string</span>                           <span class='keywordsign'>(</span><span class='number'>3</span><span class='keywordsign'>,</span> <span class='string'>&#34;hello&#34;</span><span class='keywordsign'>)</span>
<span class='lower'>record</span>          <span class='keyword'>type</span> <span class='lower'>pair</span> <span class='keywordsign'>=</span> <span class='keywordsign'>{</span> <span class='lower'>a</span> <span class='keywordsign'>:</span> <span class='lower'>int</span><span class='keywordsign'>;</span> <span class='lower'>b</span> <span class='keywordsign'>:</span> <span class='lower'>string</span> <span class='keywordsign'>}</span>    <span class='keywordsign'>{</span> <span class='lower'>a</span> <span class='keywordsign'>=</span> <span class='number'>3</span><span class='keywordsign'>;</span> <span class='lower'>b</span> <span class='keywordsign'>=</span> <span class='string'>&#34;hello&#34;</span> <span class='keywordsign'>}</span>
<span class='lower'>variant</span>         <span class='keyword'>type</span> <span class='lower'>foo</span> <span class='keywordsign'>=</span> <span class='constructor'>Int</span> <span class='keyword'>of</span> <span class='lower'>int</span>                  <span class='constructor'>Int</span> <span class='number'>3</span>
                           <span class='keywordsign'>|</span> <span class='constructor'>Pair</span> <span class='keyword'>of</span> <span class='lower'>int</span> <span class='keywordsign'>*</span> <span class='lower'>string</span>                                                                      
<span class='lower'>variant</span>         <span class='keyword'>type</span> <span class='lower'>sign</span> <span class='keywordsign'>=</span> <span class='constructor'>Positive</span> <span class='keywordsign'>|</span> <span class='constructor'>Zero</span>            <span class='constructor'>Positive</span>
                            <span class='keywordsign'>|</span> <span class='constructor'>Negative</span>                 <span class='constructor'>Zero</span>
<span class='lower'>parameterized</span>   <span class='keyword'>type</span> <span class='keywordsign'>&#39;</span><span class='lower'>amy_list</span> <span class='keywordsign'>=</span> <span class='constructor'>Empty</span>                <span class='constructor'>Cons</span> <span class='keywordsign'>(</span><span class='number'>1</span><span class='keywordsign'>,</span> <span class='constructor'>Cons</span> <span class='keywordsign'>(</span><span class='number'>2</span><span class='keywordsign'>,</span> <span class='constructor'>Empty</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
  <span class='lower'>variant</span>                   <span class='keywordsign'>|</span> <span class='constructor'>Cons</span> <span class='keyword'>of</span> <span class='keywordsign'>&#39;</span><span class='lower'>a</span><span class='keywordsign'>*</span> <span class='keywordsign'>&#39;</span><span class='lower'>amy_list</span>
<a href="javascript:octry('list            int list                               [1; 2; 3]\ntuple           int * string                           (3, &#34;hello&#34;)\nrecord          type pair = { a : int; b : string }    { a = 3; b = &#34;hello&#34; }\nvariant         type foo = Int of int                  Int 3\n                           | Pair of int * string                                                                      \nvariant         type sign = Positive | Zero            Positive\n                            | Negative                 Zero\nparameterized   type \&#39;a my_list = Empty                Cons (1, Cons (2, Empty))\n  variant                   | Cons of \&#39;a * \&#39;a my_list\n');">[try]</a></code></pre>
<h2 id="Patternmatchingondatatypes"> Pattern matching (on datatypes)</h2><p>

So one Really Cool Feature of functional languages is the ability to
break apart data structures and do pattern matching on the data. This is
again not really a &quot;functional&quot; feature - you could imagine some
variation of C appearing which would let you do this, but it&#39;s a Cool
Feature nonetheless.</p>
<p>Let&#39;s start with a real program requirement: I wish to represent simple
mathematical expressions like <code>n * (x + y)</code> and multiply them out
symbolically to get <code>n * x + n * y</code>.</p>
<p>Let&#39;s define a type for these expressions:</p>
<pre><code class='tryocaml'>  <span class='keyword'>type</span> <span class='lower'>expr</span> <span class='keywordsign'>=</span> <span class='constructor'>Plus</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>          <span class='comment'>(* means a + b *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Minus</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>       <span class='comment'>(* means a - b *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Times</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>       <span class='comment'>(* means a * b *)</span>
          <span class='keywordsign'>|</span> <span class='constructor'>Divide</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>      <span class='comment'>(* means a / b *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Value</span> <span class='keyword'>of</span> <span class='lower'>string</span>            <span class='comment'>(* &#34;x&#34;, &#34;y&#34;, &#34;n&#34;, etc. *)</span>
<a href="javascript:octry('  type expr = Plus of expr * expr          (* means a + b *)\n              | Minus of expr * expr       (* means a - b *)\n              | Times of expr * expr       (* means a * b *)\n          | Divide of expr * expr      (* means a / b *)\n              | Value of string            (* &#34;x&#34;, &#34;y&#34;, &#34;n&#34;, etc. *)\n');">[try]</a></code></pre>
<p>
The expression <code>n * (x + y)</code> would be written:</p>
<pre><code class='tryocaml'><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;n&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;x&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Value</span> <span class='string'>&#34;y&#34;</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
<a href="javascript:octry('Times (Value &#34;n&#34;, Plus (Value &#34;x&#34;, Value &#34;y&#34;))\n');">[try]</a></code></pre>
<p>
Let&#39;s write a function which prints out
<code>Times (Value &quot;n&quot;, Plus (Value &quot;x&quot;, Value &quot;y&quot;))</code> as something more like
<code>n * (x + y)</code>. Actually, I&#39;m going to write two functions, one which
converts the expression to a pretty string, and one which prints it out
(the reason is that I might want to write the same string to a file and
I wouldn&#39;t want to repeat the whole of the function just for that).</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>to_string</span> <span class='lower'>e</span> <span class='keywordsign'>=</span>
    <span class='keyword'>match</span> <span class='lower'>e</span> <span class='keyword'>with</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span>   <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; + &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Minus</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span>  <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; - &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span>  <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; * &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Divide</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; / &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Value</span> <span class='lower'>v</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>v</span> <span class='keywordsign'>;;</span>
  
  <span class='keyword'>let</span> <span class='lower'>print_expr</span> <span class='lower'>e</span> <span class='keywordsign'>=</span>
    <span class='lower'>print_endline</span> <span class='keywordsign'>(</span><span class='lower'>to_string</span> <span class='lower'>e</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
<a href="javascript:octry('  let rec to_string e =\n    match e with\n    | Plus (left, right)   -&#62; &#34;(&#34; ^ to_string left ^ &#34; + &#34; ^ to_string right ^ &#34;)&#34;\n    | Minus (left, right)  -&#62; &#34;(&#34; ^ to_string left ^ &#34; - &#34; ^ to_string right ^ &#34;)&#34;\n    | Times (left, right)  -&#62; &#34;(&#34; ^ to_string left ^ &#34; * &#34; ^ to_string right ^ &#34;)&#34;\n    | Divide (left, right) -&#62; &#34;(&#34; ^ to_string left ^ &#34; / &#34; ^ to_string right ^ &#34;)&#34;\n    | Value v -&#62; v ;;\n  \n  let print_expr e =\n    print_endline (to_string e);;\n');">[try]</a></code></pre>
<p>
(NB: The <code>^</code> operator concatenates strings.)</p>
<p>Here&#39;s the print function in action:</p>
<pre><code class='tryocaml'><span class='lower'>print_expr</span> <span class='keywordsign'>(</span><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;n&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;x&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Value</span> <span class='string'>&#34;y&#34;</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
<a href="javascript:octry('print_expr (Times (Value &#34;n&#34;, Plus (Value &#34;x&#34;, Value &#34;y&#34;)))\n');">[try]</a></code></pre>
<p>
The general form for pattern matching is:</p>
<pre><code class='tryocaml'><span class='keyword'>match</span> <span class='keyword'>object</span> <span class='keyword'>with</span>
<span class='keywordsign'>|</span> <span class='lower'>pattern</span>    <span class='keywordsign'>-&#62;</span>  <span class='lower'>result</span>
<span class='keywordsign'>|</span> <span class='lower'>pattern</span>    <span class='keywordsign'>-&#62;</span>  <span class='lower'>result</span>
    <span class='operator'>...</span>
<a href="javascript:octry('match object with\n| pattern    -&#62;  result\n| pattern    -&#62;  result\n    ...\n');">[try]</a></code></pre>
<p>
The patterns on the left hand side can be simple, as in the <code>to_string</code>
function above, or complex and nested. The next example is our function
to multiply out expressions of the form <code>n * (x + y)</code> or <code>(x + y) * n</code>
and for this we will use a nested pattern:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>multiply_out</span> <span class='lower'>e</span> <span class='keywordsign'>=</span>
    <span class='keyword'>match</span> <span class='lower'>e</span> <span class='keyword'>with</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>e2</span><span class='keywordsign'>,</span> <span class='lower'>e3</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span>
        <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>e2</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span>
              <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>e3</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='lower'>e2</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='lower'>e3</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span>
        <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>e3</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span>
              <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>e2</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>e3</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>right</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Minus</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='constructor'>Minus</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>right</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>right</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Divide</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='constructor'>Divide</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>multiply_out</span> <span class='lower'>right</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Value</span> <span class='lower'>v</span> <span class='keywordsign'>-&#62;</span> <span class='constructor'>Value</span> <span class='lower'>v</span>
<a href="javascript:octry('  let rec multiply_out e =\n    match e with\n    | Times (e1, Plus (e2, e3)) -&#62;\n        Plus (Times (multiply_out e1, multiply_out e2),\n              Times (multiply_out e1, multiply_out e3))\n    | Times (Plus (e1, e2), e3) -&#62;\n        Plus (Times (multiply_out e1, multiply_out e3),\n              Times (multiply_out e2, multiply_out e3))\n    | Plus (left, right) -&#62; Plus (multiply_out left, multiply_out right)\n    | Minus (left, right) -&#62; Minus (multiply_out left, multiply_out right)\n    | Times (left, right) -&#62; Times (multiply_out left, multiply_out right)\n    | Divide (left, right) -&#62; Divide (multiply_out left, multiply_out right)\n    | Value v -&#62; Value v\n');">[try]</a></code></pre>
<p>
Here it is in action:</p>
<pre><code class='tryocaml'><span class='lower'>print_expr</span> <span class='keywordsign'>(</span><span class='lower'>multiply_out</span> <span class='keywordsign'>(</span><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;n&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;x&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Value</span> <span class='string'>&#34;y&#34;</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
<a href="javascript:octry('print_expr (multiply_out (Times (Value &#34;n&#34;, Plus (Value &#34;x&#34;, Value &#34;y&#34;))))\n');">[try]</a></code></pre>
<p>
How does the <code>multiply_out</code> function work? The key is in the first two
patterns. The first pattern is <code>Times (e1, Plus (e2, e3))</code> which matches
expressions of the form <code>e1 * (e2 + e3)</code>. Now look at the right hand
side of this first pattern match, and convince yourself that it is the
equivalent of <code>(e1 * e2) + (e1 * e3)</code>.</p>
<p>The second pattern does the same thing, except for expressions of the
form <code>(e1 + e2) * e3</code>.</p>
<p>The remaining patterns don&#39;t change the form of the expression, but they
crucially <em>do</em> call the <code>multiply_out</code> function recursively on their
subexpressions. This ensures that all subexpressions within the
expression get multiplied out too (if you only wanted to multiply out
the very top level of an expression, then you could replace all the
remaining patterns with a simple <code>e -&gt; e</code> rule).</p>
<p>Can we do the reverse (ie. factorizing out common subexpressions)? We
sure can! (But it&#39;s a bit more complicated). The following version only
works for the top level expression. You could certainly extend it to
cope with all levels of an expression and more complex cases:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>factorize</span> <span class='lower'>e</span> <span class='keywordsign'>=</span>
    <span class='keyword'>match</span> <span class='lower'>e</span> <span class='keyword'>with</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='lower'>e2</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>e3</span><span class='keywordsign'>,</span> <span class='lower'>e4</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span> <span class='keyword'>when</span> <span class='lower'>e1</span> <span class='keywordsign'>=</span> <span class='lower'>e3</span> <span class='keywordsign'>-&#62;</span>
       <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>e2</span><span class='keywordsign'>,</span> <span class='lower'>e4</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='lower'>e2</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>e3</span><span class='keywordsign'>,</span> <span class='lower'>e4</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span> <span class='keyword'>when</span> <span class='lower'>e2</span> <span class='keywordsign'>=</span> <span class='lower'>e4</span> <span class='keywordsign'>-&#62;</span>
       <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>e1</span><span class='keywordsign'>,</span> <span class='lower'>e3</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='lower'>e4</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>|</span> <span class='lower'>e</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>e</span>

<span class='lower'>factorize</span> <span class='keywordsign'>(</span><span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;n&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Value</span> <span class='string'>&#34;x&#34;</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='constructor'>Value</span> <span class='string'>&#34;n&#34;</span><span class='keywordsign'>,</span> <span class='constructor'>Value</span> <span class='string'>&#34;y&#34;</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
<a href="javascript:octry('  let factorize e =\n    match e with\n    | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 -&#62;\n       Times (e1, Plus (e2, e4))\n    | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 -&#62;\n       Times (Plus (e1, e3), e4)\n    | e -&#62; e\n\nfactorize (Plus (Times (Value &#34;n&#34;, Value &#34;x&#34;), Times (Value &#34;n&#34;, Value &#34;y&#34;)))\n');">[try]</a></code></pre>
<p>
The factorize function above introduces another couple of features. You
can add what are known as <strong>guards</strong> to each pattern match. A guard is
the conditional which follows the <code>when</code>, and it means that the pattern
match only happens if the pattern matches <em>and</em> the condition in the
<code>when</code>-clause is satisfied.</p>
<pre><code class='tryocaml'><span class='keyword'>match</span> <span class='keyword'>object</span> <span class='keyword'>with</span>
  <span class='lower'>pattern</span>    <span class='keywordsign'>[</span> <span class='keyword'>when</span> <span class='lower'>condition</span> <span class='keywordsign'>]</span>   <span class='keywordsign'>-&#62;</span>  <span class='lower'>result</span>
  <span class='lower'>pattern</span>    <span class='keywordsign'>[</span> <span class='keyword'>when</span> <span class='lower'>condition</span> <span class='keywordsign'>]</span>   <span class='keywordsign'>-&#62;</span>  <span class='lower'>result</span>
    <span class='operator'>...</span>
<a href="javascript:octry('match object with\n  pattern    [ when condition ]   -&#62;  result\n  pattern    [ when condition ]   -&#62;  result\n    ...\n');">[try]</a></code></pre>
<p>
The second feature is the <code>=</code> operator which tests for &quot;structural
equality&quot; between two expressions. That means it goes recursively into
each expression checking they&#39;re exactly the same at all levels down.</p>
<p>OCaml is able to check at compile time that you have covered all
possibilities in your patterns. I changed the type definition of
<code>type expr</code> above by adding a <code>Product</code> variant:</p>
<pre><code class='tryocaml'>  <span class='keyword'>type</span> <span class='lower'>expr</span> <span class='keywordsign'>=</span> <span class='constructor'>Plus</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>        <span class='comment'>(* means a + b *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Minus</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>     <span class='comment'>(* means a - b *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Times</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>     <span class='comment'>(* means a * b *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Divide</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='keywordsign'>*</span> <span class='lower'>expr</span>    <span class='comment'>(* means a / b *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Product</span> <span class='keyword'>of</span> <span class='lower'>expr</span> <span class='lower'>list</span>     <span class='comment'>(* means a * b * c * ... *)</span>
              <span class='keywordsign'>|</span> <span class='constructor'>Value</span> <span class='keyword'>of</span> <span class='lower'>string</span>          <span class='comment'>(* &#34;x&#34;, &#34;y&#34;, &#34;n&#34;, etc. *)</span>
<a href="javascript:octry('  type expr = Plus of expr * expr        (* means a + b *)\n              | Minus of expr * expr     (* means a - b *)\n              | Times of expr * expr     (* means a * b *)\n              | Divide of expr * expr    (* means a / b *)\n              | Product of expr list     (* means a * b * c * ... *)\n              | Value of string          (* &#34;x&#34;, &#34;y&#34;, &#34;n&#34;, etc. *)\n');">[try]</a></code></pre>
<p>
I then recompiled the <code>to_string</code> function without changing it. OCaml
reported the following warning:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>to_string</span> <span class='lower'>e</span> <span class='keywordsign'>=</span>
    <span class='keyword'>match</span> <span class='lower'>e</span> <span class='keyword'>with</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Plus</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span>   <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; + &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Minus</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span>  <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; - &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Times</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span>  <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; * &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Divide</span> <span class='keywordsign'>(</span><span class='lower'>left</span><span class='keywordsign'>,</span> <span class='lower'>right</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='string'>&#34;(&#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>left</span> <span class='infix'>^</span> <span class='string'>&#34; / &#34;</span> <span class='infix'>^</span> <span class='lower'>to_string</span> <span class='lower'>right</span> <span class='infix'>^</span> <span class='string'>&#34;)&#34;</span>
    <span class='keywordsign'>|</span> <span class='constructor'>Value</span> <span class='lower'>v</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>v</span> <span class='keywordsign'>;;</span>

<a href="javascript:octry('  let rec to_string e =\n    match e with\n    | Plus (left, right)   -&#62; &#34;(&#34; ^ to_string left ^ &#34; + &#34; ^ to_string right ^ &#34;)&#34;\n    | Minus (left, right)  -&#62; &#34;(&#34; ^ to_string left ^ &#34; - &#34; ^ to_string right ^ &#34;)&#34;\n    | Times (left, right)  -&#62; &#34;(&#34; ^ to_string left ^ &#34; * &#34; ^ to_string right ^ &#34;)&#34;\n    | Divide (left, right) -&#62; &#34;(&#34; ^ to_string left ^ &#34; / &#34; ^ to_string right ^ &#34;)&#34;\n    | Value v -&#62; v ;;\n\n');">[try]</a></code></pre>

      </div>
    </div>
  </div>
</div>

    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-left">
            <li><a onclick="document.getElementById('footer').style.display='none'">[X]</a></li>

            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/tree/master/md-pages/learn/tutorials/data_types_and_matching.md">Edit this page</a></li>
          </ul>
          <ul class="nav pull-right">
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Feedback</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Contact us</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      // <!--
      if(document.getElementsByTagName('pre').length > 0)
         octry('')
      // -->
    </script>
  </body>
</html>
