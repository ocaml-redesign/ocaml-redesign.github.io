<!DOCTYPE HTML>

<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title> &ndash; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet">
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet">
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen">
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml"></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/list.html">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
        <div class="container">
      <div class="row">

        <div id="content-primary" class="span8">
          <div class="content">
            <h1 id="IntroductiontoGtk"> Introduction to Gtk</h1><h2 id="LablgtkandwritingGtkapplications"> Lablgtk and writing Gtk applications</h2><p>

<a href='http://www.gtk.org/' title='http://www.gtk.org/'>Gtk+</a> is a toolkit for
writing graphical applications, and
<a href='http://wwwfun.kurims.kyoto-u.ac.jp/soft/olabl/lablgtk.html' title='http://wwwfun.kurims.kyoto-u.ac.jp/soft/olabl/lablgtk.html'>lablgtk</a>
is the OCaml interface for Gtk. Gtk and lablgtk are available for Unix
and Windows platforms. In this tutorial I&#39;m going to concentrate on the
older but more stable Gtk version 1.2. Gtk 2.x has some
incompatibilities with Gtk 1.2, although mostly you won&#39;t notice the
difference. On Windows, Gtk 1.2 has a non-native look and feel, but this
is corrected in Gtk 2.x by the use of
<a href='http://gtk-wimp.sourceforge.net/' title='http://gtk-wimp.sourceforge.net/'>Gtk-Wimp</a>
(a Windows native theme for Gtk).</p>
<p>Lablgtk makes ambitious use of advanced features of the OCaml type
system. Make sure you&#39;re familiar with labelled and optional arguments
and polymorphic variants (<a href='labels.html' title='labels'>labels</a>) or you won&#39;t
have any idea what&#39;s going on in this chapter. As it is, even the author
of this tutorial finds ploughing through the lablgtk source code pretty
hard work!</p>
<h3 id="Simplelablgtkprogram"> Simple lablgtk program</h3><p>
Actually, not so simple. This program has a menu with a &quot;quit&quot; option,
and a button in the main area which you can press:</p>
<pre><code class='ocaml'><script>val ml50bd91a97df89360a64f1c7da221250a = 'open GMain&#10;open GdkKeysyms&#10;&#10;let main () =&#10;  let window = GWindow.window ~width:320 ~height:240&#10;                 ~title:&#34;Simple lablgtk program&#34; () in&#10;  let vbox = GPack.vbox ~packing:window#add () in&#10;  window#connect#destroy ~callback:Main.quit;&#10;&#10;  (* Menu bar *)&#10;  let menubar = GMenu.menu_bar ~packing:vbox#pack () in&#10;  let factory = new GMenu.factory menubar in&#10;  let accel_group = factory#accel_group in&#10;  let file_menu = factory#add_submenu &#34;File&#34; in&#10;&#10;  (* File menu *)&#10;  let factory = new GMenu.factory file_menu ~accel_group in&#10;  factory#add_item &#34;Quit&#34; ~key:_Q ~callback: Main.quit;&#10;&#10;  (* Button *)&#10;  let button = GButton.button ~label:&#34;Push me!&#34;&#10;                 ~packing:vbox#add () in&#10;  button#connect#clicked ~callback: (fun () -&#62; prerr_endline &#34;Ouch!&#34;);&#10;&#10;  (* Display the windows and enter Gtk+ main loop *)&#10;  window#add_accel_group accel_group;&#10;  window#show ();&#10;  Main.main ()&#10;&#10;let () = main ()&#10;';</script><span class='k'>open</span> GMain
<span class='k'>open</span> GdkKeysyms

<span class='k'>let</span> main () <span class='k'>=</span>
  <span class='k'>let</span> window <span class='k'>=</span> <span class='m'>GWindow</span><span class='o'>.</span>window <span class='o'>~</span>width<span class='o'>:</span>320 <span class='o'>~</span>height<span class='o'>:</span>240
                 <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;Simple lablgtk program&#34;</span> () <span class='k'>in</span>
  <span class='k'>let</span> vbox <span class='k'>=</span> <span class='m'>GPack</span><span class='o'>.</span>vbox <span class='o'>~</span>packing<span class='o'>:</span>window<span class='o'>#</span>add () <span class='k'>in</span>
  window<span class='o'>#</span>connect<span class='o'>#</span>destroy <span class='o'>~</span>callback<span class='o'>:</span><span class='m'>Main</span><span class='o'>.</span>quit<span class='o'>;</span>

  <span class='com2'>(* Menu bar *)</span><!-- end comment -->
  <span class='k'>let</span> menubar <span class='k'>=</span> <span class='m'>GMenu</span><span class='o'>.</span>menu_bar <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>pack () <span class='k'>in</span>
  <span class='k'>let</span> factory <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GMenu</span><span class='o'>.</span>factory menubar <span class='k'>in</span>
  <span class='k'>let</span> accel_group <span class='k'>=</span> factory<span class='o'>#</span>accel_group <span class='k'>in</span>
  <span class='k'>let</span> file_menu <span class='k'>=</span> factory<span class='o'>#</span>add_submenu <span class='s'>&#34;File&#34;</span> <span class='k'>in</span>

  <span class='com2'>(* File menu *)</span><!-- end comment -->
  <span class='k'>let</span> factory <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GMenu</span><span class='o'>.</span>factory file_menu <span class='o'>~</span>accel_group <span class='k'>in</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Quit&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>Q <span class='o'>~</span>callback<span class='o'>:</span> <span class='m'>Main</span><span class='o'>.</span>quit<span class='o'>;</span>

  <span class='com2'>(* Button *)</span><!-- end comment -->
  <span class='k'>let</span> button <span class='k'>=</span> <span class='m'>GButton</span><span class='o'>.</span>button <span class='o'>~</span>label<span class='o'>:</span><span class='s'>&#34;Push me!&#34;</span>
                 <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>add () <span class='k'>in</span>
  button<span class='o'>#</span>connect<span class='o'>#</span>clicked <span class='o'>~</span>callback<span class='o'>:</span> (<span class='k'>fun</span> () <span class='k'>-></span> prerr_endline <span class='s'>&#34;Ouch!&#34;</span>)<span class='o'>;</span>

  <span class='com2'>(* Display the windows <span class='ic'>and</span> enter Gtk<span class='ic'>+</span> main loop *)</span><!-- end comment -->
  window<span class='o'>#</span>add_accel_group accel_group<span class='o'>;</span>
  window<span class='o'>#</span>show ()<span class='o'>;</span>
  <span class='m'>Main</span><span class='o'>.</span>main ()

<span class='k'>let</span> () <span class='k'>=</span> main ()
</code></pre>
<p>
Save this to a file <code>simple.ml</code> and compile it like this:</p>
<pre><code class='ocaml'><script>val ml148782b5a19d03ffdbbf70c55e79ac74 = 'ocamlc -g -w s -I +lablgtk lablgtk.cma gtkInit.cmo simple.ml -o simple&#10;';</script>ocamlc <span class='o'>-</span>g <span class='o'>-</span>w s <span class='o'>-</span>I <span class='o'>+</span>lablgtk lablgtk<span class='o'>.</span>cma gtkInit<span class='o'>.</span>cmo simple<span class='o'>.</span>ml <span class='o'>-</span>o simple
</code></pre>
<p>
This is what you should see when you run it:</p>
<p><img src='../img/simplee29b.gif' alt='Simple lablgtk program' /></p>
<p>Let&#39;s analyse the program line by line to see what&#39;s going on.</p>
<pre><code class='ocaml'><script>val ml035ab4649518f848ccdf318823f863d2 = 'open GMain&#10;open GdkKeysyms&#10;';</script><span class='k'>open</span> GMain
<span class='k'>open</span> GdkKeysyms
</code></pre>
<p>
<code>GMain</code> provides useful functions like the Gtk main loop, so I find it a
good idea to always open this module. <code>GdkKeysyms</code> provides some key
definitions, in this case <code>_Q</code> for the Ctrl + Q key combination.</p>
<pre><code class='ocaml'><script>val mledb908eda2585d3786a3bd367434cff4 = '  let window = GWindow.window ~width:320 ~height:240&#10;                 ~title:&#34;Simple lablgtk program&#34; () in&#10;  let vbox = GPack.vbox ~packing:window#add () in&#10;  window#connect#destroy ~callback:Main.quit;&#10;';</script>  <span class='k'>let</span> window <span class='k'>=</span> <span class='m'>GWindow</span><span class='o'>.</span>window <span class='o'>~</span>width<span class='o'>:</span>320 <span class='o'>~</span>height<span class='o'>:</span>240
                 <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;Simple lablgtk program&#34;</span> () <span class='k'>in</span>
  <span class='k'>let</span> vbox <span class='k'>=</span> <span class='m'>GPack</span><span class='o'>.</span>vbox <span class='o'>~</span>packing<span class='o'>:</span>window<span class='o'>#</span>add () <span class='k'>in</span>
  window<span class='o'>#</span>connect<span class='o'>#</span>destroy <span class='o'>~</span>callback<span class='o'>:</span><span class='m'>Main</span><span class='o'>.</span>quit<span class='o'>;</span>
</code></pre>
<p>
Firstly we create the toplevel window. Every Gtk program needs at least
one. Notice three things: firstly <code>GWindow.window</code> is actually a helper
function which creates a <code>window</code> object for you. For various reasons
which we&#39;ll discuss in the intensive section at the end of this chapter,
you shouldn&#39;t create lablgtk objects using <code>new classname arguments...</code>,
but instead use one of these helper functions. The helper functions are
often named the same as the class which they create. Secondly lablgtk
makes extensive use of the <code>~label</code> (labelled and optional arguments).
You&#39;ll get used to this quickly. Thirdly see the apparently useless <code>()</code>
(unit) argument to <code>GWindow.window</code>. It&#39;s actually not useless, but the
only way for OCaml to tell the difference between a partial and full
function application in the presence of optional arguments.</p>
<p>A <code>vbox</code> is a vertical layout widget. It&#39;s a container which contains
other widgets but isn&#39;t normally visible by itself. The <code>~packing</code>
argument looks odd (indeed it is). It&#39;s just a shorthand way of writing:</p>
<pre><code class='ocaml'><script>val ml63fae5da21a1ac6cc0554afc285c45f4 = '  let vbox = GPack.vbox () in&#10;  window#add vbox;&#10;';</script>  <span class='k'>let</span> vbox <span class='k'>=</span> <span class='m'>GPack</span><span class='o'>.</span>vbox () <span class='k'>in</span>
  window<span class='o'>#</span>add vbox<span class='o'>;</span>
</code></pre>
<p>
The two forms are, as far as I can tell, identical. The first way is a
bit shorter.</p>
<p><code>window#connect#destroy ~callback:Main.quit;</code> is an example of
connecting a <em>signal</em> to a function. In this case the <code>destroy</code> signal,
received by the window when someone presses the &quot;X&quot; in the corner, will
cause a call to <code>Main.quit ()</code> (note extra unit arg).</p>
<p>Creating the menubar and File -\&gt; Quit button is straightforward enough.
Notice the <code>accel_group</code> object which is used to keep track of
accelerator buttons. The <code>menubar</code> is packed first into the <code>vbox</code>:</p>
<pre><code class='ocaml'><script>val mle5e3ae0cb0261fc70d17d6a87aa21a55 = '  (* Menu bar *)&#10;  let menubar = GMenu.menu_bar ~packing:vbox#pack () in&#10;  let factory = new GMenu.factory menubar in&#10;  let accel_group = factory#accel_group in&#10;  let file_menu = factory#add_submenu &#34;File&#34; in&#10;&#10;  (* File menu *)&#10;  let factory = new GMenu.factory file_menu ~accel_group in&#10;  factory#add_item &#34;Quit&#34; ~key:_Q ~callback: Main.quit;&#10;';</script>  <span class='com2'>(* Menu bar *)</span><!-- end comment -->
  <span class='k'>let</span> menubar <span class='k'>=</span> <span class='m'>GMenu</span><span class='o'>.</span>menu_bar <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>pack () <span class='k'>in</span>
  <span class='k'>let</span> factory <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GMenu</span><span class='o'>.</span>factory menubar <span class='k'>in</span>
  <span class='k'>let</span> accel_group <span class='k'>=</span> factory<span class='o'>#</span>accel_group <span class='k'>in</span>
  <span class='k'>let</span> file_menu <span class='k'>=</span> factory<span class='o'>#</span>add_submenu <span class='s'>&#34;File&#34;</span> <span class='k'>in</span>

  <span class='com2'>(* File menu *)</span><!-- end comment -->
  <span class='k'>let</span> factory <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GMenu</span><span class='o'>.</span>factory file_menu <span class='o'>~</span>accel_group <span class='k'>in</span>
  factory<span class='o'>#</span>add_item <span class='s'>&#34;Quit&#34;</span> <span class='o'>~</span>key<span class='o'>:_</span>Q <span class='o'>~</span>callback<span class='o'>:</span> <span class='m'>Main</span><span class='o'>.</span>quit<span class='o'>;</span>
</code></pre>
<p>
Next up we create the button and pack it in the <code>vbox</code>. Notice the
<code>clicked</code> signal which is connected to an anonymous function:</p>
<pre><code class='ocaml'><script>val mlb5e67a2d92934ab41734ed025f4743fe = '  (* Button *)&#10;  let button = GButton.button ~label:&#34;Push me!&#34;&#10;                 ~packing:vbox#add () in&#10;  button#connect#clicked ~callback: (fun () -&#62; prerr_endline &#34;Ouch!&#34;);&#10;';</script>  <span class='com2'>(* Button *)</span><!-- end comment -->
  <span class='k'>let</span> button <span class='k'>=</span> <span class='m'>GButton</span><span class='o'>.</span>button <span class='o'>~</span>label<span class='o'>:</span><span class='s'>&#34;Push me!&#34;</span>
                 <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>add () <span class='k'>in</span>
  button<span class='o'>#</span>connect<span class='o'>#</span>clicked <span class='o'>~</span>callback<span class='o'>:</span> (<span class='k'>fun</span> () <span class='k'>-></span> prerr_endline <span class='s'>&#34;Ouch!&#34;</span>)<span class='o'>;</span>
</code></pre>
<p>
This line just causes the accelerator keys (eg. Ctrl Q) to work:</p>
<pre><code class='ocaml'><script>val mlc78f83f13814f95eb0976c6a19cd6a4d = '  window#add_accel_group accel_group;&#10;';</script>  window<span class='o'>#</span>add_accel_group accel_group<span class='o'>;</span>
</code></pre>
<p>
Finally two lines which are essential. All Gtk widgets must be &quot;shown&quot;
before they will appear, by calling the <code>#show</code> method. However lablgtk,
by default, automatically shows all widgets <em>except</em> toplevel windows.
Thus we need to call <code>window#show ()</code> explicitly. <code>Main.main ()</code> is the
Gtk main loop - the bit which runs and handles events. Gtk is event
driven so everything else happens in a callback as a result of some
signal received.</p>
<pre><code class='ocaml'><script>val ml1f6c9711c43ab6e937a13f876e0d69ac = '  window#show ();&#10;  Main.main ()&#10;';</script>  window<span class='o'>#</span>show ()<span class='o'>;</span>
  <span class='m'>Main</span><span class='o'>.</span>main ()
</code></pre>
<h3 id="Gtktutorial"> Gtk tutorial</h3><p>

Read <a href='http://www.gtk.org/tutorial1.2/' title='http://www.gtk.org/tutorial1.2/'>this Gtk
tutorial</a>
to find out more about Gtk. Lablgtk contains a pretty complete mapping
of the Gtk+ API.</p>
<h3 id="Graphwidget"> Graph widget</h3><p>
Now we&#39;re going to get a little bit more adventurous and write our own
widget. This is going to be a simple graph, with a scrollbar at the
bottom allowing you to scroll left and right through the data. The graph
itself is going to be drawn on a Gtk drawing area widget. The Gtk
drawing area is very simple, just an empty space in which you can
execute your own drawing commands to draw lines, rectangles, text and so
on.</p>
<p>Before starting we need to think about the overall structure of our
graph widget. I&#39;m going to have it be a vbox, with the drawing area in
the top part, and the scrollbar in the bottom part. This is the overall
structure of our class:</p>
<pre><code class='ocaml'><script>val ml027ecd574bef82e8d8a84c26797c7749 = 'class graph ?width ?height ?packing ?show array =&#10;  (* The initialization code will go here. *)&#10;&#10;  object (self)&#10;    inherit widget vbox#as_widget&#10;&#10;    (* Methods will go here. *)&#10;&#10;    method init =&#10;      (* Further initialization will go here. *)&#10;  end&#10;';</script><span class='k'>class</span> graph <span class='o'>?</span>width <span class='o'>?</span>height <span class='o'>?</span>packing <span class='o'>?</span>show array <span class='k'>=</span>
  <span class='com2'>(* The initialization code will go here<span class='ic'>.</span> *)</span><!-- end comment -->

  object (self)
    <span class='k'>inherit</span> widget vbox<span class='o'>#</span>as_widget

    <span class='com2'>(* Methods will go here<span class='ic'>.</span> *)</span><!-- end comment -->

    <span class='k'>method</span> init <span class='k'>=</span>
      <span class='com2'>(* Further initialization will go here<span class='ic'>.</span> *)</span><!-- end comment -->
  <span class='k'>end</span>
</code></pre>
<p>
To create a widget you will do:</p>
<pre><code class='ocaml'><script>val mlabc689f761f274b5dbff673e51dd55c8 = 'let graph = new graph in&#10;graph#init;&#10;';</script><span class='k'>let</span> graph <span class='k'>=</span> <span class='k'>new</span> graph <span class='k'>in</span>
graph<span class='o'>#</span>init<span class='o'>;</span>
</code></pre>
<p>
Note the two-stage initialization process. This is actually an
unfortunate hack. You&#39;ll see why it&#39;s necessary once we start to fill in
the code. Perhaps a reader can suggest a way around this?</p>
<p>The <code>inherit widget vbox#as_widget</code> is interesting. You&#39;ll have to read
the section below entited <em>Structure of lablgtk</em> to understand it fully,
but basically it causes a graph to be a subclass of widget.</p>
<p>Let&#39;s have a look at the initialization code in more detail.</p>
<pre><code class='ocaml'><script>val ml266f853b0f2d1afe1720240181827222 = 'class graph ?width ?height ?packing ?show array =&#10;  (* Constants. *)&#10;  let page_size = 10 in            (* Number of bars on &#34;page&#34;. *)&#10;  let max_y = 10 in                (* Maximum on Y scale. *)&#10;&#10;  (* Number of data points. *)&#10;  let array_size = Array.length array in&#10;&#10;  (* Create the containing vbox. *)&#10;  let vbox = GPack.vbox ?width ?height ?packing ?show () in&#10;&#10;  (* Create the drawing area. *)&#10;  let da = GMisc.drawing_area ~packing:vbox#add () in&#10;  let drawable = lazy (new GDraw.drawable da#misc#window) in&#10;&#10;  (* Create the scrollbar. *)&#10;  let adjustment = GData.adjustment&#10;                     ~lower:0. ~upper:(float_of_int (array_size-1))&#10;                     ~step_incr:1. ~page_incr:(float_of_int page_size) () in&#10;  let scrollbar =&#10;    GRange.scrollbar `HORIZONTAL ~adjustment ~packing:vbox#pack () in&#10;&#10;  object (self)&#10;    inherit widget vbox#as_widget&#10;&#10;    (* Methods will go here. *)&#10;&#10;    method private repaint () =&#10;      (* Repaint the widget. See below. *)&#10;&#10;    method init =&#10;      da#event#connect#expose&#10;        ~callback:(fun _ -&#62; self#repaint (); false);&#10;      adjustment#connect#value_changed&#10;        ~callback:(fun _ -&#62; self#repaint ())&#10;&#10;  end&#10;';</script><span class='k'>class</span> graph <span class='o'>?</span>width <span class='o'>?</span>height <span class='o'>?</span>packing <span class='o'>?</span>show array <span class='k'>=</span>
  <span class='com2'>(* <span class='ic'>Constants</span><span class='ic'>.</span> *)</span><!-- end comment -->
  <span class='k'>let</span> page_size <span class='k'>=</span> 10 <span class='k'>in</span>            <span class='com2'>(* Number <span class='ic'>of</span> bars on <span class='ic'>&#34;page&#34;</span><span class='ic'>.</span> *)</span><!-- end comment -->
  <span class='k'>let</span> max_y <span class='k'>=</span> 10 <span class='k'>in</span>                <span class='com2'>(* Maximum on Y scale<span class='ic'>.</span> *)</span><!-- end comment -->

  <span class='com2'>(* Number <span class='ic'>of</span> data points<span class='ic'>.</span> *)</span><!-- end comment -->
  <span class='k'>let</span> array_size <span class='k'>=</span> <span class='m'>Array</span><span class='o'>.</span>length array <span class='k'>in</span>

  <span class='com2'>(* Create the containing vbox<span class='ic'>.</span> *)</span><!-- end comment -->
  <span class='k'>let</span> vbox <span class='k'>=</span> <span class='m'>GPack</span><span class='o'>.</span>vbox <span class='o'>?</span>width <span class='o'>?</span>height <span class='o'>?</span>packing <span class='o'>?</span>show () <span class='k'>in</span>

  <span class='com2'>(* Create the drawing area<span class='ic'>.</span> *)</span><!-- end comment -->
  <span class='k'>let</span> da <span class='k'>=</span> <span class='m'>GMisc</span><span class='o'>.</span>drawing_area <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>add () <span class='k'>in</span>
  <span class='k'>let</span> drawable <span class='k'>=</span> <span class='k'>lazy</span> (<span class='k'>new</span> <span class='m'>GDraw</span><span class='o'>.</span>drawable da<span class='o'>#</span>misc<span class='o'>#</span>window) <span class='k'>in</span>

  <span class='com2'>(* Create the scrollbar<span class='ic'>.</span> *)</span><!-- end comment -->
  <span class='k'>let</span> adjustment <span class='k'>=</span> <span class='m'>GData</span><span class='o'>.</span>adjustment
                     <span class='o'>~</span>lower<span class='o'>:</span>0. <span class='o'>~</span>upper<span class='o'>:</span>(float_of_int (array_size-1))
                     <span class='o'>~</span>step_incr<span class='o'>:</span>1. <span class='o'>~</span>page_incr<span class='o'>:</span>(float_of_int page_size) () <span class='k'>in</span>
  <span class='k'>let</span> scrollbar <span class='k'>=</span>
    <span class='m'>GRange</span><span class='o'>.</span>scrollbar `HORIZONTAL <span class='o'>~</span>adjustment <span class='o'>~</span>packing<span class='o'>:</span>vbox<span class='o'>#</span>pack () <span class='k'>in</span>

  object (self)
    <span class='k'>inherit</span> widget vbox<span class='o'>#</span>as_widget

    <span class='com2'>(* Methods will go here<span class='ic'>.</span> *)</span><!-- end comment -->

    <span class='k'>method</span> <span class='k'>private</span> repaint () <span class='k'>=</span>
      <span class='com2'>(* Repaint the widget<span class='ic'>.</span> See below<span class='ic'>.</span> *)</span><!-- end comment -->

    <span class='k'>method</span> init <span class='k'>=</span>
      da<span class='o'>#</span>event<span class='o'>#</span>connect<span class='o'>#</span>expose
        <span class='o'>~</span>callback<span class='o'>:</span>(<span class='k'>fun</span> <span class='o'>_</span> <span class='k'>-></span> self<span class='o'>#</span>repaint ()<span class='o'>;</span> <span class='o'>false</span>)<span class='o'>;</span>
      adjustment<span class='o'>#</span>connect<span class='o'>#</span>value_changed
        <span class='o'>~</span>callback<span class='o'>:</span>(<span class='k'>fun</span> <span class='o'>_</span> <span class='k'>-></span> self<span class='o'>#</span>repaint ())

  <span class='k'>end</span>
</code></pre>
<p>
The let-bindings before the start of <code>object</code> define constants such as
<code>page_size</code>, but also create the Gtk objects like vbox, drawing area,
scrollbar and adjustment. (An adjustment is an abstract object which
records the position of a scrollbar. Notice how in the <code>init</code> method we
attach a signal to the adjustment so that when the scrollbar moves (ie.
adjustment changes) we repaint the whole widget.) The private <code>repaint</code>
method is where the action is, as it were. That method will actually be
responsible for drawing the graph, axes, title and so on.</p>
<p>We&#39;ll see that in just a moment, but let&#39;s concentrate on the simpler
methods of the object first:</p>
<pre><code class='ocaml'><script>val mlc830da979c84331e3f682ffb41f08192 = '  object (self)&#10;    inherit widget vbox#as_widget&#10;&#10;    (* The title of the graph. *)&#10;    val mutable title = &#34;no title&#34;&#10;    method set_title t = title &#60;- t&#10;    method title = title&#10;&#10;    (* ... *)&#10;  end&#10;';</script>  object (self)
    <span class='k'>inherit</span> widget vbox<span class='o'>#</span>as_widget

    <span class='com2'>(* The title <span class='ic'>of</span> the graph<span class='ic'>.</span> *)</span><!-- end comment -->
    <span class='k'>val</span> <span class='k'>mutable</span> title <span class='k'>=</span> <span class='s'>&#34;no title&#34;</span>
    <span class='k'>method</span> set_title t <span class='k'>=</span> title <span class='o'>&#60;-</span> t
    <span class='k'>method</span> title <span class='k'>=</span> title

    <span class='com2'>(* <span class='ic'>...</span> *)</span><!-- end comment -->
  <span class='k'>end</span>
</code></pre>
<p>
The object is going to contain a mutable member, the title, and two
methods to <code>set_title</code> and get <code>title</code>.</p>
<p>Now we come to the repaint method, which is the guts of the widget. This
draws the graph in the drawing area:</p>
<pre><code class='ocaml'><script>val ml12788e8cdd4b70a96420c6c8ef3e2265 = '    (* Repaint the widget. *)&#10;    method private repaint () =&#10;      let drawable = Lazy.force drawable in&#10;      let (width, height) = drawable#size in&#10;      drawable#set_background `WHITE;&#10;      drawable#set_foreground `WHITE;&#10;      drawable#rectangle ~x:0 ~y:0 ~width ~height ~filled:true ();&#10;      drawable#set_foreground `BLACK;&#10;&#10;      (* Draw the title. *)&#10;      draw_text drawable font `Centre (width/2, 20) title;&#10;&#10;      (* Draw the axes. *)&#10;      drawable#line ~x:40 ~y:(height-40) ~x:(width-40) ~y:(height-40);&#10;      drawable#line ~x:40 ~y:(height-40) ~x:40 ~y:40;&#10;&#10;      (* Which part of the data to display? first .. first+page_size-1 *)&#10;      let first_bar = int_of_float adjustment#value in&#10;      let data = Array.sub array first_bar page_size in&#10;      let bar_width = (width - 80) / page_size in&#10;&#10;      (* Compute function mapping graph (x, y) to screen coordinates. *)&#10;      let map (x,y) =&#10;        (40 + x * bar_width, height-40 - y * (height-80) / max_y)  in&#10;&#10;      (* Draw the axes scales. *)&#10;      draw_text drawable font `Right (40, height-40) &#34;0&#34;;&#10;      draw_text drawable font `Right (40, 40) (string_of_int max_y);&#10;      for i = 0 to page_size-1 do&#10;        let x = 40 + i * bar_width + bar_width/2 in&#10;        let y = height-35 in&#10;        let v = first_bar + i in&#10;        draw_text drawable font `Centre (x, y) (string_of_int v)&#10;      done;&#10;&#10;      (* Draw the data. *)&#10;      for i = 0 to page_size-1 do&#10;        let (ll_x,ll_y) = map (i, data.(i)) in&#10;        let (tr_x,tr_y) = map (i+1, 0) in&#10;        draw_rectangle drawable &#34;red&#34; (ll_x, ll_y) (tr_x, tr_y)&#10;      done&#10;';</script>    <span class='com2'>(* Repaint the widget<span class='ic'>.</span> *)</span><!-- end comment -->
    <span class='k'>method</span> <span class='k'>private</span> repaint () <span class='k'>=</span>
      <span class='k'>let</span> drawable <span class='k'>=</span> <span class='m'>Lazy</span><span class='o'>.</span>force drawable <span class='k'>in</span>
      <span class='k'>let</span> (width<span class='o'>,</span> height) <span class='k'>=</span> drawable<span class='o'>#</span>size <span class='k'>in</span>
      drawable<span class='o'>#</span>set_background `WHITE<span class='o'>;</span>
      drawable<span class='o'>#</span>set_foreground `WHITE<span class='o'>;</span>
      drawable<span class='o'>#</span>rectangle <span class='o'>~</span>x<span class='o'>:</span>0 <span class='o'>~</span>y<span class='o'>:</span>0 <span class='o'>~</span>width <span class='o'>~</span>height <span class='o'>~</span>filled<span class='o'>:</span><span class='o'>true</span> ()<span class='o'>;</span>
      drawable<span class='o'>#</span>set_foreground `BLACK<span class='o'>;</span>

      <span class='com2'>(* Draw the title<span class='ic'>.</span> *)</span><!-- end comment -->
      draw_text drawable font `Centre (width<span class='o'>/</span>2<span class='o'>,</span> 20) title<span class='o'>;</span>

      <span class='com2'>(* Draw the axes<span class='ic'>.</span> *)</span><!-- end comment -->
      drawable<span class='o'>#</span>line <span class='o'>~</span>x<span class='o'>:</span>40 <span class='o'>~</span>y<span class='o'>:</span>(height-40) <span class='o'>~</span>x<span class='o'>:</span>(width-40) <span class='o'>~</span>y<span class='o'>:</span>(height-40)<span class='o'>;</span>
      drawable<span class='o'>#</span>line <span class='o'>~</span>x<span class='o'>:</span>40 <span class='o'>~</span>y<span class='o'>:</span>(height-40) <span class='o'>~</span>x<span class='o'>:</span>40 <span class='o'>~</span>y<span class='o'>:</span>40<span class='o'>;</span>

      <span class='com2'>(* Which part <span class='ic'>of</span> the data <span class='ic'>to</span> display? first <span class='ic'>..</span> first<span class='ic'>+</span>page_size-1 *)</span><!-- end comment -->
      <span class='k'>let</span> first_bar <span class='k'>=</span> int_of_float adjustment<span class='o'>#</span>value <span class='k'>in</span>
      <span class='k'>let</span> data <span class='k'>=</span> <span class='m'>Array</span><span class='o'>.</span>sub array first_bar page_size <span class='k'>in</span>
      <span class='k'>let</span> bar_width <span class='k'>=</span> (width <span class='o'>-</span> 80) <span class='o'>/</span> page_size <span class='k'>in</span>

      <span class='com2'>(* Compute <span class='ic'>function</span> mapping graph (x<span class='ic'>,</span> y) <span class='ic'>to</span> screen coordinates<span class='ic'>.</span> *)</span><!-- end comment -->
      <span class='k'>let</span> map (x<span class='o'>,</span>y) <span class='k'>=</span>
        (40 <span class='o'>+</span> x <span class='o'>*</span> bar_width<span class='o'>,</span> height-40 <span class='o'>-</span> y <span class='o'>*</span> (height-80) <span class='o'>/</span> max_y)  <span class='k'>in</span>

      <span class='com2'>(* Draw the axes scales<span class='ic'>.</span> *)</span><!-- end comment -->
      draw_text drawable font `Right (40<span class='o'>,</span> height-40) <span class='s'>&#34;0&#34;</span><span class='o'>;</span>
      draw_text drawable font `Right (40<span class='o'>,</span> 40) (string_of_int max_y)<span class='o'>;</span>
      <span class='k'>for</span> i <span class='k'>=</span> 0 <span class='k'>to</span> page_size-1 <span class='k'>do</span>
        <span class='k'>let</span> x <span class='k'>=</span> 40 <span class='o'>+</span> i <span class='o'>*</span> bar_width <span class='o'>+</span> bar_width<span class='o'>/</span>2 <span class='k'>in</span>
        <span class='k'>let</span> y <span class='k'>=</span> height-35 <span class='k'>in</span>
        <span class='k'>let</span> v <span class='k'>=</span> first_bar <span class='o'>+</span> i <span class='k'>in</span>
        draw_text drawable font `Centre (x<span class='o'>,</span> y) (string_of_int v)
      <span class='k'>done</span><span class='o'>;</span>

      <span class='com2'>(* Draw the data<span class='ic'>.</span> *)</span><!-- end comment -->
      <span class='k'>for</span> i <span class='k'>=</span> 0 <span class='k'>to</span> page_size-1 <span class='k'>do</span>
        <span class='k'>let</span> (ll_x<span class='o'>,</span>ll_y) <span class='k'>=</span> map (i<span class='o'>,</span> data<span class='o'>.</span>(i)) <span class='k'>in</span>
        <span class='k'>let</span> (tr_x<span class='o'>,</span>tr_y) <span class='k'>=</span> map (i<span class='o'>+</span>1<span class='o'>,</span> 0) <span class='k'>in</span>
        draw_rectangle drawable <span class='s'>&#34;red&#34;</span> (ll_x<span class='o'>,</span> ll_y) (tr_x<span class='o'>,</span> tr_y)
      <span class='k'>done</span>
</code></pre>
<p>
Apart from the calculation of screen coordinates from graph coordinates,
the <code>repaint</code> method is essentially very simple. The Gtk drawing area
contains a <code>drawable</code> object, and we use methods on this object such as
<code>drawable#line</code> plus some helper functions which I haven&#39;t reproduced
here to draw in the drawing area. It&#39;s really just a matter of
calculating what to draw, where. Notice how we freely access
let-bindings made before <code>object (self)</code>, eg. <code>page_size</code>, <code>drawable</code>,
<code>adjustment</code>. These let-bindings are available in any method in the
object.</p>
<p>The complete code for the graph is available in \&lt;a
href=&quot;graph.ml&quot;\&gt;graph.ml\&lt;/a\&gt; and \&lt;a href=&quot;test.ml&quot;\&gt;test.ml\&lt;/a\&gt;.
Compile it using:</p>
<pre><code class='ocaml'><script>val ml37dbdf05de8ee222b165d48a245b8d56 = 'ocamlc -g -w s -I +lablgtk lablgtk.cma gtkInit.cmo graph.ml test.ml -o graphtest&#10;';</script>ocamlc <span class='o'>-</span>g <span class='o'>-</span>w s <span class='o'>-</span>I <span class='o'>+</span>lablgtk lablgtk<span class='o'>.</span>cma gtkInit<span class='o'>.</span>cmo graph<span class='o'>.</span>ml test<span class='o'>.</span>ml <span class='o'>-</span>o graphtest
</code></pre>
<p>
Here is a screenshot:</p>
<p>\&lt;img src=&quot;graphtest.gif&quot; width=&quot;648&quot; height=&quot;508&quot; alt=&quot;Screenshot&quot;/\&gt;</p>
<h3 id="Structureoflablgtk"> Structure of lablgtk</h3><p>
The lablgtk library has two layers, which I&#39;m going to call the <em>module
layer</em> and the <em>object-oriented layer</em> (plus some ancillary library
modules which we&#39;ll also talk about). The layers are arranged like this
in relation to your code:</p>
<table>
<tbody>
<tr class="odd">
<td align="left">Your code</td>
</tr>
<tr class="even">
<td align="left">Object-oriented layer</td>
<td align="left">eg. gButton.ml</td>
</tr>
<tr class="odd">
<td align="left">Module layer</td>
<td align="left">eg. gtkButton.ml<br />ml_gtkbutton.c</td>
</tr>
<tr class="even">
<td align="left">Gtk+ library (or DLL on Windows)</td>
</tr>
</tbody>
</table>
<p>In theory you only need to interact with the object-oriented layer, and
the theory is indeed true for trivial programs. However for practical
purposes you will need to understand how the library is built up from
these layers (and why).</p>
<h4 id="Gtkobjects"> Gtk objects</h4><p>
We&#39;ll start with the peculiarities of Gtk itself. This library is
written in C and uses macros and &quot;clever&quot; hacks to (a) present an OO-ish
interface and (b) perform simple garbage collection through reference
counting. Part of the reason why lablgtk uses quite a complex model is
to cater for the implementation of Gtk itself.</p>
<p>All &quot;objects&quot; in the Gtk library (I&#39;ll call them objects, but in reality
they&#39;re C <code>struct</code>s) are &quot;derived&quot; from <code>GtkObject</code>. This means that an
object such as a button contains within its <code>struct</code> a
<code>struct _GtkObject</code>. This &quot;base class&quot; contains, amongst other things, a
reference count which is used to provide simple garbage collection.</p>
<p>Of course, the above is all in the context of a C library for C
programmers. OCaml has other mechanisms for OO and contains an advanced
garbage collector. How does lablgtk unify the two?</p>
<p>Lablgtk starts with this type definition (in module <code>Gtk</code>):</p>
<pre><code class='ocaml'><script>val ml9059372339c531c60f7927ef97ca1c0a = 'type &#39;a obj;;&#10;';</script><span class='k'>type</span> 'a obj<span class='o'>;;</span>
</code></pre>
<p>
On the face of it, this is a <em>very</em> strange type definition. It defines
a polymorphic type called <code>obj</code> (polymorphic because you can create,
say, <code>int obj</code>, etc.). But it doesn&#39;t actually define a way of creating
these objects! [Recall that a normal type definition might be something
like this:</p>
<pre><code class='ocaml'><script>val ml59f63f4dde499ec099756f6e76bbca28 = 'type &#39;a obj = Something of &#39;a&#10;';</script><span class='k'>type</span> 'a obj <span class='k'>=</span> Something <span class='k'>of</span> 'a
</code></pre>
<p>
which gives you a very definite way to create, say, an <code>int obj</code>:</p>
<pre><code class='ocaml'><script>val ml29b77b513052867ee6b87f5bae1723f3 = 'Something 1&#10;';</script>Something 1
</code></pre>
<p>
But our strange, bare definition just says:</p>
<pre><code class='ocaml'><script>val ml9059372339c531c60f7927ef97ca1c0a = 'type &#39;a obj;;&#10;';</script><span class='k'>type</span> 'a obj<span class='o'>;;</span>
</code></pre>
<p>
How do we create objects of this type? The answer is that we don&#39;t.
Instances of type <code>&#39;a obj</code> are <code>GtkObject</code> structures (actually, more
likely they are &quot;subclasses&quot; of <code>GtkObject</code>), and they are created by
the C library. What precisely happens is that the C functions in the
Gtk+ library are wrapped up by C functions which are called from OCaml.
These functions look like this:</p>
<pre><code class='ocaml'><script>val mld9d2ad4cf8bcc26d3d1b442680d9c141 = 'CAMLprim value&#10;ml_gtk_toggle_button_new (value unit)&#10;{&#10;  return Val_GtkObject_sink ((GtkObject *) gtk_toggle_button_new ());&#10;}&#10;';</script>CAMLprim value
ml_gtk_toggle_button_new (value unit)
<span class='o'>{</span>
  return Val_GtkObject_sink ((GtkObject *)</span> gtk_toggle_button_new ())<span class='other'>;</span>
<span class='other'>}</span>
</code></pre>
<p>
<code>Val_GtkObject_sink</code> is a very complex little function which wraps up
the <code>GtkObject</code> returned from the Gtk+ library function
<code>gtk_toggle_button_new ()</code> in something that OCaml&#39;s garbage collector
can understand. The same function also deals with Gtk&#39;s reference
counting.</p>
<pre><code class='ocaml'><script>val ml284f1e09acb097b44a5224e3fe9993b9 = 'static void ml_final_GtkObject_sink (value val) {&#10;  if (Field(val,1))&#10;    gtk_object_unref ((GtkObject*)Field(val,1));&#10;}&#10;&#10;value Val_GtkObject_sink (GtkObject *p) {&#10;  value ret;&#10;  if (!p) ml_raise_null_pointer ();&#10;  ret = alloc_final (2, ml_final_GtkObject_sink, 20, 1000);&#10;  initialize (&#38;Field(ret,1), (value) p);&#10;  gtk_object_ref_and_sink(p);&#10;  return ret;&#10;}&#10;';</script>static void ml_final_GtkObject_sink (value <span class='k'>val</span>) <span class='o'>{</span>
  <span class='k'>if</span> (Field(<span class='k'>val</span><span class='o'>,</span>1))
    gtk_object_unref ((GtkObject*)</span>Field(<span class='other'>val</span><span class='other'>,</span>1))<span class='other'>;</span>
<span class='other'>}</span>

value Val_GtkObject_sink (GtkObject <span class='other'>*</span>p) <span class='other'>{</span>
  value ret<span class='other'>;</span>
  <span class='other'>if</span> <span class='other'>(!</span>p) ml_raise_null_pointer ()<span class='other'>;</span>
  ret <span class='other'>=</span> alloc_final (2<span class='other'>,</span> ml_final_GtkObject_sink<span class='other'>,</span> 20<span class='other'>,</span> 1000)<span class='other'>;</span>
  initialize <span class='other'>(&#38;</span>Field(ret<span class='other'>,</span>1)<span class='other'>,</span> (value) p)<span class='other'>;</span>
  gtk_object_ref_and_sink(p)<span class='other'>;</span>
  return ret<span class='other'>;</span>
<span class='other'>}</span>
</code></pre>
<p>
OCaml code calls <code>ml_gtk_toggle_button_new</code> directly to create objects
of type <code>&#39;a obj</code>. Module <code>GtkButton</code> is in lablgtk&#39;s module layer and it
contains an inner module called <code>GtkButton.ToggleButton</code> containing a
function defined as:</p>
<pre><code class='ocaml'><script>val mlf39bc1c2656291b52d337f9e16f6a568 = 'module ToggleButton = struct&#10;  external toggle_button_create : unit -&#62; toggle_button obj&#10;      = &#34;ml_gtk_toggle_button_new&#34;&#10;  external toggle_button_create_with_label : string -&#62; toggle_button obj&#10;      = &#34;ml_gtk_toggle_button_new_with_label&#34;&#10;  let create_toggle ?label () =&#10;    match label with&#10;    | None -&#62; toggle_button_create ()&#10;    | Some label -&#62; toggle_button_create_with_label label&#10;end&#10;';</script><span class='k'>module</span> ToggleButton <span class='k'>=</span> <span class='k'>struct</span>
  <span class='k'>external</span> toggle_button_create <span class='o'>:</span> unit <span class='k'>-></span> toggle_button obj
      <span class='k'>=</span> <span class='s'>&#34;ml_gtk_toggle_button_new&#34;</span>
  <span class='k'>external</span> toggle_button_create_with_label <span class='o'>:</span> string <span class='k'>-></span> toggle_button obj
      <span class='k'>=</span> <span class='s'>&#34;ml_gtk_toggle_button_new_with_label&#34;</span>
  <span class='k'>let</span> create_toggle <span class='o'>?</span>label () <span class='k'>=</span>
    <span class='k'>match</span> label <span class='k'>with</span>
    <span class='o'>|</span> None <span class='k'>-></span> toggle_button_create ()
    <span class='o'>|</span> Some label <span class='k'>-></span> toggle_button_create_with_label label
<span class='k'>end</span>
</code></pre>
<p>
You can call these functions directly to see what they return:</p>
<pre><code class='ocaml'><script>val ml710b3adb5104b9abf4186e626e66ccd3 = '# GtkButton.ToggleButton.toggle_button_create ();;&#10;- : Gtk.toggle_button Gtk.obj = &#60;abstr&#62;&#10;# GtkButton.ToggleButton.create_toggle ~label:&#34;Push me!&#34; ();;&#10;- : Gtk.toggle_button Gtk.obj = &#60;abstr&#62;&#10;';</script><span class='o'>#</span> <span class='m'>GtkButton</span><span class='o'>.</span><span class='m'>ToggleButton</span><span class='o'>.</span>toggle_button_create ()<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> <span class='m'>Gtk</span><span class='o'>.</span>toggle_button <span class='m'>Gtk</span><span class='o'>.</span>obj <span class='k'>=</span> <span class='o'>&#60;</span>abstr<span class='o'>&#62;</span>
<span class='o'>#</span> <span class='m'>GtkButton</span><span class='o'>.</span><span class='m'>ToggleButton</span><span class='o'>.</span>create_toggle <span class='o'>~</span>label<span class='o'>:</span><span class='s'>&#34;Push me!&#34;</span> ()<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> <span class='m'>Gtk</span><span class='o'>.</span>toggle_button <span class='m'>Gtk</span><span class='o'>.</span>obj <span class='k'>=</span> <span class='o'>&#60;</span>abstr<span class='o'>&#62;</span>
</code></pre>
<p>
Notice the return type: <code>toggle_button obj</code> (ie. a definite instance of
the polymorphic type <code>&#39;a obj</code>). What is <code>toggle_button</code>? It&#39;s a type
(think <code>&#39;a list</code> vs. <code>int list</code>) defined like this (in module <code>Gtk</code>):</p>
<pre><code class='ocaml'><script>val ml68db3ca83299f75a34c9a0a3940479a2 = 'type widget = [`base|`widget]&#10;type container = [widget|`container]&#10;type button = [container|`button]&#10;type toggle_button = [button|`toggle]&#10;';</script><span class='k'>type</span> widget <span class='k'>=</span> <span class='o'>[</span>`base<span class='o'>|</span>`widget<span class='o'>]</span>
<span class='k'>type</span> container <span class='k'>=</span> <span class='o'>[</span>widget<span class='o'>|</span>`container<span class='o'>]</span>
<span class='k'>type</span> button <span class='k'>=</span> <span class='o'>[</span>container<span class='o'>|</span>`button<span class='o'>]</span>
<span class='k'>type</span> toggle_button <span class='k'>=</span> <span class='o'>[</span>button<span class='o'>|</span>`toggle<span class='o'>]</span>
</code></pre>
<p>
Hence the full type written out is:</p>
<pre><code class='ocaml'><script>val mlbbba46e073cf884cbb78aa0f3a9e375b = 'type toggle_button = [`base|`widget|`container|`button|`toggle]&#10;';</script><span class='k'>type</span> toggle_button <span class='k'>=</span> <span class='o'>[</span>`base<span class='o'>|</span>`widget<span class='o'>|</span>`container<span class='o'>|</span>`button<span class='o'>|</span>`toggle<span class='o'>]</span>
</code></pre>
<p>
(These are polymorphic variants - see \&lt;a href=&quot;../ch7/&quot;\&gt;Chapter
7\&lt;/a\&gt; if you don&#39;t remember them).</p>
<p>If you check the Gtk class hierarchy you&#39;ll see that the list of
variants closely (but not exactly) matches the classes. A Gtk toggle
button is-a Gtk button, Gtk container is-a Gtk widget, etc.</p>
<h4 id="Objectorientedlayer"> Object-oriented layer</h4><p>
Now let&#39;s look at the object-oriented layer interface to the toggle
button, so we can see how <code>&#39;a obj</code> comes into play. The <code>GButton</code> module
defines a class for toggle buttons, but unusually you don&#39;t directly
create instances of this class using <code>new toggle_button</code> (or similar).
Instead a function is provided which generates instances for you. Here
it is, simplified somewhat:</p>
<pre><code class='ocaml'><script>val mlfa066b6ea4b703df570a9462ee2d1ca4 = 'let toggle_button ?label ?border_width ?width ?height () =&#10;  let w = ToggleButton.create_toggle ?label () in&#10;  Container.set w ?border_width ?width ?height;&#10;  new toggle_button w&#10;';</script><span class='k'>let</span> toggle_button <span class='o'>?</span>label <span class='o'>?</span>border_width <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
  <span class='k'>let</span> w <span class='k'>=</span> <span class='m'>ToggleButton</span><span class='o'>.</span>create_toggle <span class='o'>?</span>label () <span class='k'>in</span>
  <span class='m'>Container</span><span class='o'>.</span>set w <span class='o'>?</span>border_width <span class='o'>?</span>width <span class='o'>?</span>height<span class='o'>;</span>
  <span class='k'>new</span> toggle_button w
</code></pre>
<p>
Recall that <code>w</code> has the abstract type
<code> [`base|`widget|`container|`button|`toggle] obj </code>, and it wraps up
the actual <code>GtkObject</code> allocated by the C library.</p>
<p>A toggle button is-a container, and the next thing we do is call
<code>Container.set</code> to set some properties in the base class. Here is where
the polymorphic variants become interesting. What is the type of
<code>Container.set</code>?</p>
<pre><code class='ocaml'><script>val ml062e22dd3bac2a023655ba19f93b19ea = '# GtkBase.Container.set;;&#10;- : ?border_width:int -&#62;&#10;    ?width:int -&#62; ?height:int -&#62; [&#62; `container | `widget] Gtk.obj -&#62; unit&#10;= &#60;fun&#62;&#10;';</script><span class='o'>#</span> <span class='m'>GtkBase</span><span class='o'>.</span><span class='m'>Container</span><span class='o'>.</span>set<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> <span class='o'>?</span>border_width<span class='o'>:</span>int <span class='k'>-></span>
    <span class='o'>?</span>width<span class='o'>:</span>int <span class='k'>-></span> <span class='o'>?</span>height<span class='o'>:</span>int <span class='k'>-></span> <span class='o'>[</span><span class='o'>&#62;</span> `container <span class='o'>|</span> `widget<span class='o'>]</span> <span class='m'>Gtk</span><span class='o'>.</span>obj <span class='k'>-></span> unit
<span class='k'>=</span> <span class='o'>&#60;</span><span class='k'>fun</span><span class='o'>&#62;</span>
</code></pre>
<p>
<code>Container.set</code> is expecting an argument of type
<code> [&gt;`container|`widget] obj </code>. Recall from our discussion of
polymorphic variants that <code> [&gt;`container|`widget] </code> means &quot;a variant
which contains <em>at least</em> <code>`containe</code> and <code>`widge</code>, and
possibly other things too&quot;. Now go back and compare with the definition
of <code>toggle_button</code> type above.</p>
<p>So <code>w</code> of type <code> [`base|`widget|`container|`button|`toggle] obj </code> is
compatible with the call to <code>Container.set</code>, expecting
<code> [&gt;`container|`widget] obj </code>.</p>
<p>Finally our function actually creates the class, passing the widget <code>w</code>
as the parameter to the class. The class is defined like this
(simplified):</p>
<pre><code class='ocaml'><script>val mlf1f287742d703283563a8dee21782338 = 'class toggle_button w = object&#10;  inherit button w&#10;  method connect = new toggle_button_signals obj&#10;  method active = ToggleButton.get_active obj&#10;  method set_active = ToggleButton.set_active obj&#10;  method set_draw_indicator = ToggleButton.set_mode obj&#10;end&#10;';</script><span class='k'>class</span> toggle_button w <span class='k'>=</span> object
  <span class='k'>inherit</span> button w
  <span class='k'>method</span> connect <span class='k'>=</span> <span class='k'>new</span> toggle_button_signals obj
  <span class='k'>method</span> active <span class='k'>=</span> <span class='m'>ToggleButton</span><span class='o'>.</span>get_active obj
  <span class='k'>method</span> set_active <span class='k'>=</span> <span class='m'>ToggleButton</span><span class='o'>.</span>set_active obj
  <span class='k'>method</span> set_draw_indicator <span class='k'>=</span> <span class='m'>ToggleButton</span><span class='o'>.</span>set_mode obj
<span class='k'>end</span>
</code></pre>
<p>
The base class for all objects is <code>GObj.gtkobj</code> defined as:</p>
<pre><code class='ocaml'><script>val mlbf4a30191b622ae7944bb4cfaaca760f = 'class gtkobj w = object&#10;  val obj = w&#10;  method destroy () = Object.destroy w&#10;  method get_id = Object.get_id w&#10;end&#10;';</script><span class='k'>class</span> gtkobj w <span class='k'>=</span> object
  <span class='k'>val</span> obj <span class='k'>=</span> w
  <span class='k'>method</span> destroy () <span class='k'>=</span> <span class='m'>Object</span><span class='o'>.</span>destroy w
  <span class='k'>method</span> get_id <span class='k'>=</span> <span class='m'>Object</span><span class='o'>.</span>get_id w
<span class='k'>end</span>
</code></pre>
<p>
So all classes, including <code>toggle_button</code>, have access to their
underlying object (the <code>GtkObject</code> allocated in C) through the <code>obj</code>
member, and have <code>#destroy</code> and <code>#get_id</code> methods. All classes derived
from <code>widget</code> have a public <code>#as_widget</code> method which returns the
underlying object (sadly there is no equivalent for <code>gtkobj</code>, although
this doesn&#39;t matter so much since almost all interesting classes are
widgets).</p>
<p>Let&#39;s try the OO interface for toggle buttons:</p>
<pre><code class='ocaml'><script>val ml78dd71b3e0ad85945931e33e81d70062 = '          (* call the toggle_button function *)&#10;# let b = GButton.toggle_button ~label:&#34;Push me!&#34; ();;&#10;          (* note: returns object from toggle_button class *)&#10;val b : GButton.toggle_button = &#60;obj&#62;&#10;# b#as_widget;;&#10;          (* note: returns a widget obj == [`base|`widget] obj *)&#10;- : Gtk.widget Gtk.obj = &#60;abstr&#62;&#10;';</script>          <span class='com2'>(* call the toggle_button <span class='ic'>function</span> *)</span><!-- end comment -->
<span class='o'>#</span> <span class='k'>let</span> b <span class='k'>=</span> <span class='m'>GButton</span><span class='o'>.</span>toggle_button <span class='o'>~</span>label<span class='o'>:</span><span class='s'>&#34;Push me!&#34;</span> ()<span class='o'>;;</span>
          <span class='com2'>(* note<span class='ic'>:</span> returns object from toggle_button <span class='ic'>class</span> *)</span><!-- end comment -->
<span class='k'>val</span> b <span class='o'>:</span> <span class='m'>GButton</span><span class='o'>.</span>toggle_button <span class='k'>=</span> <span class='o'>&#60;</span>obj<span class='o'>&#62;</span>
<span class='o'>#</span> b<span class='o'>#</span>as_widget<span class='o'>;;</span>
          <span class='com2'>(* note<span class='ic'>:</span> returns a widget obj <span class='ic'>==</span> <span class='ic'>[</span>`base<span class='ic'>|</span>`widget<span class='ic'>]</span> obj *)</span><!-- end comment -->
<span class='o'>-</span> <span class='o'>:</span> <span class='m'>Gtk</span><span class='o'>.</span>widget <span class='m'>Gtk</span><span class='o'>.</span>obj <span class='k'>=</span> <span class='o'>&#60;</span>abstr<span class='o'>&#62;</span>
</code></pre>
<h4 id="Downcasts"> Downcasts</h4><p>

Gtk is dynamically typed, and this means you can
\&lt;dfn\&gt;downcast\&lt;/dfn\&gt;, for example, a widget into a toggle button. Gtk
requires downcasting in some instances: for example you can pack widgets
into containers, but if you try and retrieve them out of the container,
all you get is a list of widgets. The original type of the widgets is
lost. Assuming you know that a widget is really, say, a button, then Gtk
requires you to downcast the widget to a button in order to use the
button-like features.</p>
<p>Such an operation is normally illegal in OCaml because OCaml is strongly
typed at compile time and downcasting is unsafe. The widget might or
might not actually be a toggle button. Lablgtk allows downcasting, and
provides another mechanism for casting which avoids the explicit
downcast. Whichever way you do it, you may get a runtime exception if
you cast to the wrong type.</p>
<p>The simplest downcast is just to unwrap the <code>&#39;a obj</code> (<code>GtkObject</code>) from
one class and wrap it in another class. Here we take the children out of
a table widget, which we happen to know are actually all vboxes, unwrap
each one from the <code>widget</code> class and rewrap in a <code>GPack.box</code> class.
(Example due to Jacques Garrigue.)</p>
<pre><code class='ocaml'><script>val ml0e0ebe3f2e7f0725ecb95be9d7729585 = 'let vbox_of_widget widget =&#10;  let obj = GtkPack.Box.cast widget#as_widget in&#10;  new GPack.box obj&#10;&#10;let vboxes = List.iter vbox_of_widget table#children&#10;';</script><span class='k'>let</span> vbox_of_widget widget <span class='k'>=</span>
  <span class='k'>let</span> obj <span class='k'>=</span> <span class='m'>GtkPack</span><span class='o'>.</span><span class='m'>Box</span><span class='o'>.</span>cast widget<span class='o'>#</span>as_widget <span class='k'>in</span>
  <span class='k'>new</span> <span class='m'>GPack</span><span class='o'>.</span>box obj

<span class='k'>let</span> vboxes <span class='k'>=</span> <span class='m'>List</span><span class='o'>.</span>iter vbox_of_widget table<span class='o'>#</span>children
</code></pre>
<p>
The terminology might be a little bit confusing here because the
<code>#as_widget</code> method returns the internal <code>GtkObject</code> of type <code>&#39;a obj</code>.</p>
<p><code>GtkPack.Box.cast</code> does the actual unsafe downcast. Downcasts can always
fail at runtime, and in the case above the <code>Cannot_cast</code> exception could
be thrown. You should be prepared to deal with this - unfortunately it&#39;s
a program bug which cannot be picked up at compile time.</p>
<p>The other method for doing this avoids the explicit downcast, but can
still throw an exception indicating a program bug at runtime. The
strategy here is to remember what objects we put into the container
separately, and when we take them out try to match them up. We use the
<code>GUtil.memo</code> class for this:</p>
<pre><code class='ocaml'><script>val ml03eb6d234632caa4b86701143d356dc9 = 'class [&#39;a] memo () = object&#10;  constraint &#39;a = #widget&#10;  val tbl = Hashtbl.create 7&#10;  method add (obj : &#39;a) =&#10;    Hashtbl.add tbl obj#get_id obj&#10;  method find (obj : widget) = Hashtbl.find tbl obj#get_id&#10;  method remove (obj : widget) = Hashtbl.remove tbl obj#get_id&#10;end&#10;';</script><span class='k'>class</span> <span class='o'>[</span>'a<span class='o'>]</span> memo () <span class='k'>=</span> object
  <span class='k'>constraint</span> 'a <span class='k'>=</span> <span class='o'>#</span>widget
  <span class='k'>val</span> tbl <span class='k'>=</span> <span class='m'>Hashtbl</span><span class='o'>.</span>create 7
  <span class='k'>method</span> add (obj <span class='o'>:</span> 'a) <span class='k'>=</span>
    <span class='m'>Hashtbl</span><span class='o'>.</span>add tbl obj<span class='o'>#</span>get_id obj
  <span class='k'>method</span> find (obj <span class='o'>:</span> widget) <span class='k'>=</span> <span class='m'>Hashtbl</span><span class='o'>.</span>find tbl obj<span class='o'>#</span>get_id
  <span class='k'>method</span> remove (obj <span class='o'>:</span> widget) <span class='k'>=</span> <span class='m'>Hashtbl</span><span class='o'>.</span>remove tbl obj<span class='o'>#</span>get_id
<span class='k'>end</span>
</code></pre>
<p>
(The constraint essentially says that <code>&#39;a</code> must be a widget, or some
subclass of widget).</p>
<p>Here is an example of using a memo. First we will create a top-level
window, a container (vbox) to go inside this, and a button:</p>
<pre><code class='ocaml'><script>val mlb59422bae2be7496ea7be5bd9cadb119 = '# let w = GWindow.window ();;&#10;val w : GWindow.window = &#60;obj&#62;&#10;# let c = GPack.vbox ~packing:w#add ();;&#10;val c : GPack.box = &#60;obj&#62;&#10;# let b = GButton.button ~label:&#34;Push me!&#34; ();;&#10;val b : GButton.button = &#60;obj&#62;&#10;';</script><span class='o'>#</span> <span class='k'>let</span> w <span class='k'>=</span> <span class='m'>GWindow</span><span class='o'>.</span>window ()<span class='o'>;;</span>
<span class='k'>val</span> w <span class='o'>:</span> <span class='m'>GWindow</span><span class='o'>.</span>window <span class='k'>=</span> <span class='o'>&#60;</span>obj<span class='o'>&#62;</span>
<span class='o'>#</span> <span class='k'>let</span> c <span class='k'>=</span> <span class='m'>GPack</span><span class='o'>.</span>vbox <span class='o'>~</span>packing<span class='o'>:</span>w<span class='o'>#</span>add ()<span class='o'>;;</span>
<span class='k'>val</span> c <span class='o'>:</span> <span class='m'>GPack</span><span class='o'>.</span>box <span class='k'>=</span> <span class='o'>&#60;</span>obj<span class='o'>&#62;</span>
<span class='o'>#</span> <span class='k'>let</span> b <span class='k'>=</span> <span class='m'>GButton</span><span class='o'>.</span>button <span class='o'>~</span>label<span class='o'>:</span><span class='s'>&#34;Push me!&#34;</span> ()<span class='o'>;;</span>
<span class='k'>val</span> b <span class='o'>:</span> <span class='m'>GButton</span><span class='o'>.</span>button <span class='k'>=</span> <span class='o'>&#60;</span>obj<span class='o'>&#62;</span>
</code></pre>
<p>
Before we pack the button into the container, let&#39;s create a memo to
remember the real object. Notice how the type of the memo is refined as
soon as the button is added:</p>
<pre><code class='ocaml'><script>val ml00a22ed4cac2478c4dc925fac4db780c = '# let m = new GUtil.memo ();;&#10;val m : _#GObj.widget GUtil.memo = &#60;obj&#62;&#10;# m#add b;;&#10;- : unit = ()&#10;# m;;&#10;- : GButton.button GUtil.memo = &#60;obj&#62;&#10;';</script><span class='o'>#</span> <span class='k'>let</span> m <span class='k'>=</span> <span class='k'>new</span> <span class='m'>GUtil</span><span class='o'>.</span>memo ()<span class='o'>;;</span>
<span class='k'>val</span> m <span class='o'>:</span> <span class='o'>_</span><span class='o'>#</span><span class='m'>GObj</span><span class='o'>.</span>widget <span class='m'>GUtil</span><span class='o'>.</span>memo <span class='k'>=</span> <span class='o'>&#60;</span>obj<span class='o'>&#62;</span>
<span class='o'>#</span> m<span class='o'>#</span>add b<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> unit <span class='k'>=</span> ()
<span class='o'>#</span> m<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> <span class='m'>GButton</span><span class='o'>.</span>button <span class='m'>GUtil</span><span class='o'>.</span>memo <span class='k'>=</span> <span class='o'>&#60;</span>obj<span class='o'>&#62;</span>
</code></pre>
<p>
Now we can add the button to the container, remembering to upcast it to
a widget first of course:</p>
<pre><code class='ocaml'><script>val ml2d8bfd8d2d28c7c8922c478355ac91e3 = '# c#add (b :&#62; GObj.widget);;&#10;- : unit = ()&#10;';</script><span class='o'>#</span> c<span class='o'>#</span>add (b <span class='o'>:&#62;</span> <span class='m'>GObj</span><span class='o'>.</span>widget)<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> unit <span class='k'>=</span> ()
</code></pre>
<p>
The method <code>#children</code> returns a list of widgets. Not much use to us:</p>
<pre><code class='ocaml'><script>val ml837adecc0a092dc14fe7643c59dd4a0f = '# c#children;;&#10;- : GObj.widget list = [&#60;obj&#62;]&#10;';</script><span class='o'>#</span> c<span class='o'>#</span>children<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> <span class='m'>GObj</span><span class='o'>.</span>widget list <span class='k'>=</span> <span class='o'>[</span><span class='o'>&#60;</span>obj<span class='o'>&#62;</span><span class='o'>]</span>
</code></pre>
<p>
But we can use our memo to map these widgets to the original button
objects:</p>
<pre><code class='ocaml'><script>val ml9f0369e059025a0349289825beee8a86 = '# List.map (fun w -&#62; m#find w) c#children;;&#10;- : GButton.button list = [&#60;obj&#62;]&#10;';</script><span class='o'>#</span> <span class='m'>List</span><span class='o'>.</span>map (<span class='k'>fun</span> w <span class='k'>-></span> m<span class='o'>#</span>find w) c<span class='o'>#</span>children<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> <span class='m'>GButton</span><span class='o'>.</span>button list <span class='k'>=</span> <span class='o'>[</span><span class='o'>&#60;</span>obj<span class='o'>&#62;</span><span class='o'>]</span>
</code></pre>
<p>
Remember that this is still dynamic casting, and so unsafe. In this case
the memo will throw a <code>Not_found</code> exception if the widget cannot be
mapped:</p>
<pre><code class='ocaml'><script>val mlf0226ea56335669fef157f367e1b697d = '# let b2 = GButton.button ~label:&#34;Don&#39;t push me!&#34; ();;&#10;val b2 : GButton.button = &#60;obj&#62;&#10;# c#add (b2 :&#62; GObj.widget);;&#10;- : unit = ()&#10;# List.map (fun w -&#62; m#find w) c#children;;&#10;Exception: Not_found.&#10;';</script><span class='o'>#</span> <span class='k'>let</span> b2 <span class='k'>=</span> <span class='m'>GButton</span><span class='o'>.</span>button <span class='o'>~</span>label<span class='o'>:</span><span class='s'>&#34;Don&#39;t push me!&#34;</span> ()<span class='o'>;;</span>
<span class='k'>val</span> b2 <span class='o'>:</span> <span class='m'>GButton</span><span class='o'>.</span>button <span class='k'>=</span> <span class='o'>&#60;</span>obj<span class='o'>&#62;</span>
<span class='o'>#</span> c<span class='o'>#</span>add (b2 <span class='o'>:&#62;</span> <span class='m'>GObj</span><span class='o'>.</span>widget)<span class='o'>;;</span>
<span class='o'>-</span> <span class='o'>:</span> unit <span class='k'>=</span> ()
<span class='o'>#</span> <span class='m'>List</span><span class='o'>.</span>map (<span class='k'>fun</span> w <span class='k'>-></span> m<span class='o'>#</span>find w) c<span class='o'>#</span>children<span class='o'>;;</span>
Exception<span class='o'>:</span> <span class='m'>Not_found</span><span class='o'>.</span>
</code></pre>
<h3 id="Structureoflablgtksummary"> Structure of lablgtk — summary</h3>
<ul>
 <li><code>GtkObject</code>s allocated by the C library are wrapped up in opaque
 <code>&#39;a obj</code> abstract types.
 </li>
 <li>The module layer is flat (not OO) but uses polymorphic variants to
 simulate a class hierarchy.
 </li>
 <li>The module layer handles Gtk&#39;s reference counting for you
 transparently.
 </li>
 <li>Classes in the OO layer store the opaque <code>GtkObject</code> in a member
 called <code>obj</code>, and perform operations through the module layer,
 usually passing <code>obj</code> as the first parameter.
 </li>
 <li>Helper functions are provided to create instances of classes.
 </li>
 <li>Lablgtk provides two ways to perform downcasting, but this doesn&#39;t
 change the fact that downcasting is unsafe and can throw exceptions
 at runtime.</li>
</ul>

<p>\&lt;a href=&quot;../ch13/&quot;\&gt;Chapter 13\&lt;/a\&gt; continues with a discussion of
wrapping up external C libraries. We look at another way to wrap up Gtk.</p>

          </div>
        </div>
      </div>
    </div>
    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-right">
            <li><a href="#">Feedback</a></li>
            <li><a href="#">Contact us</a></li>
            <li><a href="#">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
  </body>
</html>
