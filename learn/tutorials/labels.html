<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title> &#8211; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" />
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet" />
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen" />
    <link href="/static/css/bootstrap_mod.css" rel="stylesheet" media="screen" />
    <link href="/static/css/opamdoc.css" rel="stylesheet" media="screen" />
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <script type="text/javascript">
      function octry(x){
        if(document.getElementById('buttons').innerHTML=='') {
          t = document.getElementById('tryocaml');
          js = document.createElement("script"); js.type = "text/javascript"; js.src = "/try-ocaml.js";
          t.appendChild(js);
        } else {
          t = document.getElementById('tryocaml');
          t.style.display = 'block';
          document.getElementById('console').value = x;
          document.getElementById('console').focus();
          document.getElementById('console').select();
        }
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml" /></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/pkg/">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
    <div class="container">
  <div class="row">
    

    <div id="content-primary" class="span8">
      <div id='tryocaml' class="content" style='display:none;'>
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style='display:none;'></div>
            <div id="menu-lessons" style='display:none'>
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td id=""></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id='main-contents' class="content">
        <h1 id="Labels"> Labels</h1><h2 id="Exceptionsandhashtables"> Exceptions and hash tables</h2><p>

<em>(unfinished)</em></p>
<h2 id="Mutuallyrecursivefunctions"> Mutually recursive functions</h2><p>
Suppose I want to define two functions which call each other. This is
actually not a very common thing to do, but it can be useful sometimes.
Here&#39;s a contrived example (thanks to Ryan Tarpine): The number 0 is
even. Other numbers greater than 0 are even if their predecessor is odd.
Hence:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> even n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>true</span>
  <span class='o'>|</span> x <span class='k'>-></span> odd (x-1)
<a href="javascript:octry('let rec even n =\n  match n with\n  | 0 -&#62; true\n  | x -&#62; odd (x-1)\n');">[try]</a></code></pre>
<p>
The code above doesn&#39;t compile because we haven&#39;t defined the function
<code>odd</code> yet! That&#39;s easy though. Zero is not odd, and other numbers
greater than 0 are odd if their predecessor is even. So to make this
complete we need that function too:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> even n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>true</span>
  <span class='o'>|</span> x <span class='k'>-></span> odd (x-1)

<span class='k'>let rec</span> odd n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>false</span>
  <span class='o'>|</span> x <span class='k'>-></span> even (x-1)
<a href="javascript:octry('let rec even n =\n  match n with\n  | 0 -&#62; true\n  | x -&#62; odd (x-1)\n\nlet rec odd n =\n  match n with\n  | 0 -&#62; false\n  | x -&#62; even (x-1)\n');">[try]</a></code></pre>
<p>
The only problem is... this program doesn&#39;t compile. In order to compile
the <code>even</code> function, we already need the definition of <code>odd</code>, and to
compile <code>odd</code> we need the definition of <code>even</code>. So swapping the two
definitions around won&#39;t help either.</p>
<p>There are no &quot;forward prototypes&quot; in OCaml but there is a special syntax
for defining a set of two or more mutually recursive functions, like
<code>odd</code> and <code>even</code>:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> even n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>true</span>
  <span class='o'>|</span> x <span class='k'>-></span> odd (x-1)
<span class='k'>and</span> odd n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>false</span>
  <span class='o'>|</span> x <span class='k'>-></span> even (x-1)
<a href="javascript:octry('let rec even n =\n  match n with\n  | 0 -&#62; true\n  | x -&#62; odd (x-1)\nand odd n =\n  match n with\n  | 0 -&#62; false\n  | x -&#62; even (x-1)\n');">[try]</a></code></pre>
<p>
It&#39;s hard to know exactly how useful this is in practice, since I&#39;ve
never had cause to write mutually recursive functions, nor have I been
able to think of a non-trivial example. However it&#39;s there. You can also
use similar syntax for writing mutually recursive class definitions and
modules.</p>
<h2 id="Aliasesforfunctionnamesandarguments"> Aliases for function names and arguments</h2><p>
Recall in Chapter 5 we talked about partial function application. It&#39;s
possible to use this as a neat trick to save typing: aliasing function
names, and function arguments.</p>
<p>Although we haven&#39;t looked at object-oriented programming (that&#39;s the
subject for the next chapter), here&#39;s an example from OCamlNet of an
aliased function call. All you need to know is that
<code>cgi # output # output_string &quot;string&quot;</code> is a method call, similar to
<code>cgi.output().output_string (&quot;string&quot;)</code> in Java.</p>
<pre><code class='ocaml'><span class='k'>let</span> begin_page cgi title <span class='k'>=</span>
  <span class='k'>let</span> out <span class='k'>=</span> cgi <span class='o'>#</span> output <span class='o'>#</span> output_string <span class='k'>in</span>
  out <span class='s'>&#34;&#60;html&#62;\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;head&#62;\n&#34;</span><span class='o'>;</span>
  out (<span class='s'>&#34;&#60;title&#62;&#34;</span> <span class='o'>^</span> text title <span class='o'>^</span> <span class='s'>&#34;&#60;/title&#62;\n&#34;</span>)<span class='o'>;</span>
  out (<span class='s'>&#34;&#60;style type=\&#34;text/css\&#34;&#62;\n&#34;</span>)<span class='o'>;</span>
  out <span class='s'>&#34;body { background: white; color: black; }\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;/style&#62;\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;/head&#62;\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;body&#62;\n&#34;</span><span class='o'>;</span>
  out (<span class='s'>&#34;&#60;h1&#62;&#34;</span> <span class='o'>^</span> text title <span class='o'>^</span> <span class='s'>&#34;&#60;/h1&#62;\n&#34;</span>)
<a href="javascript:octry('let begin_page cgi title =\n  let out = cgi # output # output_string in\n  out &#34;&#60;html&#62;\n&#34;;\n  out &#34;&#60;head&#62;\n&#34;;\n  out (&#34;&#60;title&#62;&#34; ^ text title ^ &#34;&#60;/title&#62;\n&#34;);\n  out (&#34;&#60;style type=\&#34;text/css\&#34;&#62;\n&#34;);\n  out &#34;body { background: white; color: black; }\n&#34;;\n  out &#34;&#60;/style&#62;\n&#34;;\n  out &#34;&#60;/head&#62;\n&#34;;\n  out &#34;&#60;body&#62;\n&#34;;\n  out (&#34;&#60;h1&#62;&#34; ^ text title ^ &#34;&#60;/h1&#62;\n&#34;)\n');">[try]</a></code></pre>
<p>
The <code>let out = ... </code> is a partial function application for that method
call (partial, because the string parameter hasn&#39;t been applied). <code>out</code>
is therefore a function, which takes a string parameter.</p>
<pre><code class='ocaml'>  out <span class='s'>&#34;&#60;html&#62;\n&#34;</span><span class='o'>;</span>
<a href="javascript:octry('  out &#34;&#60;html&#62;\n&#34;;\n');">[try]</a></code></pre>
<p>
is equivalent to:</p>
<pre><code class='ocaml'>  cgi <span class='o'>#</span> output <span class='o'>#</span> output_string <span class='s'>&#34;&#60;html&#62;\n&#34;</span><span class='o'>;</span>
<a href="javascript:octry('  cgi # output # output_string &#34;&#60;html&#62;\n&#34;;\n');">[try]</a></code></pre>
<p>
We saved ourselves a lot of typing there.</p>
<p>We can also add arguments. This alternative definition of <code>print_string</code>
can be thought of as a kind of alias for a function name plus arguments:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> print_string <span class='k'>=</span> output_string stdout
<a href="javascript:octry('  let print_string = output_string stdout\n');">[try]</a></code></pre>
<p>
<code>output_string</code> takes two arguments (a channel and a string), but since
we have only supplied one, it is partially applied. So <code>print_string</code> is
a function, expecting one string argument.</p>
<h2 id="Labelledandoptionalargumentstofunctions"> Labelled and optional arguments to functions</h2><h3 id="Labelledarguments"> Labelled arguments</h3><p>

Python has the nicest syntax for writing arguments to functions. Here&#39;s
an example (from the Python tutorial, since I&#39;m not a Python
programmer):</p>
<pre><code class='ocaml'>def ask_ok(prompt<span class='o'>,</span> retries<span class='k'>=</span>4<span class='o'>,</span> complaint<span class='k'>=</span>'Yes <span class='k'>or</span> no<span class='o'>,</span> please<span class='o'>!</span>')<span class='o'>:</span>
  <span class='o'>#</span> <span class='k'>function</span> definition omitted
<a href="javascript:octry('def ask_ok(prompt, retries=4, complaint=&#39;Yes or no, please!&#39;):\n  # function definition omitted\n');">[try]</a></code></pre>
<p>
Here are the ways we can call this Python function:</p>
<pre><code class='ocaml'>ask_ok ('Do you really want <span class='k'>to</span> quit?')
ask_ok ('Overwrite the file?'<span class='o'>,</span> 2)
ask_ok (prompt<span class='k'>=</span>'Are you sure?')
ask_ok (complaint<span class='k'>=</span>'Please answer yes <span class='k'>or</span> no<span class='o'>!</span>'<span class='o'>,</span> prompt<span class='k'>=</span>'Are you sure?')
<a href="javascript:octry('ask_ok (&#39;Do you really want to quit?&#39;)\nask_ok (&#39;Overwrite the file?&#39;, 2)\nask_ok (prompt=&#39;Are you sure?&#39;)\nask_ok (complaint=&#39;Please answer yes or no!&#39;, prompt=&#39;Are you sure?&#39;)\n');">[try]</a></code></pre>
<p>
Notice that in Python we are allowed to name arguments when we call
them, or use the usual function call syntax, and we can have optional
arguments with default values.</p>
<p>You can do something similar in Perl:</p>
<pre><code class='ocaml'>sub ask_ok
<span class='o'>{</span>
  my <span class='o'>%</span>params <span class='k'>=</span> <span class='o'>@_;</span>

  my <span class='o'>$</span>prompt <span class='k'>=</span> <span class='o'>$</span>params<span class='o'>{</span>prompt<span class='o'>}</span><span class='o'>;</span>
  my <span class='o'>$</span>retries <span class='k'>=</span> exists <span class='o'>$</span>params<span class='o'>{</span>retries<span class='o'>}</span> <span class='o'>?</span> <span class='o'>$</span>params<span class='o'>{</span>retries<span class='o'>}</span> <span class='o'>:</span> 4<span class='o'>;</span>

  <span class='o'>#</span> <span class='o'>...</span> etc<span class='o'>.</span>
<span class='o'>}</span>

ask_ok (prompt <span class='o'>=&#62;</span> <span class='s'>&#34;Are you sure?&#34;</span><span class='o'>,</span> retries <span class='o'>=&#62;</span> 2)<span class='o'>;</span>
<a href="javascript:octry('sub ask_ok\n{\n  my %params = @_;\n\n  my $prompt = $params{prompt};\n  my $retries = exists $params{retries} ? $params{retries} : 4;\n\n  # ... etc.\n}\n\nask_ok (prompt =&#62; &#34;Are you sure?&#34;, retries =&#62; 2);\n');">[try]</a></code></pre>
<p>
OCaml also has a way to label arguments and have optional arguments with
default values.</p>
<p>The basic syntax is:</p>
<pre><code class='ocaml'>  <span class='k'>let rec</span> range <span class='o'>~</span>first<span class='o'>:</span>a <span class='o'>~</span>last<span class='o'>:</span>b <span class='k'>=</span>
    <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> <span class='o'>[</span><span class='o'>]</span>
    <span class='k'>else</span> a <span class='o'>::</span> range <span class='o'>~</span>first<span class='o'>:</span>(a<span class='o'>+</span>1) <span class='o'>~</span>last<span class='o'>:</span>b
<a href="javascript:octry('  let rec range ~first:a ~last:b =\n    if a &#62; b then []\n    else a :: range ~first:(a+1) ~last:b\n');">[try]</a></code></pre>
<p>
(Notice that both <code>to</code> and <code>end</code> are reserved words in OCaml, so they
cannot be used as labels. So you cannot have <code>~from/~to</code> or
<code>~start/~end</code>.)</p>
<p>The type of our previous <code>range</code> function was:</p>
<pre><code class='ocaml'>range <span class='o'>:</span> int <span class='k'>-></span> int <span class='k'>-></span> int list
<a href="javascript:octry('range : int -&#62; int -&#62; int list\n');">[try]</a></code></pre>
<p>
And the type of our new <code>range</code> function with labelled arguments is:</p>
<pre><code class='ocaml'>range <span class='o'>:</span> first<span class='o'>:</span>int <span class='k'>-></span> last<span class='o'>:</span>int <span class='k'>-></span> int list
<a href="javascript:octry('range : first:int -&#62; last:int -&#62; int list\n');">[try]</a></code></pre>
<p>
(Confusingly, the <code>~</code> (tilde) is <em>not</em> shown in the type definition, but
you need to use it everywhere else).</p>
<p>With labelled arguments, it doesn&#39;t matter which order you give the
arguments anymore:</p>
<pre><code class='ocaml'>range <span class='o'>~</span>first<span class='o'>:</span>1 <span class='o'>~</span>last<span class='o'>:</span>10<span class='o'>;;</span>
range <span class='o'>~</span>last<span class='o'>:</span>10 <span class='o'>~</span>first<span class='o'>:</span>1<span class='o'>;;</span>
<a href="javascript:octry('range ~first:1 ~last:10;;\nrange ~last:10 ~first:1;;\n');">[try]</a></code></pre>
<p>
There is also a shorthand way to name the arguments, so that the label
is the same as the variable in the function definition. Here is a
function defined in <code>lablgtk/gaux.ml</code> (a library of useful oddities used
in lablgtk):</p>
<pre><code class='ocaml'>  <span class='k'>let</span> may <span class='o'>~</span>f x <span class='k'>=</span>
    <span class='k'>match</span> x <span class='k'>with</span>
    <span class='o'>|</span> None <span class='k'>-></span> ()
    <span class='o'>|</span> Some x <span class='k'>-></span> ignore(f x)
<a href="javascript:octry('  let may ~f x =\n    match x with\n    | None -&#62; ()\n    | Some x -&#62; ignore(f x)\n');">[try]</a></code></pre>
<p>
It&#39;s worth spending some time working out exactly what this function
does, and also working out by hand its type signature. There&#39;s a lot
going on. First of all, the parameter <code>~f</code> is just shorthand for <code>~f:f</code>
(ie. the label is <code>~f</code> and the variable used in the function is <code>f</code>).
Secondly notice that the function takes two parameters. The second
parameter (<code>x</code>) is unlabelled - it is permitted for a function to take a
mixture of labelled and unlabelled arguments if you want.</p>
<p>What is the type of the labelled <code>f</code> parameter? Obviously it&#39;s a
function of some sort.</p>
<p>What is the type of the unlabelled <code>x</code> parameter? The <code>match</code> clause
gives us a clue. It&#39;s an <code>&#39;a option</code>.</p>
<p>This tells us that <code>f</code> takes an <code>&#39;a</code> parameter, and the return value of
<code>f</code> is ignored, so it could be anything. The type of <code>f</code> is therefore
<code>&#39;a -&gt; &#39;b</code>.</p>
<p>The <code>may</code> function as a whole returns <code>unit</code>. Notice in each case of the
<code>match</code> the result is <code>()</code>.</p>
<p>Thus the type of the <code>may</code> function is (and you can verify this in the
OCaml toplevel if you want):</p>
<pre><code class='ocaml'>may <span class='o'>:</span> f<span class='o'>:</span>('a <span class='k'>-></span> 'b) <span class='k'>-></span> 'a option <span class='k'>-></span> unit
<a href="javascript:octry('may : f:(&#39;a -&#62; &#39;b) -&#62; &#39;a option -&#62; unit\n');">[try]</a></code></pre>
<p>
What does this function do? Running the function in the OCaml toplevel
gives us some clues:</p>
<pre><code class='ocaml'>may <span class='o'>~</span>f<span class='o'>:</span>print_endline None<span class='o'>;;</span>
may <span class='o'>~</span>f<span class='o'>:</span>print_endline (Some <span class='s'>&#34;hello&#34;</span>)<span class='o'>;;</span>
<a href="javascript:octry('may ~f:print_endline None;;\nmay ~f:print_endline (Some &#34;hello&#34;);;\n');">[try]</a></code></pre>
<p>
If the unlabelled argument is a &quot;null pointer&quot; then <code>may</code> does nothing.
Otherwise <code>may</code> calls the <code>f</code> function on the argument. Why is this
useful? We&#39;re just about to find out ...</p>
<h3 id="Optionalarguments"> Optional arguments</h3><p>
Optional arguments are like labelled arguments, but we use <code>?</code> instead
of <code>~</code> in front of them. Here is an example:</p>
<pre><code class='ocaml'>  <span class='k'>let rec</span> range <span class='o'>?</span>(step<span class='k'>=</span>1) a b <span class='k'>=</span>
    <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> <span class='o'>[</span><span class='o'>]</span>
    <span class='k'>else</span> a <span class='o'>::</span> range <span class='o'>~</span>step (a<span class='o'>+</span>step) b
<a href="javascript:octry('  let rec range ?(step=1) a b =\n    if a &#62; b then []\n    else a :: range ~step (a+step) b\n');">[try]</a></code></pre>
<p>
Note the somewhat confusing syntax, switching between <code>?</code> and <code>~</code>. We&#39;ll
talk about that in the next section. Here is how you call this function:</p>
<pre><code class='ocaml'>range 1 10<span class='o'>;;</span>
range 1 10 <span class='o'>~</span>step<span class='o'>:</span>2<span class='o'>;;</span>
<a href="javascript:octry('range 1 10;;\nrange 1 10 ~step:2;;\n');">[try]</a></code></pre>
<p>
In this case, <code>?(step=1)</code> fairly obviously means that <code>~step</code> is an
optional argument which defaults to 1. We can also omit the default
value and just have an optional argument. This example is modified from
lablgtk:</p>
<pre><code class='ocaml'>  <span class='k'>type</span> window <span class='k'>=</span> <span class='o'>{</span> <span class='k'>mutable</span> title<span class='o'>:</span> string<span class='o'>;</span>
                  <span class='k'>mutable</span> width<span class='o'>:</span> int<span class='o'>;</span>
                  <span class='k'>mutable</span> height<span class='o'>:</span> int <span class='o'>}</span>
  
  <span class='k'>let</span> create_window () <span class='k'>=</span>
    <span class='o'>{</span> title <span class='k'>=</span> <span class='s'>&#34;none&#34;</span><span class='o'>;</span> width <span class='k'>=</span> 640<span class='o'>;</span> height <span class='k'>=</span> 480<span class='o'>;</span> <span class='o'>}</span>
  
  <span class='k'>let</span> set_title window title <span class='k'>=</span>
    window<span class='o'>.</span>title <span class='o'>&#60;-</span> title
  
  <span class='k'>let</span> set_width window width <span class='k'>=</span>
    window<span class='o'>.</span>width <span class='o'>&#60;-</span> width
  
  <span class='k'>let</span> set_height window height <span class='k'>=</span>
    window<span class='o'>.</span>height <span class='o'>&#60;-</span> height
  
  <span class='k'>let</span> open_window <span class='o'>?</span>title <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    <span class='k'>let</span> window <span class='k'>=</span> create_window () <span class='k'>in</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_width window) width<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_height window) height<span class='o'>;</span>
    window
<a href="javascript:octry('  type window = { mutable title: string;\n                  mutable width: int;\n                  mutable height: int }\n  \n  let create_window () =\n    { title = &#34;none&#34;; width = 640; height = 480; }\n  \n  let set_title window title =\n    window.title &#60;- title\n  \n  let set_width window width =\n    window.width &#60;- width\n  \n  let set_height window height =\n    window.height &#60;- height\n  \n  let open_window ?title ?width ?height () =\n    let window = create_window () in\n    may ~f:(set_title window) title;\n    may ~f:(set_width window) width;\n    may ~f:(set_height window) height;\n    window\n');">[try]</a></code></pre>
<p>
This example is significantly complex and quite subtle, but the pattern
used is very common in the lablgtk source code. Let&#39;s concentrate on the
simple <code>create_window</code> function first. This function takes a <code>unit</code> and
returns a <code>window</code>, initialized with default settings for title, width
and height:</p>
<pre><code class='ocaml'>create_window ()<span class='o'>;;</span>
<a href="javascript:octry('create_window ();;\n');">[try]</a></code></pre>
<p>
The <code>set_title</code>, <code>set_width</code> and <code>set_height</code> functions are impure
functions which modify the <code>window</code> structure, in the obvious way. For
example:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> w <span class='k'>=</span> create_window () <span class='k'>in</span>
  set_title w <span class='s'>&#34;My Application&#34;</span><span class='o'>;</span>
  w<span class='o'>;;</span>
<a href="javascript:octry('  let w = create_window () in\n  set_title w &#34;My Application&#34;;\n  w;;\n');">[try]</a></code></pre>
<p>
So far this is just the imperative &quot;mutable records&quot; which we talked
about in the previous chapter. Now the complex part is the <code>open_window</code>
function. This function takes <em>4</em> arguments, three of them optional,
followed by a required, unlabelled <code>unit</code>. Let&#39;s first see this function
in action:</p>
<pre><code class='ocaml'>open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> ()<span class='o'>;;</span>
open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;Clock&#34;</span> <span class='o'>~</span>width<span class='o'>:</span>128 <span class='o'>~</span>height<span class='o'>:</span>128 ()<span class='o'>;;</span>
<a href="javascript:octry('open_window ~title:&#34;My Application&#34; ();;\nopen_window ~title:&#34;Clock&#34; ~width:128 ~height:128 ();;\n');">[try]</a></code></pre>
<p>
It does what you expect, but how?! The secret is in the <code>may</code> function
(see above) and the fact that the optional parameters <em>don&#39;t</em> have
defaults.</p>
<p>When an optional parameter doesn&#39;t have a default, then it has type
<code>&#39;a option</code>. The <code>&#39;a</code> would normally be inferred by type inference, so
in the case of <code>?title</code> above, this has type <code>string option</code>.</p>
<p>Remember the <code>may</code> function? It takes a function and an argument, and
calls the function on the argument provided the argument isn&#39;t <code>None</code>.
So:</p>
<pre><code class='ocaml'>may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
<a href="javascript:octry('may ~f:(set_title window) title;\n');">[try]</a></code></pre>
<p>
If the optional title argument is not specified by the caller, then
<code>title</code> = <code>None</code>, so <code>may</code> does nothing. But if we call the function
with, for example, <code>open_window ~title:&quot;My Application&quot; ();;</code>, then
<code>title</code> = <code>Some &quot;My Application&quot;</code>, and <code>may</code> therefore calls
<code>set_title window &quot;My Application&quot;</code>.</p>
<p>You should make sure you fully understand this example before proceeding
to the next section.</p>
<h3 id="quotWarningThisoptionalargumentcannotbeerasedquot"> &quot;Warning: This optional argument cannot be erased&quot;</h3><p>
We&#39;ve just touched upon labels and optional arguments, but even this
brief explanation should have raised several questions. The first may be
why the extra <code>unit</code> argument to <code>open_window</code>? Let&#39;s try defining this
function without the extra <code>unit</code>:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_window <span class='o'>?</span>title <span class='o'>?</span>width <span class='o'>?</span>height <span class='k'>=</span>
    <span class='k'>let</span> window <span class='k'>=</span> create_window () <span class='k'>in</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_width window) width<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_height window) height<span class='o'>;</span>
    window
<a href="javascript:octry('  let open_window ?title ?width ?height =\n    let window = create_window () in\n    may ~f:(set_title window) title;\n    may ~f:(set_width window) width;\n    may ~f:(set_height window) height;\n    window\n');">[try]</a></code></pre>
<p>
Although OCaml has compiled the function, it has generated a somewhat
infamous warning: &quot;This optional argument cannot be erased&quot;, referring
to the final <code>?height</code> argument. To try to show what&#39;s going on here,
let&#39;s call our modified <code>open_window</code> function:</p>
<pre><code class='ocaml'>open_window<span class='o'>;;</span>
open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span><span class='o'>;;</span>
<a href="javascript:octry('open_window;;\nopen_window ~title:&#34;My Application&#34;;;\n');">[try]</a></code></pre>
<p>
Did that work or not? No it didn&#39;t. In fact it didn&#39;t even run the
<code>open_window</code> function at all. Instead it printed some strange type
information. What&#39;s going on?</p>
<p>Recall currying and uncurrying, and partial application of functions. If
we have a function <code>plus</code> defined as:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> plus x y <span class='k'>=</span>
    x <span class='o'>+</span> y
<a href="javascript:octry('  let plus x y =\n    x + y\n');">[try]</a></code></pre>
<p>
We can partially apply this, for example as <code>plus 2</code> which is &quot;the
function that adds 2 to things&quot;:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> f <span class='k'>=</span> plus 2<span class='o'>;;</span>
  f 5<span class='o'>;;</span>
  f 100<span class='o'>;;</span>
<a href="javascript:octry('  let f = plus 2;;\n  f 5;;\n  f 100;;\n');">[try]</a></code></pre>
<p>
In the <code>plus</code> example, the OCaml compiler can easily work out that
<code>plus 2</code> doesn&#39;t have enough arguments supplied yet. It needs another
argument before the <code>plus</code> function itself can be executed. Therefore
<code>plus 2</code> is a function which is waiting for its extra argument to come
along.</p>
<p>Things are not so clear when we add optional arguments into the mix. The
call to <code>open_window;;</code> above is a case in point. Does the user mean
&quot;execute <code>open_window</code> now&quot;? Or does the user mean to supply some or all
of the optional arguments later? Is <code>open_window;;</code> waiting for extra
arguments to come along like <code>plus 2</code>?</p>
<p>OCaml plays it safe and doesn&#39;t execute <code>open_window</code>. Instead it treats
it as a partial function application. The expression <code>open_window</code>
literally evaluates to a function value.</p>
<p>Let&#39;s go back to the original and working definition of <code>open_window</code>
where we had the extra unlabelled <code>unit</code> argument at the end:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_window <span class='o'>?</span>title <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    <span class='k'>let</span> window <span class='k'>=</span> create_window () <span class='k'>in</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_width window) width<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_height window) height<span class='o'>;</span>
    window
<a href="javascript:octry('  let open_window ?title ?width ?height () =\n    let window = create_window () in\n    may ~f:(set_title window) title;\n    may ~f:(set_width window) width;\n    may ~f:(set_height window) height;\n    window\n');">[try]</a></code></pre>
<p>
If you want to pass optional arguments to <code>open_window</code> you must do so
before the final <code>unit</code>, so if you type:</p>
<pre><code class='ocaml'>  open_window ()<span class='o'>;;</span>
<a href="javascript:octry('  open_window ();;\n');">[try]</a></code></pre>
<p>
you must mean &quot;execute <code>open_window</code> now with all optional arguments
unspecified&quot;. Whereas if you type:</p>
<pre><code class='ocaml'>open_window<span class='o'>;;</span>
<a href="javascript:octry('open_window;;\n');">[try]</a></code></pre>
<p>
you mean &quot;give me the functional value&quot; or (more usually in the
toplevel) &quot;print out the type of <code>open_window</code>&quot;.</p>
<h3 id="Moreshorthand"> More <code>~</code>shorthand</h3><p>
Let&#39;s rewrite the <code>range</code> function yet again, this time using as much
shorthand as possible for the labels:</p>
<pre><code class='ocaml'>  <span class='k'>let rec</span> range <span class='o'>~</span>first <span class='o'>~</span>last <span class='k'>=</span>
    <span class='k'>if</span> first <span class='o'>&#62;</span> last <span class='k'>then</span> <span class='o'>[</span><span class='o'>]</span>
    <span class='k'>else</span> first <span class='o'>::</span> range <span class='o'>~</span>first<span class='o'>:</span>(first<span class='o'>+</span>1) <span class='o'>~</span>last
<a href="javascript:octry('  let rec range ~first ~last =\n    if first &#62; last then []\n    else first :: range ~first:(first+1) ~last\n');">[try]</a></code></pre>
<p>
Recall that <code>~foo</code> on its own is short for <code>~foo:foo</code>. This applies also
when calling functions as well as declaring the arguments to functions,
hence in the above the highlighted red <code>~last</code> is short for
<code>~last:last</code>.</p>
<h3 id="Usingfooinafunctioncall"> Using <code>?foo</code> in a function call</h3><p>
There&#39;s another little wrinkle concerning optional arguments. Suppose we
write a function around <code>open_window</code> to open up an application:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_application <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> <span class='o'>~</span>width <span class='o'>~</span>height
<a href="javascript:octry('  let open_application ?width ?height () =\n    open_window ~title:&#34;My Application&#34; ~width ~height\n');">[try]</a></code></pre>
<p>
Recall that <code>~width</code> is shorthand for <code>~width:width</code>. The type of
<code>width</code> is <code>&#39;a option</code>, but <code>open_window ~width:</code> expects an <code>int</code>.</p>
<p>OCaml provides more syntactic sugar. Writing <code>?width</code> in the function
call is shorthand for writing <code>~width:(unwrap width)</code> where <code>unwrap</code>
would be a function which would remove the &quot;<code>option</code> wrapper&quot; around
<code>width</code> (it&#39;s not actually possible to write an <code>unwrap</code> function like
this, but conceptually that&#39;s the idea). So the correct way to write
this function is:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_application <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> <span class='o'>?</span>width <span class='o'>?</span>height
<a href="javascript:octry('  let open_application ?width ?height () =\n    open_window ~title:&#34;My Application&#34; ?width ?height\n');">[try]</a></code></pre>
<h3 id="Whenandwhennottouseand"> When and when not to use <code>~</code> and <code>?</code></h3><p>

The syntax for labels and optional arguments is confusing, and you may
often wonder when to use <code>~foo</code>, when to use <code>?foo</code> and when to use
plain <code>foo</code>. It&#39;s something of a black art which takes practice to get
right.</p>
<p><code>?foo</code> is only used when declaring the arguments of a function, ie:</p>
<pre><code class='ocaml'><span class='k'>let</span> f <span class='o'>?</span>arg1 <span class='o'>...</span> <span class='k'>=</span>
<a href="javascript:octry('let f ?arg1 ... =\n');">[try]</a></code></pre>
<p>
or when using the specialised &quot;unwrap <code>option</code> wrapper&quot; form for
function calls:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_application <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> <span class='o'>?</span>width <span class='o'>?</span>height
<a href="javascript:octry('  let open_application ?width ?height () =\n    open_window ~title:&#34;My Application&#34; ?width ?height\n');">[try]</a></code></pre>
<p>
The declaration <code>?foo</code> creates a variable called <code>foo</code>, so if you need
the value of <code>?foo</code>, use just <code>foo</code>.</p>
<p>The same applies to labels. Only use the <code>~foo</code> form when declaring
arguments of a function, ie:</p>
<pre><code class='ocaml'><span class='k'>let</span> f <span class='o'>~</span>foo<span class='o'>:</span>foo <span class='o'>...</span> <span class='k'>=</span>
<a href="javascript:octry('let f ~foo:foo ... =\n');">[try]</a></code></pre>
<p>
The declaration <code>~foo:foo</code> creates a variable called simply <code>foo</code>, so if
you need the value just use plain <code>foo</code>.</p>
<p>Things, however, get complicated for two reasons: Firstly the shorthand
form <code>~foo</code> (equivalent to <code>~foo:foo</code>), and secondly when you call a
function which takes a labelled or optional argument and you use the
shorthand form.</p>
<p>Here is some apparently obscure code from lablgtk to demonstrate all of
this:</p>
<pre><code class='ocaml'><span class='k'>let</span> html <span class='o'>?</span>border_width <span class='o'>?</span>width <span class='o'>?</span>height <span class='o'>?</span>packing <span class='o'>?</span>show () <span class='k'>=</span>  <span class='com2'>(* line 1 *)</span><!-- end comment -->
  <span class='k'>let</span> w <span class='k'>=</span> create () <span class='k'>in</span>
  load_empty w<span class='o'>;</span>
  <span class='m'>Container</span><span class='o'>.</span>set w <span class='o'>?</span>border_width <span class='o'>?</span>width <span class='o'>?</span>height<span class='o'>;</span>            <span class='com2'>(* line 4 *)</span><!-- end comment -->
  pack_return (<span class='k'>new</span> html w) <span class='o'>~</span>packing <span class='o'>~</span>show                  <span class='com2'>(* line 5 *)</span><!-- end comment -->
<a href="javascript:octry('let html ?border_width ?width ?height ?packing ?show () =  (* line 1 *)\n  let w = create () in\n  load_empty w;\n  Container.set w ?border_width ?width ?height;            (* line 4 *)\n  pack_return (new html w) ~packing ~show                  (* line 5 *)\n');">[try]</a></code></pre>
<p>
On line 1 we have the function definition. Notice there are 5 optional
arguments, and the mandatory <code>unit</code> 6<sup>th</sup> argument. Each of the
optional arguments is going to define a variable, eg. <code>border_width</code>, of
type <code>&#39;a option</code>.</p>
<p>On line 4 we use the special <code>?foo</code> form for passing optional arguments
to functions which take optional arguments. <code>Container.set</code> has the
following type:</p>
<pre><code class='ocaml'><span class='k'>module</span> Container <span class='k'>=</span> <span class='k'>struct</span>
  <span class='k'>let</span> set <span class='o'>?</span>border_width <span class='o'>?</span>(width <span class='k'>=</span> -2) <span class='o'>?</span>(height <span class='k'>=</span> -2) w <span class='k'>=</span>
    <span class='com2'>(* <span class='ic'>...</span> *)</span><!-- end comment -->
<a href="javascript:octry('module Container = struct\n  let set ?border_width ?(width = -2) ?(height = -2) w =\n    (* ... *)\n');">[try]</a></code></pre>
<p>
Line 5 uses the <code>~</code>shorthand. Writing this in long form:</p>
<pre><code class='ocaml'>  pack_return (<span class='k'>new</span> html w) <span class='o'>~</span>packing<span class='o'>:</span>packing <span class='o'>~</span>show<span class='o'>:</span>show
<a href="javascript:octry('  pack_return (new html w) ~packing:packing ~show:show\n');">[try]</a></code></pre>
<p>
The <code>pack_return</code> function actually takes mandatory labelled arguments
called <code>~packing</code> and <code>~show</code>, each of type <code>&#39;a option</code>. In other words,
<code>pack_return</code> explicitly unwraps the <code>option</code> wrapper.</p>
<h3 id="Addendum"> Addendum</h3><p>
If you think labels and optional arguments are complicated, that&#39;s
because they are! Luckily, however, this is a relatively new feature in
OCaml, and it&#39;s not yet widely used. In fact if you&#39;re not hacking on
lablgtk, it&#39;s unlikely you&#39;ll see labels and optional arguments used at
all (at the moment).</p>
<h2 id="Morevariantsquotpolymorphicvariantsquot"> More variants (&quot;polymorphic variants&quot;)</h2><p>
Try compiling the following C code:</p>
<pre><code class='ocaml'><span class='o'>#</span><span class='k'>include</span> <span class='o'>&#60;</span>stdio<span class='o'>.</span>h<span class='o'>&#62;</span>
<span class='o'>#</span><span class='k'>include</span> <span class='o'>&#60;</span>fcntl<span class='o'>.</span>h<span class='o'>&#62;</span>
<span class='o'>#</span><span class='k'>include</span> <span class='o'>&#60;</span>unistd<span class='o'>.</span>h<span class='o'>&#62;</span>

enum lock <span class='o'>{</span> <span class='k'>open</span><span class='o'>,</span> close <span class='o'>}</span><span class='o'>;</span>

main ()
<span class='o'>{</span>
  int fd<span class='o'>,</span> n<span class='o'>;</span>
  char buffer<span class='o'>[</span>256<span class='o'>]</span><span class='o'>;</span>

  fd <span class='k'>=</span> <span class='k'>open</span> (<span class='s'>&#34;/etc/motd&#34;</span><span class='o'>,</span> O_RDONLY)<span class='o'>;</span>                     <span class='o'>//</span> line 12
  <span class='k'>while</span> ((n <span class='k'>=</span> read (fd<span class='o'>,</span> buffer<span class='o'>,</span> sizeof buffer)) <span class='o'>&#62;</span> 0)
    write (1<span class='o'>,</span> buffer<span class='o'>,</span> n)<span class='o'>;</span>
  close (fd)<span class='o'>;</span>                                            <span class='o'>//</span> line 15
<span class='o'>}</span>
<a href="javascript:octry('#include &#60;stdio.h&#62;\n#include &#60;fcntl.h&#62;\n#include &#60;unistd.h&#62;\n\nenum lock { open, close };\n\nmain ()\n{\n  int fd, n;\n  char buffer[256];\n\n  fd = open (&#34;/etc/motd&#34;, O_RDONLY);                     // line 12\n  while ((n = read (fd, buffer, sizeof buffer)) &#62; 0)\n    write (1, buffer, n);\n  close (fd);                                            // line 15\n}\n');">[try]</a></code></pre>
<p>
When I compile the code I get a whole bunch of errors including:</p>
<pre><code class='ocaml'>test<span class='o'>.</span>c<span class='o'>:</span> In <span class='k'>function</span> `main'<span class='o'>:</span>
test<span class='o'>.</span>c<span class='o'>:</span>12<span class='o'>:</span> error<span class='o'>:</span> called object is not a <span class='k'>function</span>
test<span class='o'>.</span>c<span class='o'>:</span>15<span class='o'>:</span> error<span class='o'>:</span> called object is not a <span class='k'>function</span>
<a href="javascript:octry('test.c: In function `main&#39;:\ntest.c:12: error: called object is not a function\ntest.c:15: error: called object is not a function\n');">[try]</a></code></pre>
<p>
This illustrates one problem with enumerated types (enums) in C. In the
example above, one enum statement reserves <em>three</em> symbols, namely
<code>lock</code>, <code>open</code> and <code>close</code>. Here&#39;s another example:</p>
<pre><code class='ocaml'>enum lock <span class='o'>{</span> <span class='k'>open</span><span class='o'>,</span> close <span class='o'>}</span><span class='o'>;</span>
enum door <span class='o'>{</span> <span class='k'>open</span><span class='o'>,</span> close <span class='o'>}</span><span class='o'>;</span>
<a href="javascript:octry('enum lock { open, close };\nenum door { open, close };\n');">[try]</a></code></pre>
<p>
Compiling gives:</p>
<pre><code class='ocaml'>test<span class='o'>.</span>c<span class='o'>:</span>2<span class='o'>:</span> error<span class='o'>:</span> conflicting types <span class='k'>for</span> `<span class='k'>open</span>'
test<span class='o'>.</span>c<span class='o'>:</span>1<span class='o'>:</span> error<span class='o'>:</span> previous declaration <span class='k'>of</span> `<span class='k'>open</span>'
test<span class='o'>.</span>c<span class='o'>:</span>2<span class='o'>:</span> error<span class='o'>:</span> conflicting types <span class='k'>for</span> `close'
test<span class='o'>.</span>c<span class='o'>:</span>1<span class='o'>:</span> error<span class='o'>:</span> previous declaration <span class='k'>of</span> `close'
<a href="javascript:octry('test.c:2: error: conflicting types for `open&#39;\ntest.c:1: error: previous declaration of `open&#39;\ntest.c:2: error: conflicting types for `close&#39;\ntest.c:1: error: previous declaration of `close&#39;\n');">[try]</a></code></pre>
<p>
The first enum defines the symbol <code>open</code> as something of type
<code>enum lock</code>. You cannot reuse that symbol in another enum.</p>
<p>This will be familiar to most C/C++ programmers, and they won&#39;t write
naive code like that above. However the same issue happens with OCaml
variants, but OCaml provides a way to work around it.</p>
<p>Here is some OCaml code, which actually <em>does</em> compile:</p>
<pre><code class='ocaml'><span class='k'>type</span> lock <span class='k'>=</span> Open <span class='o'>|</span> Close
<span class='k'>type</span> door <span class='k'>=</span> Open <span class='o'>|</span> Close
<a href="javascript:octry('type lock = Open | Close\ntype door = Open | Close\n');">[try]</a></code></pre>
<p>
After running those two statements, what is the type of <code>Open</code>? We can
find out easily enough in the toplevel:</p>
<pre><code class='ocaml'><span class='k'>type</span> lock <span class='k'>=</span> Open <span class='o'>|</span> Close<span class='o'>;;</span>
<span class='k'>type</span> door <span class='k'>=</span> Open <span class='o'>|</span> Close<span class='o'>;;</span>
Open<span class='o'>;;</span>
<a href="javascript:octry('type lock = Open | Close;;\ntype door = Open | Close;;\nOpen;;\n');">[try]</a></code></pre>
<p>
OCaml uses the most recent definition for <code>Open</code>, giving it the type
<code>door</code>. This is actually not such a serious problem because if you
accidentally tried to use <code>Open</code> in the type context of a <code>lock</code>, then
OCaml&#39;s wonderful type inference would immediately spot the error and
you wouldn&#39;t be able to compile the code.</p>
<p>So far, so much like C. Now I said that OCaml provides a way to work
around the constraint that <code>Open</code> can only have one type. In other
words, suppose I want to use <code>Open</code> to mean either &quot;the <code>Open</code> of type
<code>lock</code>&quot; or &quot;the <code>Open</code> of type <code>door</code>&quot; and I want OCaml to work out
which one I mean.</p>
<p>The syntax is slightly different, but here is how we do it:</p>
<pre><code class='ocaml'><span class='k'>type</span> lock <span class='k'>=</span> <span class='o'>[</span> `Open <span class='o'>|</span> `Close <span class='o'>]</span><span class='o'>;;</span>
<span class='k'>type</span> door <span class='k'>=</span> <span class='o'>[</span> `Open <span class='o'>|</span> `Close <span class='o'>]</span><span class='o'>;;</span>
<a href="javascript:octry('type lock = [ `Open | `Close ];;\ntype door = [ `Open | `Close ];;\n');">[try]</a></code></pre>
<p>
Notice the syntactic differences:</p>
<ol>
 <li>Each variant name is prefixed with <code>`</code> (a back tick).
 </li>
 <li>You have to put square brackets (<code>[]</code>) around the alternatives.</li>
</ol>

<p>The question naturally arises: What is the type of <code>`Ope</code>?</p>
<pre><code class='ocaml'>`Open<span class='o'>;;</span>
<a href="javascript:octry('`Open;;\n');">[try]</a></code></pre>
<p>
<code> [&gt; `Open] </code> can be read as
<code> [ `Open | and some other possibilities which we don&#39;t know about ] </code>.
The \&gt; (greater than) sign indicates that the set of possibilities is
bigger than those listed (open-ended).</p>
<p>There&#39;s nothing special about <code>`Ope</code>. <em>Any</em> back-ticked word can be
used as a type, even one which we haven&#39;t mentioned before:</p>
<pre><code class='ocaml'>`Foo<span class='o'>;;</span>
`Foo 42<span class='o'>;;</span>
<a href="javascript:octry('`Foo;;\n`Foo 42;;\n');">[try]</a></code></pre>
<p>
Let&#39;s write a function to print the state of a <code>lock</code>:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> print_lock st <span class='k'>=</span>
    <span class='k'>match</span> st <span class='k'>with</span>
    <span class='o'>|</span> `Open <span class='k'>-></span> print_endline <span class='s'>&#34;The lock is open&#34;</span>
    <span class='o'>|</span> `Close <span class='k'>-></span> print_endline <span class='s'>&#34;The lock is closed&#34;</span>
<a href="javascript:octry('  let print_lock st =\n    match st with\n    | `Open -&#62; print_endline &#34;The lock is open&#34;\n    | `Close -&#62; print_endline &#34;The lock is closed&#34;\n');">[try]</a></code></pre>
<p>
Take a careful look at the type of that function. Type inference has
worked out that the <code>st</code> argument has type <code> [&lt; `Close | `Open] </code>. The
\&lt; (less than) sign means that this is a \&lt;dfn\&gt;closed class\&lt;/dfn\&gt;. In
other words, this function will only work on <code>`Clos</code> or <code>`Ope</code>
and not on anything else.</p>
<pre><code class='ocaml'>print_lock `Open<span class='o'>;;</span>
<a href="javascript:octry('print_lock `Open;;\n');">[try]</a></code></pre>
<p>
Notice that <code>print_lock</code> works just as well with a <code>door</code> as with a
<code>lock</code>! We&#39;ve deliberately given up some type safety, and type inference
is now being used to help guess what we mean, rather than enforce
correct coding.</p>
<p>This is only an introduction to polymorphic variants. Because of the
reduction in type safety, it is recommended that you don&#39;t use these in
your code. You will, however, see them in advanced OCaml code quite a
lot precisely because advanced programmers will sometimes want to weaken
the type system to write advanced idioms.</p>

      </div>
    </div>
  </div>
</div>

    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-left">
            <li><a onclick="document.getElementById('footer').style.display='none'">[X]</a></li>

            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/tree/master/md-pages/learn/tutorials/labels.md">Edit this page</a></li>
          </ul>
          <ul class="nav pull-right">
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Feedback</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Contact us</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      // <!--
      if(document.getElementsByTagName('pre').length > 0)
         octry('')
      // -->
    </script>
  </body>
</html>
