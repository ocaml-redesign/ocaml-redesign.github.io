<h1 id="Labels"> Labels</h1><h2 id="Exceptionsandhashtables"> Exceptions and hash tables</h2><p>

<em>(unfinished)</em></p>
<h2 id="Mutuallyrecursivefunctions"> Mutually recursive functions</h2><p>
Suppose I want to define two functions which call each other. This is
actually not a very common thing to do, but it can be useful sometimes.
Here&apos;s a contrived example (thanks to Ryan Tarpine): The number 0 is
even. Other numbers greater than 0 are even if their predecessor is odd.
Hence:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> even n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>true</span>
  <span class='o'>|</span> x <span class='k'>-></span> odd (x-1)
</code></pre>
<p>
The code above doesn&apos;t compile because we haven&apos;t defined the function
<code>odd</code> yet! That&apos;s easy though. Zero is not odd, and other numbers
greater than 0 are odd if their predecessor is even. So to make this
complete we need that function too:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> even n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>true</span>
  <span class='o'>|</span> x <span class='k'>-></span> odd (x-1)

<span class='k'>let rec</span> odd n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>false</span>
  <span class='o'>|</span> x <span class='k'>-></span> even (x-1)
</code></pre>
<p>
The only problem is... this program doesn&apos;t compile. In order to compile
the <code>even</code> function, we already need the definition of <code>odd</code>, and to
compile <code>odd</code> we need the definition of <code>even</code>. So swapping the two
definitions around won&apos;t help either.</p>
<p>There are no &quot;forward prototypes&quot; in OCaml but there is a special syntax
for defining a set of two or more mutually recursive functions, like
<code>odd</code> and <code>even</code>:</p>
<pre><code class='ocaml'><span class='k'>let rec</span> even n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>true</span>
  <span class='o'>|</span> x <span class='k'>-></span> odd (x-1)
<span class='k'>and</span> odd n <span class='k'>=</span>
  <span class='k'>match</span> n <span class='k'>with</span>
  <span class='o'>|</span> 0 <span class='k'>-></span> <span class='o'>false</span>
  <span class='o'>|</span> x <span class='k'>-></span> even (x-1)
</code></pre>
<p>
It&apos;s hard to know exactly how useful this is in practice, since I&apos;ve
never had cause to write mutually recursive functions, nor have I been
able to think of a non-trivial example. However it&apos;s there. You can also
use similar syntax for writing mutually recursive class definitions and
modules.</p>
<h2 id="Aliasesforfunctionnamesandarguments"> Aliases for function names and arguments</h2><p>
Recall in Chapter 5 we talked about partial function application. It&apos;s
possible to use this as a neat trick to save typing: aliasing function
names, and function arguments.</p>
<p>Although we haven&apos;t looked at object-oriented programming (that&apos;s the
subject for the next chapter), here&apos;s an example from OCamlNet of an
aliased function call. All you need to know is that
<code>cgi # output # output_string &quot;string&quot;</code> is a method call, similar to
<code>cgi.output().output_string (&quot;string&quot;)</code> in Java.</p>
<pre><code class='ocaml'><span class='k'>let</span> begin_page cgi title <span class='k'>=</span>
  <span class='k'>let</span> out <span class='k'>=</span> cgi <span class='o'>#</span> output <span class='o'>#</span> output_string <span class='k'>in</span>
  out <span class='s'>&#34;&#60;html&#62;\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;head&#62;\n&#34;</span><span class='o'>;</span>
  out (<span class='s'>&#34;&#60;title&#62;&#34;</span> <span class='o'>^</span> text title <span class='o'>^</span> <span class='s'>&#34;&#60;/title&#62;\n&#34;</span>)<span class='o'>;</span>
  out (<span class='s'>&#34;&#60;style type=\&#34;text/css\&#34;&#62;\n&#34;</span>)<span class='o'>;</span>
  out <span class='s'>&#34;body { background: white; color: black; }\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;/style&#62;\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;/head&#62;\n&#34;</span><span class='o'>;</span>
  out <span class='s'>&#34;&#60;body&#62;\n&#34;</span><span class='o'>;</span>
  out (<span class='s'>&#34;&#60;h1&#62;&#34;</span> <span class='o'>^</span> text title <span class='o'>^</span> <span class='s'>&#34;&#60;/h1&#62;\n&#34;</span>)
</code></pre>
<p>
The <code>let out = ... </code> is a partial function application for that method
call (partial, because the string parameter hasn&apos;t been applied). <code>out</code>
is therefore a function, which takes a string parameter.</p>
<pre><code class='ocaml'>  out <span class='s'>&#34;&#60;html&#62;\n&#34;</span><span class='o'>;</span>
</code></pre>
<p>
is equivalent to:</p>
<pre><code class='ocaml'>  cgi <span class='o'>#</span> output <span class='o'>#</span> output_string <span class='s'>&#34;&#60;html&#62;\n&#34;</span><span class='o'>;</span>
</code></pre>
<p>
We saved ourselves a lot of typing there.</p>
<p>We can also add arguments. This alternative definition of <code>print_string</code>
can be thought of as a kind of alias for a function name plus arguments:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> print_string <span class='k'>=</span> output_string stdout
</code></pre>
<p>
<code>output_string</code> takes two arguments (a channel and a string), but since
we have only supplied one, it is partially applied. So <code>print_string</code> is
a function, expecting one string argument.</p>
<h2 id="Labelledandoptionalargumentstofunctions"> Labelled and optional arguments to functions</h2><h3 id="Labelledarguments"> Labelled arguments</h3><p>

Python has the nicest syntax for writing arguments to functions. Here&apos;s
an example (from the Python tutorial, since I&apos;m not a Python
programmer):</p>
<pre><code class='ocaml'>def ask_ok(prompt<span class='o'>,</span> retries<span class='k'>=</span>4<span class='o'>,</span> complaint<span class='k'>=</span>'Yes <span class='k'>or</span> no<span class='o'>,</span> please<span class='o'>!</span>')<span class='o'>:</span>
  <span class='o'>#</span> <span class='k'>function</span> definition omitted
</code></pre>
<p>
Here are the ways we can call this Python function:</p>
<pre><code class='ocaml'>ask_ok ('Do you really want <span class='k'>to</span> quit?')
ask_ok ('Overwrite the file?'<span class='o'>,</span> 2)
ask_ok (prompt<span class='k'>=</span>'Are you sure?')
ask_ok (complaint<span class='k'>=</span>'Please answer yes <span class='k'>or</span> no<span class='o'>!</span>'<span class='o'>,</span> prompt<span class='k'>=</span>'Are you sure?')
</code></pre>
<p>
Notice that in Python we are allowed to name arguments when we call
them, or use the usual function call syntax, and we can have optional
arguments with default values.</p>
<p>You can do something similar in Perl:</p>
<pre><code class='ocaml'>sub ask_ok
<span class='o'>{</span>
  my <span class='o'>%</span>params <span class='k'>=</span> <span class='o'>@_;</span>

  my <span class='o'>$</span>prompt <span class='k'>=</span> <span class='o'>$</span>params<span class='o'>{</span>prompt<span class='o'>}</span><span class='o'>;</span>
  my <span class='o'>$</span>retries <span class='k'>=</span> exists <span class='o'>$</span>params<span class='o'>{</span>retries<span class='o'>}</span> <span class='o'>?</span> <span class='o'>$</span>params<span class='o'>{</span>retries<span class='o'>}</span> <span class='o'>:</span> 4<span class='o'>;</span>

  <span class='o'>#</span> <span class='o'>...</span> etc<span class='o'>.</span>
<span class='o'>}</span>

ask_ok (prompt <span class='o'>=&#62;</span> <span class='s'>&#34;Are you sure?&#34;</span><span class='o'>,</span> retries <span class='o'>=&#62;</span> 2)<span class='o'>;</span>
</code></pre>
<p>
OCaml also has a way to label arguments and have optional arguments with
default values.</p>
<p>The basic syntax is:</p>
<pre><code class='ocaml'>  <span class='k'>let rec</span> range <span class='o'>~</span>first<span class='o'>:</span>a <span class='o'>~</span>last<span class='o'>:</span>b <span class='k'>=</span>
    <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> <span class='o'>[</span><span class='o'>]</span>
    <span class='k'>else</span> a <span class='o'>::</span> range <span class='o'>~</span>first<span class='o'>:</span>(a<span class='o'>+</span>1) <span class='o'>~</span>last<span class='o'>:</span>b
</code></pre>
<p>
(Notice that both <code>to</code> and <code>end</code> are reserved words in OCaml, so they
cannot be used as labels. So you cannot have <code>~from/~to</code> or
<code>~start/~end</code>.)</p>
<p>The type of our previous <code>range</code> function was:</p>
<pre><code class='ocaml'>range <span class='o'>:</span> int <span class='k'>-></span> int <span class='k'>-></span> int list
</code></pre>
<p>
And the type of our new <code>range</code> function with labelled arguments is:</p>
<pre><code class='ocaml'>range <span class='o'>:</span> first<span class='o'>:</span>int <span class='k'>-></span> last<span class='o'>:</span>int <span class='k'>-></span> int list
</code></pre>
<p>
(Confusingly, the <code>~</code> (tilde) is <em>not</em> shown in the type definition, but
you need to use it everywhere else).</p>
<p>With labelled arguments, it doesn&apos;t matter which order you give the
arguments anymore:</p>
<pre><code class='ocaml'>range <span class='o'>~</span>first<span class='o'>:</span>1 <span class='o'>~</span>last<span class='o'>:</span>10<span class='o'>;;</span>
range <span class='o'>~</span>last<span class='o'>:</span>10 <span class='o'>~</span>first<span class='o'>:</span>1<span class='o'>;;</span>
</code></pre>
<p>
There is also a shorthand way to name the arguments, so that the label
is the same as the variable in the function definition. Here is a
function defined in <code>lablgtk/gaux.ml</code> (a library of useful oddities used
in lablgtk):</p>
<pre><code class='ocaml'>  <span class='k'>let</span> may <span class='o'>~</span>f x <span class='k'>=</span>
    <span class='k'>match</span> x <span class='k'>with</span>
    <span class='o'>|</span> None <span class='k'>-></span> ()
    <span class='o'>|</span> Some x <span class='k'>-></span> ignore(f x)
</code></pre>
<p>
It&apos;s worth spending some time working out exactly what this function
does, and also working out by hand its type signature. There&apos;s a lot
going on. First of all, the parameter <code>~f</code> is just shorthand for <code>~f:f</code>
(ie. the label is <code>~f</code> and the variable used in the function is <code>f</code>).
Secondly notice that the function takes two parameters. The second
parameter (<code>x</code>) is unlabelled - it is permitted for a function to take a
mixture of labelled and unlabelled arguments if you want.</p>
<p>What is the type of the labelled <code>f</code> parameter? Obviously it&apos;s a
function of some sort.</p>
<p>What is the type of the unlabelled <code>x</code> parameter? The <code>match</code> clause
gives us a clue. It&apos;s an <code>&apos;a option</code>.</p>
<p>This tells us that <code>f</code> takes an <code>&apos;a</code> parameter, and the return value of
<code>f</code> is ignored, so it could be anything. The type of <code>f</code> is therefore
<code>&apos;a -&gt; &apos;b</code>.</p>
<p>The <code>may</code> function as a whole returns <code>unit</code>. Notice in each case of the
<code>match</code> the result is <code>()</code>.</p>
<p>Thus the type of the <code>may</code> function is (and you can verify this in the
OCaml toplevel if you want):</p>
<pre><code class='ocaml'>may <span class='o'>:</span> f<span class='o'>:</span>('a <span class='k'>-></span> 'b) <span class='k'>-></span> 'a option <span class='k'>-></span> unit
</code></pre>
<p>
What does this function do? Running the function in the OCaml toplevel
gives us some clues:</p>
<pre><code class='ocaml'>may <span class='o'>~</span>f<span class='o'>:</span>print_endline None<span class='o'>;;</span>
may <span class='o'>~</span>f<span class='o'>:</span>print_endline (Some <span class='s'>&#34;hello&#34;</span>)<span class='o'>;;</span>
</code></pre>
<p>
If the unlabelled argument is a &quot;null pointer&quot; then <code>may</code> does nothing.
Otherwise <code>may</code> calls the <code>f</code> function on the argument. Why is this
useful? We&apos;re just about to find out ...</p>
<h3 id="Optionalarguments"> Optional arguments</h3><p>
Optional arguments are like labelled arguments, but we use <code>?</code> instead
of <code>~</code> in front of them. Here is an example:</p>
<pre><code class='ocaml'>  <span class='k'>let rec</span> range <span class='o'>?</span>(step<span class='k'>=</span>1) a b <span class='k'>=</span>
    <span class='k'>if</span> a <span class='o'>&#62;</span> b <span class='k'>then</span> <span class='o'>[</span><span class='o'>]</span>
    <span class='k'>else</span> a <span class='o'>::</span> range <span class='o'>~</span>step (a<span class='o'>+</span>step) b
</code></pre>
<p>
Note the somewhat confusing syntax, switching between <code>?</code> and <code>~</code>. We&apos;ll
talk about that in the next section. Here is how you call this function:</p>
<pre><code class='ocaml'>range 1 10<span class='o'>;;</span>
range 1 10 <span class='o'>~</span>step<span class='o'>:</span>2<span class='o'>;;</span>
</code></pre>
<p>
In this case, <code>?(step=1)</code> fairly obviously means that <code>~step</code> is an
optional argument which defaults to 1. We can also omit the default
value and just have an optional argument. This example is modified from
lablgtk:</p>
<pre><code class='ocaml'>  <span class='k'>type</span> window <span class='k'>=</span> <span class='o'>{</span> <span class='k'>mutable</span> title<span class='o'>:</span> string<span class='o'>;</span>
                  <span class='k'>mutable</span> width<span class='o'>:</span> int<span class='o'>;</span>
                  <span class='k'>mutable</span> height<span class='o'>:</span> int <span class='o'>}</span>
  
  <span class='k'>let</span> create_window () <span class='k'>=</span>
    <span class='o'>{</span> title <span class='k'>=</span> <span class='s'>&#34;none&#34;</span><span class='o'>;</span> width <span class='k'>=</span> 640<span class='o'>;</span> height <span class='k'>=</span> 480<span class='o'>;</span> <span class='o'>}</span>
  
  <span class='k'>let</span> set_title window title <span class='k'>=</span>
    window<span class='o'>.</span>title <span class='o'>&#60;-</span> title
  
  <span class='k'>let</span> set_width window width <span class='k'>=</span>
    window<span class='o'>.</span>width <span class='o'>&#60;-</span> width
  
  <span class='k'>let</span> set_height window height <span class='k'>=</span>
    window<span class='o'>.</span>height <span class='o'>&#60;-</span> height
  
  <span class='k'>let</span> open_window <span class='o'>?</span>title <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    <span class='k'>let</span> window <span class='k'>=</span> create_window () <span class='k'>in</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_width window) width<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_height window) height<span class='o'>;</span>
    window
</code></pre>
<p>
This example is significantly complex and quite subtle, but the pattern
used is very common in the lablgtk source code. Let&apos;s concentrate on the
simple <code>create_window</code> function first. This function takes a <code>unit</code> and
returns a <code>window</code>, initialized with default settings for title, width
and height:</p>
<pre><code class='ocaml'>create_window ()<span class='o'>;;</span>
</code></pre>
<p>
The <code>set_title</code>, <code>set_width</code> and <code>set_height</code> functions are impure
functions which modify the <code>window</code> structure, in the obvious way. For
example:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> w <span class='k'>=</span> create_window () <span class='k'>in</span>
  set_title w <span class='s'>&#34;My Application&#34;</span><span class='o'>;</span>
  w<span class='o'>;;</span>
</code></pre>
<p>
So far this is just the imperative &quot;mutable records&quot; which we talked
about in the previous chapter. Now the complex part is the <code>open_window</code>
function. This function takes <em>4</em> arguments, three of them optional,
followed by a required, unlabelled <code>unit</code>. Let&apos;s first see this function
in action:</p>
<pre><code class='ocaml'>open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> ()<span class='o'>;;</span>
open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;Clock&#34;</span> <span class='o'>~</span>width<span class='o'>:</span>128 <span class='o'>~</span>height<span class='o'>:</span>128 ()<span class='o'>;;</span>
</code></pre>
<p>
It does what you expect, but how?! The secret is in the <code>may</code> function
(see above) and the fact that the optional parameters <em>don&apos;t</em> have
defaults.</p>
<p>When an optional parameter doesn&apos;t have a default, then it has type
<code>&apos;a option</code>. The <code>&apos;a</code> would normally be inferred by type inference, so
in the case of <code>?title</code> above, this has type <code>string option</code>.</p>
<p>Remember the <code>may</code> function? It takes a function and an argument, and
calls the function on the argument provided the argument isn&apos;t <code>None</code>.
So:</p>
<pre><code class='ocaml'>may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
</code></pre>
<p>
If the optional title argument is not specified by the caller, then
<code>title</code> = <code>None</code>, so <code>may</code> does nothing. But if we call the function
with, for example, <code>open_window ~title:&quot;My Application&quot; ();;</code>, then
<code>title</code> = <code>Some &quot;My Application&quot;</code>, and <code>may</code> therefore calls
<code>set_title window &quot;My Application&quot;</code>.</p>
<p>You should make sure you fully understand this example before proceeding
to the next section.</p>
<h3 id="quotWarningThisoptionalargumentcannotbeerasedquot"> &quot;Warning: This optional argument cannot be erased&quot;</h3><p>
We&apos;ve just touched upon labels and optional arguments, but even this
brief explanation should have raised several questions. The first may be
why the extra <code>unit</code> argument to <code>open_window</code>? Let&apos;s try defining this
function without the extra <code>unit</code>:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_window <span class='o'>?</span>title <span class='o'>?</span>width <span class='o'>?</span>height <span class='k'>=</span>
    <span class='k'>let</span> window <span class='k'>=</span> create_window () <span class='k'>in</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_width window) width<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_height window) height<span class='o'>;</span>
    window
</code></pre>
<p>
Although OCaml has compiled the function, it has generated a somewhat
infamous warning: &quot;This optional argument cannot be erased&quot;, referring
to the final <code>?height</code> argument. To try to show what&apos;s going on here,
let&apos;s call our modified <code>open_window</code> function:</p>
<pre><code class='ocaml'>open_window<span class='o'>;;</span>
open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span><span class='o'>;;</span>
</code></pre>
<p>
Did that work or not? No it didn&apos;t. In fact it didn&apos;t even run the
<code>open_window</code> function at all. Instead it printed some strange type
information. What&apos;s going on?</p>
<p>Recall currying and uncurrying, and partial application of functions. If
we have a function <code>plus</code> defined as:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> plus x y <span class='k'>=</span>
    x <span class='o'>+</span> y
</code></pre>
<p>
We can partially apply this, for example as <code>plus 2</code> which is &quot;the
function that adds 2 to things&quot;:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> f <span class='k'>=</span> plus 2<span class='o'>;;</span>
  f 5<span class='o'>;;</span>
  f 100<span class='o'>;;</span>
</code></pre>
<p>
In the <code>plus</code> example, the OCaml compiler can easily work out that
<code>plus 2</code> doesn&apos;t have enough arguments supplied yet. It needs another
argument before the <code>plus</code> function itself can be executed. Therefore
<code>plus 2</code> is a function which is waiting for its extra argument to come
along.</p>
<p>Things are not so clear when we add optional arguments into the mix. The
call to <code>open_window;;</code> above is a case in point. Does the user mean
&quot;execute <code>open_window</code> now&quot;? Or does the user mean to supply some or all
of the optional arguments later? Is <code>open_window;;</code> waiting for extra
arguments to come along like <code>plus 2</code>?</p>
<p>OCaml plays it safe and doesn&apos;t execute <code>open_window</code>. Instead it treats
it as a partial function application. The expression <code>open_window</code>
literally evaluates to a function value.</p>
<p>Let&apos;s go back to the original and working definition of <code>open_window</code>
where we had the extra unlabelled <code>unit</code> argument at the end:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_window <span class='o'>?</span>title <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    <span class='k'>let</span> window <span class='k'>=</span> create_window () <span class='k'>in</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_title window) title<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_width window) width<span class='o'>;</span>
    may <span class='o'>~</span>f<span class='o'>:</span>(set_height window) height<span class='o'>;</span>
    window
</code></pre>
<p>
If you want to pass optional arguments to <code>open_window</code> you must do so
before the final <code>unit</code>, so if you type:</p>
<pre><code class='ocaml'>  open_window ()<span class='o'>;;</span>
</code></pre>
<p>
you must mean &quot;execute <code>open_window</code> now with all optional arguments
unspecified&quot;. Whereas if you type:</p>
<pre><code class='ocaml'>open_window<span class='o'>;;</span>
</code></pre>
<p>
you mean &quot;give me the functional value&quot; or (more usually in the
toplevel) &quot;print out the type of <code>open_window</code>&quot;.</p>
<h3 id="Moreshorthand"> More <code>~</code>shorthand</h3><p>
Let&apos;s rewrite the <code>range</code> function yet again, this time using as much
shorthand as possible for the labels:</p>
<pre><code class='ocaml'>  <span class='k'>let rec</span> range <span class='o'>~</span>first <span class='o'>~</span>last <span class='k'>=</span>
    <span class='k'>if</span> first <span class='o'>&#62;</span> last <span class='k'>then</span> <span class='o'>[</span><span class='o'>]</span>
    <span class='k'>else</span> first <span class='o'>::</span> range <span class='o'>~</span>first<span class='o'>:</span>(first<span class='o'>+</span>1) <span class='o'>~</span>last
</code></pre>
<p>
Recall that <code>~foo</code> on its own is short for <code>~foo:foo</code>. This applies also
when calling functions as well as declaring the arguments to functions,
hence in the above the highlighted red <code>~last</code> is short for
<code>~last:last</code>.</p>
<h3 id="Usingfooinafunctioncall"> Using <code>?foo</code> in a function call</h3><p>
There&apos;s another little wrinkle concerning optional arguments. Suppose we
write a function around <code>open_window</code> to open up an application:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_application <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> <span class='o'>~</span>width <span class='o'>~</span>height
</code></pre>
<p>
Recall that <code>~width</code> is shorthand for <code>~width:width</code>. The type of
<code>width</code> is <code>&apos;a option</code>, but <code>open_window ~width:</code> expects an <code>int</code>.</p>
<p>OCaml provides more syntactic sugar. Writing <code>?width</code> in the function
call is shorthand for writing <code>~width:(unwrap width)</code> where <code>unwrap</code>
would be a function which would remove the &quot;<code>option</code> wrapper&quot; around
<code>width</code> (it&apos;s not actually possible to write an <code>unwrap</code> function like
this, but conceptually that&apos;s the idea). So the correct way to write
this function is:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_application <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> <span class='o'>?</span>width <span class='o'>?</span>height
</code></pre>
<h3 id="Whenandwhennottouseand"> When and when not to use <code>~</code> and <code>?</code></h3><p>

The syntax for labels and optional arguments is confusing, and you may
often wonder when to use <code>~foo</code>, when to use <code>?foo</code> and when to use
plain <code>foo</code>. It&apos;s something of a black art which takes practice to get
right.</p>
<p><code>?foo</code> is only used when declaring the arguments of a function, ie:</p>
<pre><code class='ocaml'><span class='k'>let</span> f <span class='o'>?</span>arg1 <span class='o'>...</span> <span class='k'>=</span>
</code></pre>
<p>
or when using the specialised &quot;unwrap <code>option</code> wrapper&quot; form for
function calls:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> open_application <span class='o'>?</span>width <span class='o'>?</span>height () <span class='k'>=</span>
    open_window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My Application&#34;</span> <span class='o'>?</span>width <span class='o'>?</span>height
</code></pre>
<p>
The declaration <code>?foo</code> creates a variable called <code>foo</code>, so if you need
the value of <code>?foo</code>, use just <code>foo</code>.</p>
<p>The same applies to labels. Only use the <code>~foo</code> form when declaring
arguments of a function, ie:</p>
<pre><code class='ocaml'><span class='k'>let</span> f <span class='o'>~</span>foo<span class='o'>:</span>foo <span class='o'>...</span> <span class='k'>=</span>
</code></pre>
<p>
The declaration <code>~foo:foo</code> creates a variable called simply <code>foo</code>, so if
you need the value just use plain <code>foo</code>.</p>
<p>Things, however, get complicated for two reasons: Firstly the shorthand
form <code>~foo</code> (equivalent to <code>~foo:foo</code>), and secondly when you call a
function which takes a labelled or optional argument and you use the
shorthand form.</p>
<p>Here is some apparently obscure code from lablgtk to demonstrate all of
this:</p>
<pre><code class='ocaml'><span class='k'>let</span> html <span class='o'>?</span>border_width <span class='o'>?</span>width <span class='o'>?</span>height <span class='o'>?</span>packing <span class='o'>?</span>show () <span class='k'>=</span>  <span class='com2'>(* line 1 *)</span><!-- end comment -->
  <span class='k'>let</span> w <span class='k'>=</span> create () <span class='k'>in</span>
  load_empty w<span class='o'>;</span>
  <span class='m'>Container</span><span class='o'>.</span>set w <span class='o'>?</span>border_width <span class='o'>?</span>width <span class='o'>?</span>height<span class='o'>;</span>            <span class='com2'>(* line 4 *)</span><!-- end comment -->
  pack_return (<span class='k'>new</span> html w) <span class='o'>~</span>packing <span class='o'>~</span>show                  <span class='com2'>(* line 5 *)</span><!-- end comment -->
</code></pre>
<p>
On line 1 we have the function definition. Notice there are 5 optional
arguments, and the mandatory <code>unit</code> 6<sup>th</sup> argument. Each of the
optional arguments is going to define a variable, eg. <code>border_width</code>, of
type <code>&apos;a option</code>.</p>
<p>On line 4 we use the special <code>?foo</code> form for passing optional arguments
to functions which take optional arguments. <code>Container.set</code> has the
following type:</p>
<pre><code class='ocaml'><span class='k'>module</span> Container <span class='k'>=</span> <span class='k'>struct</span>
  <span class='k'>let</span> set <span class='o'>?</span>border_width <span class='o'>?</span>(width <span class='k'>=</span> -2) <span class='o'>?</span>(height <span class='k'>=</span> -2) w <span class='k'>=</span>
    <span class='com2'>(* <span class='ic'>...</span> *)</span><!-- end comment -->
</code></pre>
<p>
Line 5 uses the <code>~</code>shorthand. Writing this in long form:</p>
<pre><code class='ocaml'>  pack_return (<span class='k'>new</span> html w) <span class='o'>~</span>packing<span class='o'>:</span>packing <span class='o'>~</span>show<span class='o'>:</span>show
</code></pre>
<p>
The <code>pack_return</code> function actually takes mandatory labelled arguments
called <code>~packing</code> and <code>~show</code>, each of type <code>&apos;a option</code>. In other words,
<code>pack_return</code> explicitly unwraps the <code>option</code> wrapper.</p>
<h3 id="Addendum"> Addendum</h3><p>
If you think labels and optional arguments are complicated, that&apos;s
because they are! Luckily, however, this is a relatively new feature in
OCaml, and it&apos;s not yet widely used. In fact if you&apos;re not hacking on
lablgtk, it&apos;s unlikely you&apos;ll see labels and optional arguments used at
all (at the moment).</p>
<h2 id="Morevariantsquotpolymorphicvariantsquot"> More variants (&quot;polymorphic variants&quot;)</h2><p>
Try compiling the following C code:</p>
<pre><code class='ocaml'><span class='o'>#</span><span class='k'>include</span> <span class='o'>&#60;</span>stdio<span class='o'>.</span>h<span class='o'>&#62;</span>
<span class='o'>#</span><span class='k'>include</span> <span class='o'>&#60;</span>fcntl<span class='o'>.</span>h<span class='o'>&#62;</span>
<span class='o'>#</span><span class='k'>include</span> <span class='o'>&#60;</span>unistd<span class='o'>.</span>h<span class='o'>&#62;</span>

enum lock <span class='o'>{</span> <span class='k'>open</span><span class='o'>,</span> close <span class='o'>}</span><span class='o'>;</span>

main ()
<span class='o'>{</span>
  int fd<span class='o'>,</span> n<span class='o'>;</span>
  char buffer<span class='o'>[</span>256<span class='o'>]</span><span class='o'>;</span>

  fd <span class='k'>=</span> <span class='k'>open</span> (<span class='s'>&#34;/etc/motd&#34;</span><span class='o'>,</span> O_RDONLY)<span class='o'>;</span>                     <span class='o'>//</span> line 12
  <span class='k'>while</span> ((n <span class='k'>=</span> read (fd<span class='o'>,</span> buffer<span class='o'>,</span> sizeof buffer)) <span class='o'>&#62;</span> 0)
    write (1<span class='o'>,</span> buffer<span class='o'>,</span> n)<span class='o'>;</span>
  close (fd)<span class='o'>;</span>                                            <span class='o'>//</span> line 15
<span class='o'>}</span>
</code></pre>
<p>
When I compile the code I get a whole bunch of errors including:</p>
<pre><code class='ocaml'>test<span class='o'>.</span>c<span class='o'>:</span> In <span class='k'>function</span> `main'<span class='o'>:</span>
test<span class='o'>.</span>c<span class='o'>:</span>12<span class='o'>:</span> error<span class='o'>:</span> called object is not a <span class='k'>function</span>
test<span class='o'>.</span>c<span class='o'>:</span>15<span class='o'>:</span> error<span class='o'>:</span> called object is not a <span class='k'>function</span>
</code></pre>
<p>
This illustrates one problem with enumerated types (enums) in C. In the
example above, one enum statement reserves <em>three</em> symbols, namely
<code>lock</code>, <code>open</code> and <code>close</code>. Here&apos;s another example:</p>
<pre><code class='ocaml'>enum lock <span class='o'>{</span> <span class='k'>open</span><span class='o'>,</span> close <span class='o'>}</span><span class='o'>;</span>
enum door <span class='o'>{</span> <span class='k'>open</span><span class='o'>,</span> close <span class='o'>}</span><span class='o'>;</span>
</code></pre>
<p>
Compiling gives:</p>
<pre><code class='ocaml'>test<span class='o'>.</span>c<span class='o'>:</span>2<span class='o'>:</span> error<span class='o'>:</span> conflicting types <span class='k'>for</span> `<span class='k'>open</span>'
test<span class='o'>.</span>c<span class='o'>:</span>1<span class='o'>:</span> error<span class='o'>:</span> previous declaration <span class='k'>of</span> `<span class='k'>open</span>'
test<span class='o'>.</span>c<span class='o'>:</span>2<span class='o'>:</span> error<span class='o'>:</span> conflicting types <span class='k'>for</span> `close'
test<span class='o'>.</span>c<span class='o'>:</span>1<span class='o'>:</span> error<span class='o'>:</span> previous declaration <span class='k'>of</span> `close'
</code></pre>
<p>
The first enum defines the symbol <code>open</code> as something of type
<code>enum lock</code>. You cannot reuse that symbol in another enum.</p>
<p>This will be familiar to most C/C++ programmers, and they won&apos;t write
naive code like that above. However the same issue happens with OCaml
variants, but OCaml provides a way to work around it.</p>
<p>Here is some OCaml code, which actually <em>does</em> compile:</p>
<pre><code class='ocaml'><span class='k'>type</span> lock <span class='k'>=</span> Open <span class='o'>|</span> Close
<span class='k'>type</span> door <span class='k'>=</span> Open <span class='o'>|</span> Close
</code></pre>
<p>
After running those two statements, what is the type of <code>Open</code>? We can
find out easily enough in the toplevel:</p>
<pre><code class='ocaml'><span class='k'>type</span> lock <span class='k'>=</span> Open <span class='o'>|</span> Close<span class='o'>;;</span>
<span class='k'>type</span> door <span class='k'>=</span> Open <span class='o'>|</span> Close<span class='o'>;;</span>
Open<span class='o'>;;</span>
</code></pre>
<p>
OCaml uses the most recent definition for <code>Open</code>, giving it the type
<code>door</code>. This is actually not such a serious problem because if you
accidentally tried to use <code>Open</code> in the type context of a <code>lock</code>, then
OCaml&apos;s wonderful type inference would immediately spot the error and
you wouldn&apos;t be able to compile the code.</p>
<p>So far, so much like C. Now I said that OCaml provides a way to work
around the constraint that <code>Open</code> can only have one type. In other
words, suppose I want to use <code>Open</code> to mean either &quot;the <code>Open</code> of type
<code>lock</code>&quot; or &quot;the <code>Open</code> of type <code>door</code>&quot; and I want OCaml to work out
which one I mean.</p>
<p>The syntax is slightly different, but here is how we do it:</p>
<pre><code class='ocaml'><span class='k'>type</span> lock <span class='k'>=</span> <span class='o'>[</span> `Open <span class='o'>|</span> `Close <span class='o'>]</span><span class='o'>;;</span>
<span class='k'>type</span> door <span class='k'>=</span> <span class='o'>[</span> `Open <span class='o'>|</span> `Close <span class='o'>]</span><span class='o'>;;</span>
</code></pre>
<p>
Notice the syntactic differences:</p>
<ol>
 <li>Each variant name is prefixed with <code>`</code> (a back tick).
 </li>
 <li>You have to put square brackets (<code>[]</code>) around the alternatives.</li>
</ol>

<p>The question naturally arises: What is the type of <code>`Ope</code>?</p>
<pre><code class='ocaml'>`Open<span class='o'>;;</span>
</code></pre>
<p>
<code> [&gt; `Open] </code> can be read as
<code> [ `Open | and some other possibilities which we don&apos;t know about ] </code>.
The &#92;&gt; (greater than) sign indicates that the set of possibilities is
bigger than those listed (open-ended).</p>
<p>There&apos;s nothing special about <code>`Ope</code>. <em>Any</em> back-ticked word can be
used as a type, even one which we haven&apos;t mentioned before:</p>
<pre><code class='ocaml'>`Foo<span class='o'>;;</span>
`Foo 42<span class='o'>;;</span>
</code></pre>
<p>
Let&apos;s write a function to print the state of a <code>lock</code>:</p>
<pre><code class='ocaml'>  <span class='k'>let</span> print_lock st <span class='k'>=</span>
    <span class='k'>match</span> st <span class='k'>with</span>
    <span class='o'>|</span> `Open <span class='k'>-></span> print_endline <span class='s'>&#34;The lock is open&#34;</span>
    <span class='o'>|</span> `Close <span class='k'>-></span> print_endline <span class='s'>&#34;The lock is closed&#34;</span>
</code></pre>
<p>
Take a careful look at the type of that function. Type inference has
worked out that the <code>st</code> argument has type <code> [&lt; `Close | `Open] </code>. The
&#92;&lt; (less than) sign means that this is a &#92;&lt;dfn&#92;&gt;closed class&#92;&lt;/dfn&#92;&gt;. In
other words, this function will only work on <code>`Clos</code> or <code>`Ope</code>
and not on anything else.</p>
<pre><code class='ocaml'>print_lock `Open<span class='o'>;;</span>
</code></pre>
<p>
Notice that <code>print_lock</code> works just as well with a <code>door</code> as with a
<code>lock</code>! We&apos;ve deliberately given up some type safety, and type inference
is now being used to help guess what we mean, rather than enforce
correct coding.</p>
<p>This is only an introduction to polymorphic variants. Because of the
reduction in type safety, it is recommended that you don&apos;t use these in
your code. You will, however, see them in advanced OCaml code quite a
lot precisely because advanced programmers will sometimes want to weaken
the type system to write advanced idioms.</p>
