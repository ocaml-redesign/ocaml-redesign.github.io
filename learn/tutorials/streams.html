<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title> &#8211; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" />
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet" />
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen" />
    <link href="/static/css/bootstrap_mod.css" rel="stylesheet" media="screen" />
    <link href="/static/css/opamdoc.css" rel="stylesheet" media="screen" />
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <script type="text/javascript">
      function octry(x){
        if(document.getElementById('buttons').innerHTML=='') {
          t = document.getElementById('tryocaml');
          js = document.createElement("script"); js.type = "text/javascript"; js.src = "/try-ocaml.js";
          t.appendChild(js);
        } else {
          t = document.getElementById('tryocaml');
          t.style.display = 'block';
          document.getElementById('console').value = x;
          document.getElementById('console').focus();
          document.getElementById('console').select();
        }
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml" /></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/pkg/">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
    <div class="container">
  <div class="row">
    

    <div id="content-primary" class="span8">
      <div id='tryocaml' class="content" style='display:none;'>
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style='display:none;'></div>
            <div id="menu-lessons" style='display:none'>
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td id=""></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id='main-contents' class="content">
        <h1 id="Streams"> Streams</h1><h2 id="Streamsx"> Streams</h2><p>

Suppose you need to process each line of a text file. One way to do this
is to read the file in as a single large string and use something like
<code>Str.split</code> to turn it into a list. This works when the file is small,
but because the entire file is loaded into memory, it does not scale
well when the file is large.</p>
<p>More commonly, the <code>input_line</code> function can be used to read one line at
a time from a channel. This typically looks like:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>in_channel</span> <span class='keywordsign'>=</span> <span class='lower'>open_in</span> <span class='string'>&#34;lines.txt&#34;</span> <span class='keyword'>in</span>
<span class='keyword'>try</span>
  <span class='keyword'>while</span> <span class='keyword'>true</span> <span class='keyword'>do</span>
    <span class='keyword'>let</span> <span class='lower'>line</span> <span class='keywordsign'>=</span> <span class='lower'>input_line</span> <span class='lower'>in_channel</span> <span class='keyword'>in</span>
    <span class='comment'>(* do something with line *)</span>
  <span class='keyword'>done</span>
<span class='keyword'>with</span> <span class='constructor module'>End_of_file</span> <span class='keywordsign'>-&#62;</span>
  <span class='lower'>close_in</span> <span class='lower'>in_channel</span>
</code></pre>
<p>
The above code is efficient with memory, but it can be inconvenient in
other ways. Since <code>input_line</code> only works with the <code>in_channel</code> type, it
cannot be reused in cases where the text is already in memory. The
<code>End_of_file</code> exception can be raised at any point during iteration, and
it is the programmer&#39;s responsibility to ensure that the file is closed
appropriately. In fact, if there is any other exception in the above
example, the file will not be closed at all. Altogether, there is a lot
going on: channels, I/O, exceptions, and files.</p>
<p>Streams offer an abstraction over one part of this process: reading
items from a sequence. They don&#39;t assume anything about files or
channels, and they replace the <code>End_of_file</code> exception with a more
structured approach to dealing with the end of input. Here is a function
that builds a stream of lines from an input channel:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>line_stream_of_channel</span> <span class='lower'>channel</span> <span class='keywordsign'>=</span>
  <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span>
    <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>_</span> <span class='keywordsign'>-&#62;</span>
       <span class='keyword'>try</span> <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='lower'>input_line</span> <span class='lower'>channel</span><span class='keywordsign'>)</span> <span class='keyword'>with</span> <span class='constructor module'>End_of_file</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span><span class='keywordsign'>)</span>
</code></pre>
<p>
The &quot;Stream.from&quot; function builds a stream from a callback function.
This function is passed the current stream count (starting with 0) as an
argument and is expected to return an <code>&#39;a option</code>. If the option has a
value (<code>Some x</code>), that value will be the next item in the stream. If it
has no value (<code>None</code>), this indicates that the stream is empty and no
further reads will be attempted. Since the option is polymorphic,
<code>Stream.from</code> can construct streams of any type. These streams have a
type of <code>&#39;a Stream.t</code>.</p>
<p>With this simple function, we can now easily construct line streams from
any input channel:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>in_channel</span> <span class='keywordsign'>=</span> <span class='lower'>open_in</span> <span class='string'>&#34;_oasis&#34;</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>lines</span> <span class='keywordsign'>=</span> <span class='lower'>line_stream_of_channel</span> <span class='lower'>in_channel</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
This variable <code>lines</code> is a stream of strings, one string per line. We
can now begin reading lines from it by passing it to <code>Stream.next</code>:</p>
<pre><code class='tryocaml'><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='keyword'>while</span> <span class='keyword'>true</span> <span class='keyword'>do</span> <span class='lower'>ignore</span><span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>)</span> <span class='keyword'>done</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
As you can see, <code>Stream.next</code> either returns the next item in the stream
or raises a <code>Stream.Failure</code> exception indicating that the stream is
empty. Likewise, with a little help from the <code>Stream.of_list</code>
constructor and the <code>Str</code> regular expression module, we could build a
stream of lines from a string in memory:</p>
<pre><code class='tryocaml'><span class='keywordsign'>#</span><span class='lower'>load</span> <span class='string'>&#34;str.cma&#34;</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>line_stream_of_string</span> <span class='lower'>string</span> <span class='keywordsign'>=</span>
  <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='keywordsign'>(</span><span class='constructor module'>Str</span><span class='keywordsign'>.</span><span class='lower'>split</span> <span class='keywordsign'>(</span><span class='constructor module'>Str</span><span class='keywordsign'>.</span><span class='lower'>regexp</span> <span class='string'>&#34;\n&#34;</span><span class='keywordsign'>)</span> <span class='lower'>string</span><span class='keywordsign'>)</span>
</code></pre>
<p>
and these streams could be used exactly the same way:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>lines</span> <span class='keywordsign'>=</span> <span class='lower'>line_stream_of_string</span> <span class='string'>&#34;hello\nstream\nworld&#34;</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
Since both cases raise <code>Stream.Failure</code> on an empty stream, there is no
need to worry about catching <code>End_of_file</code> in the case of file I/O. This
unified interface makes it much easier to write functions that can
receive data from multiple sources.</p>
<p>The <code>Stream.iter</code> function automates the common task of performing an
operation for each item. With it, we can rewrite the original example as
follows:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>in_channel</span> <span class='keywordsign'>=</span> <span class='lower'>open_in</span> <span class='string'>&#34;_oasis&#34;</span> <span class='keyword'>in</span>
  <span class='keyword'>try</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span>
      <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>line</span> <span class='keywordsign'>-&#62;</span>
         <span class='comment'>(* do something with line *)</span>
         <span class='lower'>print_endline</span> <span class='lower'>line</span><span class='keywordsign'>)</span>
      <span class='keywordsign'>(</span><span class='lower'>line_stream_of_channel</span> <span class='lower'>in_channel</span><span class='keywordsign'>)</span><span class='keywordsign'>;</span>
    <span class='lower'>close_in</span> <span class='lower'>in_channel</span>
  <span class='keyword'>with</span> <span class='lower'>e</span> <span class='keywordsign'>-&#62;</span>
    <span class='lower'>close_in</span> <span class='lower'>in_channel</span><span class='keywordsign'>;</span>
    <span class='lower'>raise</span> <span class='lower'>e</span>
</code></pre>
<p>
Note how much easier it is to handle I/O exceptions properly, since we
can deal with them independently from the end-of-file condition. This
separation of concerns allows us to decompose this into simpler and more
reusable functions:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>process_line</span> <span class='lower'>line</span> <span class='keywordsign'>=</span>
  <span class='lower'>print_endline</span> <span class='lower'>line</span>

<span class='keyword'>let</span> <span class='lower'>process_lines</span> <span class='lower'>lines</span> <span class='keywordsign'>=</span>
  <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span> <span class='lower'>process_line</span> <span class='lower'>lines</span>

<span class='keyword'>let</span> <span class='lower'>process_file</span> <span class='lower'>filename</span> <span class='keywordsign'>=</span>
  <span class='keyword'>let</span> <span class='lower'>in_channel</span> <span class='keywordsign'>=</span> <span class='lower'>open_in</span> <span class='lower'>filename</span> <span class='keyword'>in</span>
  <span class='keyword'>try</span>
    <span class='lower'>process_lines</span> <span class='keywordsign'>(</span><span class='lower'>line_stream_of_channel</span> <span class='lower'>in_channel</span><span class='keywordsign'>)</span><span class='keywordsign'>;</span>
    <span class='lower'>close_in</span> <span class='lower'>in_channel</span>
  <span class='keyword'>with</span> <span class='lower'>e</span> <span class='keywordsign'>-&#62;</span>
    <span class='lower'>close_in</span> <span class='lower'>in_channel</span>
    <span class='lower'>raise</span> <span class='lower'>e</span>

<span class='keyword'>let</span> <span class='lower'>process_string</span> <span class='lower'>string</span> <span class='keywordsign'>=</span>
  <span class='lower'>process_lines</span> <span class='keywordsign'>(</span><span class='lower'>line_stream_of_string</span> <span class='lower'>string</span><span class='keywordsign'>)</span>
</code></pre>
<h2 id="Constructingstreams"> Constructing streams</h2><p>

In the above examples, we saw two methods for constructing streams:</p>
<ul>
 <li>Stream.from, which builds a stream from a callback function
 </li>
 <li>Stream.of_list, which builds a stream from a list in memory</li>
</ul>

<p>The <code>Stream</code> module provides a few other stream builders:</p>
<ul>
 <li>Stream.of_string, which builds a character stream from a string
 </li>
 <li>Stream.of_channel, which builds a character stream from a channel</li>
</ul>

<p><code>Stream.from</code> is the most general, and it can be used to produce streams
of any type. It is not limited to I/O and can even produce infinite
sequences. Here are a few simple stream builders defined with
<code>Stream.from</code>:</p>
<pre><code class='tryocaml'>  <span class='comment'>(* A stream that is always empty. *)</span>
  <span class='keyword'>let</span> <span class='lower'>empty_stream</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>_</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
  <span class='comment'>(* A stream that yields the same item repeatedly. *)</span>
  <span class='keyword'>let</span> <span class='lower'>const_stream</span> <span class='lower'>k</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>_</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>Some</span> <span class='lower'>k</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
  <span class='comment'>(* A stream that yields consecutive integers starting with &#39;i&#39;. *)</span>
  <span class='keyword'>let</span> <span class='lower'>count_stream</span> <span class='lower'>i</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>j</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='lower'>i</span> <span class='keywordsign'>+</span> <span class='lower'>j</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
</code></pre>
<h2 id="Deconstructingstreams"> Deconstructing streams</h2><p>

We already saw the <code>Stream.next</code> function, which retrieves a single item
from a stream. There is another way to work with streams that is often
preferable: <code>Stream.peek</code> and <code>Stream.junk</code>. When used together, these
functions allow you to see what the next item would be. This feature,
known as &quot;look ahead&quot;, is very useful when writing parsers. Even if you
don&#39;t need to look ahead, the peek/junk protocol may be nicer to work
with because it uses options instead of exceptions:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>lines</span> <span class='keywordsign'>=</span> <span class='lower'>line_stream_of_string</span> <span class='string'>&#34;hello\nworld&#34;</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>peek</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>peek</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>junk</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>peek</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>junk</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>peek</span> <span class='lower'>lines</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
As you can see, it is necessary to call <code>Stream.junk</code> to advance to the
next item. <code>Stream.peek</code> will always give you either the next item or
<code>None</code>, and it will never fail. Likewise, <code>Stream.junk</code> always succeeds
(even if the stream is empty).</p>
<h2 id="AmorecomplexquotStreamfromquotexample"> A more complex &quot;Stream.from&quot; example</h2><p>
Here is a function that converts a line stream into a paragraph stream.
As such, it is both a stream consumer and a stream producer.</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>paragraphs</span> <span class='lower'>lines</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>para_lines</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>match</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>peek</span> <span class='lower'>lines</span><span class='keywordsign'>,</span> <span class='lower'>para_lines</span> <span class='keyword'>with</span>
      <span class='keywordsign'>|</span> <span class='constructor module'>None</span><span class='keywordsign'>,</span> <span class='keywordsign operator'>[]</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span>
      <span class='keywordsign'>|</span> <span class='constructor module'>Some</span> <span class='string'>&#34;&#34;</span><span class='keywordsign'>,</span> <span class='keywordsign operator'>[]</span> <span class='keywordsign'>-&#62;</span>
          <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>junk</span> <span class='lower'>lines</span><span class='keywordsign'>;</span>
          <span class='lower'>next</span> <span class='lower'>para_lines</span> <span class='lower'>i</span>
      <span class='keywordsign'>|</span> <span class='constructor module'>Some</span> <span class='string'>&#34;&#34;</span><span class='keywordsign'>,</span> <span class='keywordsign'>_</span> <span class='keywordsign'>|</span> <span class='constructor module'>None</span><span class='keywordsign'>,</span> <span class='keywordsign'>_</span> <span class='keywordsign'>-&#62;</span>
          <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='constructor module'>String</span><span class='keywordsign'>.</span><span class='lower'>concat</span> <span class='string'>&#34;\n&#34;</span> <span class='keywordsign'>(</span><span class='constructor module'>List</span><span class='keywordsign'>.</span><span class='lower'>rev</span> <span class='lower'>para_lines</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
      <span class='keywordsign'>|</span> <span class='constructor module'>Some</span> <span class='lower'>line</span><span class='keywordsign'>,</span> <span class='keywordsign'>_</span> <span class='keywordsign'>-&#62;</span>
          <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>junk</span> <span class='lower'>lines</span><span class='keywordsign'>;</span>
          <span class='lower'>next</span> <span class='keywordsign'>(</span><span class='lower'>line</span> <span class='keywordsign'>::</span> <span class='lower'>para_lines</span><span class='keywordsign'>)</span> <span class='lower'>i</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='keywordsign'>(</span><span class='lower'>next</span> <span class='keywordsign operator'>[]</span><span class='keywordsign'>)</span>
</code></pre>
<p>
This function uses an extra parameter to <code>next</code> (the <code>Stream.from</code>
callback) called <code>para_lines</code> in order to collect the lines for each
paragraph. Paragraphs are delimited by any number of blank lines.</p>
<p>Each time <code>next</code> is called, a <code>match</code> expression tests two values: the
next line in the stream, and the contents of <code>para_lines</code>. Four cases
are handled:</p>
<ol>
 <li>If the end of the stream is reached and no lines have been
 collected, the paragraph stream ends as well.
 </li>
 <li>If the next line is blank and no lines have been collected, the
 blank is ignored and <code>next</code> is called recursively to keep looking
 for a non-blank line.
 </li>
 <li>If a blank line or end of stream is reached and lines <strong>have</strong> been
 collected, the paragraph is returned by concatenating <code>para_lines</code>
 to a single string.
 </li>
 <li>Finally, if a non-blank line has been reached, the line is collected
 by recursively calling <code>para_lines</code>.</li>
</ol>

<p>Happily, we can rely on the OCaml compiler&#39;s exhaustiveness checking to
ensure that we are handling all possible cases.</p>
<p>With this new tool, we can now work just as easily with paragraphs as we
could before with lines:</p>
<pre><code class='tryocaml'>  <span class='comment'>(* Print each paragraph, followed by a separator. *)</span>
  <span class='keyword'>let</span> <span class='lower'>lines</span> <span class='keywordsign'>=</span> <span class='lower'>line_stream_of_channel</span> <span class='lower'>in_channel</span> <span class='keyword'>in</span>
  <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span>
    <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>para</span> <span class='keywordsign'>-&#62;</span>
       <span class='lower'>print_endline</span> <span class='lower'>para</span><span class='keywordsign'>;</span>
       <span class='lower'>print_endline</span> <span class='string'>&#34;--&#34;</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>(</span><span class='lower'>paragraphs</span> <span class='lower'>lines</span><span class='keywordsign'>)</span>
</code></pre>
<p>
Functions like <code>paragraphs</code> that produce and consume streams can be
composed together in a manner very similar to UNIX pipes and filters.</p>
<h2 id="Streamcombinators"> Stream combinators</h2><p>
Just like lists and arrays, common iteration patterns such as <code>map</code>,
<code>filter</code>, and <code>fold</code> can be very useful. The <code>Stream</code> module does not
provide such functions, but they can be built easily using
<code>Stream.from</code>:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>stream_map</span> <span class='lower'>f</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>try</span> <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='lower'>f</span> <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
      <span class='keyword'>with</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='constructor module'>Failure</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>next</span>

  <span class='keyword'>let</span> <span class='lower'>stream_filter</span> <span class='lower'>p</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>try</span>
        <span class='keyword'>let</span> <span class='lower'>value</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream</span> <span class='keyword'>in</span>
        <span class='keyword'>if</span> <span class='lower'>p</span> <span class='lower'>value</span> <span class='keyword'>then</span> <span class='constructor module'>Some</span> <span class='lower'>value</span> <span class='keyword'>else</span> <span class='lower'>next</span> <span class='lower'>i</span>
      <span class='keyword'>with</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='constructor module'>Failure</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>next</span>
  
  <span class='keyword'>let</span> <span class='lower'>stream_fold</span> <span class='lower'>f</span> <span class='lower'>stream</span> <span class='lower'>init</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>result</span> <span class='keywordsign'>=</span> <span class='lower'>ref</span> <span class='lower'>init</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span>
      <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>x</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>result</span> <span class='keywordsign'>:=</span> <span class='lower'>f</span> <span class='lower'>x</span> <span class='keywordsign prefix'>!</span><span class='lower'>result</span><span class='keywordsign'>)</span>
      <span class='lower'>stream</span><span class='keywordsign'>;</span>
    <span class='keywordsign prefix'>!</span><span class='lower'>result</span>
</code></pre>
<p>
For example, here is a stream of leap years starting with 2000:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>is_leap</span> <span class='lower'>year</span> <span class='keywordsign'>=</span>
    <span class='lower'>year</span> <span class='keyword'>mod</span> <span class='number'>4</span> <span class='keywordsign'>=</span> <span class='number'>0</span> <span class='keywordsign'>&#38;&#38;</span> <span class='keywordsign'>(</span><span class='lower'>year</span> <span class='keyword'>mod</span> <span class='number'>100</span> <span class='keywordsign infix'>&#60;&#62;</span> <span class='number'>0</span> <span class='keywordsign infix'>||</span> <span class='lower'>year</span> <span class='keyword'>mod</span> <span class='number'>400</span> <span class='keywordsign'>=</span> <span class='number'>0</span><span class='keywordsign'>)</span>
  <span class='keyword'>let</span> <span class='lower'>leap_years</span> <span class='keywordsign'>=</span> <span class='lower'>stream_filter</span> <span class='lower'>is_leap</span> <span class='keywordsign'>(</span><span class='lower'>count_stream</span> <span class='number'>2000</span><span class='keywordsign'>)</span>
</code></pre>
<p>
We can use the <code>Stream.npeek</code> function to look ahead by more than one
item. In this case, we&#39;ll peek at the next 30 items to make sure that
the year 2100 is not a leap year (since it&#39;s divisible by 100 but not
400!):</p>
<pre><code class='tryocaml'><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>npeek</span> <span class='number'>30</span> <span class='lower'>leap_years</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
Note that we must be careful not to use <code>Stream.iter</code> on an infinite
stream like <code>leap_years</code>. This applies to <code>stream_fold</code>, as well as any
function that attempts to consume the entire stream.</p>
<pre><code class='tryocaml'><span class='lower'>stream_fold</span> <span class='keywordsign'>(</span><span class='keywordsign'>+</span><span class='keywordsign'>)</span> <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='keywordsign'>[</span><span class='number'>1</span><span class='keywordsign'>;</span> <span class='number'>2</span><span class='keywordsign'>;</span> <span class='number'>3</span><span class='keywordsign'>]</span><span class='keywordsign'>)</span> <span class='number'>0</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
<code>stream_fold (+) (count_stream 0) 0</code> runs forever.</p>
<h2 id="Otherusefulstreambuilders"> Other useful stream builders</h2><p>
The previously defined <code>const_stream</code> function builds a stream that
repeats a single value. It is also useful to build a stream that repeats
a sequence of values. The following function does just that:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>cycle</span> <span class='lower'>items</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>buf</span> <span class='keywordsign'>=</span> <span class='lower'>ref</span> <span class='keywordsign operator'>[]</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>if</span> <span class='keywordsign prefix'>!</span><span class='lower'>buf</span> <span class='keywordsign'>=</span> <span class='keywordsign operator'>[]</span> <span class='keyword'>then</span> <span class='lower'>buf</span> <span class='keywordsign'>:=</span> <span class='lower'>items</span><span class='keywordsign'>;</span>
      <span class='keyword'>match</span> <span class='keywordsign prefix'>!</span><span class='lower'>buf</span> <span class='keyword'>with</span>
        <span class='keywordsign'>|</span> <span class='lower'>h</span> <span class='keywordsign'>::</span> <span class='lower'>t</span> <span class='keywordsign'>-&#62;</span> <span class='keywordsign'>(</span><span class='lower'>buf</span> <span class='keywordsign'>:=</span> <span class='lower'>t</span><span class='keywordsign'>;</span> <span class='constructor module'>Some</span> <span class='lower'>h</span><span class='keywordsign'>)</span>
        <span class='keywordsign'>|</span> <span class='keywordsign operator'>[]</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>next</span>
</code></pre>
<p>
One common task that can benefit from this kind of stream is the
generation of alternating background colors for HTML. By using <code>cycle</code>
with <code>stream_combine</code>, explained in the next section, an infinite stream
of background colors can be combined with a finite stream of data to
produce a sequence of HTML blocks:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>stream_combine</span> <span class='lower'>stream1</span> <span class='lower'>stream2</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>try</span> <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream1</span><span class='keywordsign'>,</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream2</span><span class='keywordsign'>)</span>
      <span class='keyword'>with</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='constructor module'>Failure</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>next</span><span class='keywordsign'>;;</span>
  <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span> <span class='lower'>print_endline</span>
    <span class='keywordsign'>(</span><span class='lower'>stream_map</span>
       <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>(</span><span class='lower'>bg</span><span class='keywordsign'>,</span> <span class='lower'>s</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span>
          <span class='constructor module'>Printf</span><span class='keywordsign'>.</span><span class='lower'>sprintf</span> <span class='string'>&#34;&#60;div style=&#39;background: %s&#39;&#62;%s&#60;/div&#62;&#34;</span> <span class='lower'>bg</span> <span class='lower'>s</span><span class='keywordsign'>)</span>
       <span class='keywordsign'>(</span><span class='lower'>stream_combine</span>
          <span class='keywordsign'>(</span><span class='lower'>cycle</span> <span class='keywordsign'>[</span><span class='string'>&#34;#eee&#34;</span><span class='keywordsign'>;</span> <span class='string'>&#34;#fff&#34;</span><span class='keywordsign'>]</span><span class='keywordsign'>)</span>
          <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='keywordsign'>[</span><span class='string'>&#34;hello&#34;</span><span class='keywordsign'>;</span> <span class='string'>&#34;html&#34;</span><span class='keywordsign'>;</span> <span class='string'>&#34;world&#34;</span><span class='keywordsign'>]</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
</code></pre>
<p>
Here is a simple <code>range</code> function that produces a sequence of integers:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>range</span> <span class='keywordsign'>?</span><span class='keywordsign'>(</span><span class='lower'>start</span><span class='keywordsign'>=</span><span class='number'>0</span><span class='keywordsign'>)</span> <span class='keywordsign'>?</span><span class='keywordsign'>(</span><span class='lower'>stop</span><span class='keywordsign'>=</span><span class='number'>0</span><span class='keywordsign'>)</span> <span class='keywordsign'>?</span><span class='keywordsign'>(</span><span class='lower'>step</span><span class='keywordsign'>=</span><span class='number'>1</span><span class='keywordsign'>)</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>in_range</span> <span class='keywordsign'>=</span> <span class='keyword'>if</span> <span class='lower'>step</span> <span class='keywordsign'>&#60;</span> <span class='number'>0</span> <span class='keyword'>then</span> <span class='keywordsign'>(</span><span class='keywordsign'>&#62;</span><span class='keywordsign'>)</span> <span class='keyword'>else</span> <span class='keywordsign'>(</span><span class='keywordsign'>&#60;</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='lower'>current</span> <span class='keywordsign'>=</span> <span class='lower'>ref</span> <span class='lower'>start</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>if</span> <span class='lower'>in_range</span> <span class='keywordsign prefix'>!</span><span class='lower'>current</span> <span class='lower'>stop</span>
      <span class='keyword'>then</span> <span class='keyword'>let</span> <span class='lower'>result</span> <span class='keywordsign'>=</span> <span class='keywordsign prefix'>!</span><span class='lower'>current</span> <span class='keyword'>in</span> <span class='keywordsign'>(</span><span class='lower'>current</span> <span class='keywordsign'>:=</span> <span class='keywordsign prefix'>!</span><span class='lower'>current</span> <span class='keywordsign'>+</span> <span class='lower'>step</span><span class='keywordsign'>;</span>
                                     <span class='constructor module'>Some</span> <span class='lower'>result</span><span class='keywordsign'>)</span>
      <span class='keyword'>else</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>next</span>
</code></pre>
<p>
This works just like Python&#39;s <code>xrange</code> built-in function, providing an
easy way to produce an assortment of lazy integer sequences by
specifying combinations of <code>start</code>, <code>stop</code>, or <code>step</code> values:</p>
<pre><code class='tryocaml'><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>npeek</span> <span class='number'>10</span> <span class='keywordsign'>(</span><span class='lower'>range</span> <span class='keywordsign'>~</span><span class='lower'>start</span><span class='keywordsign'>:</span><span class='number'>5</span> <span class='keywordsign'>~</span><span class='lower'>stop</span><span class='keywordsign'>:</span><span class='number'>10</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>npeek</span> <span class='number'>10</span> <span class='keywordsign'>(</span><span class='lower'>range</span> <span class='keywordsign'>~</span><span class='lower'>stop</span><span class='keywordsign'>:</span><span class='number'>10</span> <span class='keywordsign'>~</span><span class='lower'>step</span><span class='keywordsign'>:</span><span class='number'>2</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>npeek</span> <span class='number'>10</span> <span class='keywordsign'>(</span><span class='lower'>range</span> <span class='keywordsign'>~</span><span class='lower'>start</span><span class='keywordsign'>:</span><span class='number'>10</span> <span class='keywordsign'>~</span><span class='lower'>step</span><span class='keywordsign'>:</span><span class='keywordsign'>(</span><span class='keywordsign'>-</span><span class='number'>1</span><span class='keywordsign'>)</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>npeek</span> <span class='number'>10</span> <span class='keywordsign'>(</span><span class='lower'>range</span> <span class='keywordsign'>~</span><span class='lower'>start</span><span class='keywordsign'>:</span><span class='number'>10</span> <span class='keywordsign'>~</span><span class='lower'>stop</span><span class='keywordsign'>:</span><span class='number'>5</span> <span class='keywordsign'>~</span><span class='lower'>step</span><span class='keywordsign'>:</span><span class='keywordsign'>(</span><span class='keywordsign'>-</span><span class='number'>1</span><span class='keywordsign'>)</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>
</code></pre>
<h2 id="Combiningstreams"> Combining streams</h2><p>

There are several ways to combine streams. One is to produce a stream of
streams and then concatenate them into a single stream. The following
function works just like <code>List.concat</code>, but instead of turning a list of
lists into a list, it turns a stream of streams into a stream:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>stream_concat</span> <span class='lower'>streams</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>current_stream</span> <span class='keywordsign'>=</span> <span class='lower'>ref</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>try</span>
        <span class='keyword'>let</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span>
          <span class='keyword'>match</span> <span class='keywordsign prefix'>!</span><span class='lower'>current_stream</span> <span class='keyword'>with</span>
          <span class='keywordsign'>|</span> <span class='constructor module'>Some</span> <span class='lower'>stream</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>stream</span>
          <span class='keywordsign'>|</span> <span class='constructor module'>None</span> <span class='keywordsign'>-&#62;</span>
             <span class='keyword'>let</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>streams</span> <span class='keyword'>in</span>
             <span class='lower'>current_stream</span> <span class='keywordsign'>:=</span> <span class='constructor module'>Some</span> <span class='lower'>stream</span><span class='keywordsign'>;</span>
             <span class='lower'>stream</span> <span class='keyword'>in</span>
        <span class='keyword'>try</span> <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream</span><span class='keywordsign'>)</span>
        <span class='keyword'>with</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='constructor module'>Failure</span> <span class='keywordsign'>-&#62;</span> <span class='keywordsign'>(</span><span class='lower'>current_stream</span> <span class='keywordsign'>:=</span> <span class='constructor module'>None</span><span class='keywordsign'>;</span> <span class='lower'>next</span> <span class='lower'>i</span><span class='keywordsign'>)</span>
      <span class='keyword'>with</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='constructor module'>Failure</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>next</span>
</code></pre>
<p>
Here is a sequence of ranges which are themselves derived from a range,
concatenated with <code>stream_concat</code> to produce a flattened <code>int Stream.t</code>.</p>
<pre><code class='tryocaml'>  <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>npeek</span> <span class='number'>10</span>
    <span class='keywordsign'>(</span><span class='lower'>stream_concat</span>
       <span class='keywordsign'>(</span><span class='lower'>stream_map</span>
          <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>i</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>range</span> <span class='keywordsign'>~</span><span class='lower'>stop</span><span class='keywordsign'>:</span><span class='lower'>i</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
          <span class='keywordsign'>(</span><span class='lower'>range</span> <span class='keywordsign'>~</span><span class='lower'>stop</span><span class='keywordsign'>:</span><span class='number'>5</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
</code></pre>
<p>
Another way to combine streams is to iterate through them in a pairwise
fashion:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>stream_combine</span> <span class='lower'>stream1</span> <span class='lower'>stream2</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='keyword'>rec</span> <span class='lower'>next</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>try</span> <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream1</span><span class='keywordsign'>,</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream2</span><span class='keywordsign'>)</span>
      <span class='keyword'>with</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='constructor module'>Failure</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>next</span>
</code></pre>
<p>
This is useful, for instance, if you have a stream of keys and a stream
of corresponding values. Iterating through key value pairs is then as
simple as:</p>
<pre><code class='tryocaml'><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span>
  <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>(</span><span class='lower'>key</span><span class='keywordsign'>,</span> <span class='lower'>value</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span>
     <span class='comment'>(* do something with &#39;key&#39; and &#39;value&#39; *)</span>
     <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
  <span class='keywordsign'>(</span><span class='lower'>stream_combine</span> <span class='lower'>key_stream</span> <span class='lower'>value_stream</span><span class='keywordsign'>)</span>
</code></pre>
<p>
Since <code>stream_combine</code> stops as soon as either of its input streams runs
out, it can be used to combine an infinite stream with a finite one.
This provides a neat way to add indexes to a sequence:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>items</span> <span class='keywordsign'>=</span> <span class='keywordsign'>[</span><span class='string'>&#34;this&#34;</span><span class='keywordsign'>;</span> <span class='string'>&#34;is&#34;</span><span class='keywordsign'>;</span> <span class='string'>&#34;a&#34;</span><span class='keywordsign'>;</span> <span class='string'>&#34;test&#34;</span><span class='keywordsign'>]</span><span class='keywordsign'>;;</span>
  <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span>
    <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>(</span><span class='lower'>index</span><span class='keywordsign'>,</span> <span class='lower'>value</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span>
       <span class='constructor module'>Printf</span><span class='keywordsign'>.</span><span class='lower'>printf</span> <span class='string'>&#34;%d. %s\n%!&#34;</span> <span class='lower'>index</span> <span class='lower'>value</span><span class='keywordsign'>)</span>
    <span class='keywordsign'>(</span><span class='lower'>stream_combine</span> <span class='keywordsign'>(</span><span class='lower'>count_stream</span> <span class='number'>1</span><span class='keywordsign'>)</span> <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='lower'>items</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
</code></pre>
<h2 id="Copyingstreams"> Copying streams</h2><p>

Streams are destructive; once you discard an item in a stream, it is no
longer available unless you save a copy somewhere. What if you want to
use the same stream more than once? One way is to create a &quot;tee&quot;. The
following function creates two output streams from one input stream,
intelligently queueing unseen values until they have been produced by
both streams:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>stream_tee</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>next</span> <span class='lower'>self</span> <span class='lower'>other</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='keyword'>try</span>
        <span class='keyword'>if</span> <span class='constructor module'>Queue</span><span class='keywordsign'>.</span><span class='lower'>is_empty</span> <span class='lower'>self</span>
        <span class='keyword'>then</span>
          <span class='keyword'>let</span> <span class='lower'>value</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>stream</span> <span class='keyword'>in</span>
          <span class='constructor module'>Queue</span><span class='keywordsign'>.</span><span class='lower'>add</span> <span class='lower'>value</span> <span class='lower'>other</span><span class='keywordsign'>;</span>
          <span class='constructor module'>Some</span> <span class='lower'>value</span>
        <span class='keyword'>else</span>
          <span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='constructor module'>Queue</span><span class='keywordsign'>.</span><span class='lower'>take</span> <span class='lower'>self</span><span class='keywordsign'>)</span>
      <span class='keyword'>with</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='constructor module'>Failure</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>None</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='lower'>q1</span> <span class='keywordsign'>=</span> <span class='constructor module'>Queue</span><span class='keywordsign'>.</span><span class='lower'>create</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='lower'>q2</span> <span class='keywordsign'>=</span> <span class='constructor module'>Queue</span><span class='keywordsign'>.</span><span class='lower'>create</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='keywordsign'>(</span><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='keywordsign'>(</span><span class='lower'>next</span> <span class='lower'>q1</span> <span class='lower'>q2</span><span class='keywordsign'>)</span><span class='keywordsign'>,</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='keywordsign'>(</span><span class='lower'>next</span> <span class='lower'>q2</span> <span class='lower'>q1</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span>
</code></pre>
<p>
Here is an example of a stream tee in action:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>letters</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='keywordsign'>[</span><span class='string'>&#39;a&#39;</span><span class='keywordsign'>;</span> <span class='string'>&#39;b&#39;</span><span class='keywordsign'>;</span> <span class='string'>&#39;c&#39;</span><span class='keywordsign'>;</span> <span class='string'>&#39;d&#39;</span><span class='keywordsign'>;</span> <span class='string'>&#39;e&#39;</span><span class='keywordsign'>]</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>s1</span><span class='keywordsign'>,</span> <span class='lower'>s2</span> <span class='keywordsign'>=</span> <span class='lower'>stream_tee</span> <span class='lower'>letters</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s1</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s1</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s2</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s1</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s2</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s2</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
Again, since streams are destructive, you probably want to leave the
original stream alone or you will lose items from the copied streams:</p>
<pre><code class='tryocaml'><span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>letters</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s1</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>next</span> <span class='lower'>s2</span><span class='keywordsign'>;;</span>
</code></pre>
<h2 id="Convertingstreams"> Converting streams</h2><p>

Here are a few functions for converting between streams and lists,
arrays, and hash tables. These probably belong in the standard library,
but they are simple to define anyhow. Again, beware of infinite streams,
which will cause these functions to hang.</p>
<pre><code class='tryocaml'>  <span class='comment'>(* This one is free. *)</span>
  <span class='keyword'>let</span> <span class='lower'>stream_of_list</span> <span class='keywordsign'>=</span> <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span>

  <span class='keyword'>let</span> <span class='lower'>list_of_stream</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>result</span> <span class='keywordsign'>=</span> <span class='lower'>ref</span> <span class='keywordsign operator'>[]</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>value</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>result</span> <span class='keywordsign'>:=</span> <span class='lower'>value</span> <span class='keywordsign'>::</span> <span class='keywordsign prefix'>!</span><span class='lower'>result</span><span class='keywordsign'>)</span> <span class='lower'>stream</span><span class='keywordsign'>;</span>
    <span class='constructor module'>List</span><span class='keywordsign'>.</span><span class='lower'>rev</span> <span class='keywordsign prefix'>!</span><span class='lower'>result</span>
  
  <span class='keyword'>let</span> <span class='lower'>stream_of_array</span> <span class='lower'>array</span> <span class='keywordsign'>=</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='keywordsign'>(</span><span class='constructor module'>Array</span><span class='keywordsign'>.</span><span class='lower'>to_list</span> <span class='lower'>array</span><span class='keywordsign'>)</span>
  
  <span class='keyword'>let</span> <span class='lower'>array_of_stream</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span>
    <span class='constructor module'>Array</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='keywordsign'>(</span><span class='lower'>list_of_stream</span> <span class='lower'>stream</span><span class='keywordsign'>)</span>
  
  <span class='keyword'>let</span> <span class='lower'>stream_of_hash</span> <span class='lower'>hash</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>result</span> <span class='keywordsign'>=</span> <span class='lower'>ref</span> <span class='keywordsign operator'>[]</span> <span class='keyword'>in</span>
    <span class='constructor module'>Hashtbl</span><span class='keywordsign'>.</span><span class='lower'>iter</span>
      <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>key</span> <span class='lower'>value</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>result</span> <span class='keywordsign'>:=</span> <span class='keywordsign'>(</span><span class='lower'>key</span><span class='keywordsign'>,</span> <span class='lower'>value</span><span class='keywordsign'>)</span> <span class='keywordsign'>::</span> <span class='keywordsign prefix'>!</span><span class='lower'>result</span><span class='keywordsign'>)</span>
      <span class='lower'>hash</span><span class='keywordsign'>;</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>of_list</span> <span class='keywordsign prefix'>!</span><span class='lower'>result</span>
  
  <span class='keyword'>let</span> <span class='lower'>hash_of_stream</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>result</span> <span class='keywordsign'>=</span> <span class='constructor module'>Hashtbl</span><span class='keywordsign'>.</span><span class='lower'>create</span> <span class='number'>0</span> <span class='keyword'>in</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span>
      <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>(</span><span class='lower'>key</span><span class='keywordsign'>,</span> <span class='lower'>value</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>Hashtbl</span><span class='keywordsign'>.</span><span class='lower'>replace</span> <span class='lower'>result</span> <span class='lower'>key</span> <span class='lower'>value</span><span class='keywordsign'>)</span>
      <span class='lower'>stream</span><span class='keywordsign'>;</span>
    <span class='lower'>result</span>
</code></pre>
<p>
What if you want to convert arbitary data types to streams? Well, if the
data type defines an <code>iter</code> function, and you don&#39;t mind using threads,
you can use a producer-consumer arrangement to invert control:</p>
<pre><code class='tryocaml'>  <span class='keywordsign'>#</span><span class='lower'>directory</span> <span class='string'>&#34;+threads&#34;</span><span class='keywordsign'>;;</span>
  <span class='keywordsign'>#</span><span class='lower'>load</span> <span class='string'>&#34;threads.cma&#34;</span><span class='keywordsign'>;;</span>
  <span class='keyword'>let</span> <span class='lower'>elements</span> <span class='lower'>iter</span> <span class='lower'>coll</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>channel</span> <span class='keywordsign'>=</span> <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>new_channel</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='lower'>producer</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keywordsign'>=</span>
      <span class='keyword'>let</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keywordsign'>=</span>
        <span class='lower'>iter</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>x</span> <span class='keywordsign'>-&#62;</span> <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>sync</span> <span class='keywordsign'>(</span><span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>send</span> <span class='lower'>channel</span> <span class='keywordsign'>(</span><span class='constructor module'>Some</span> <span class='lower'>x</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span> <span class='lower'>coll</span> <span class='keyword'>in</span>
      <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>sync</span> <span class='keywordsign'>(</span><span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>send</span> <span class='lower'>channel</span> <span class='constructor module'>None</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='lower'>consumer</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>sync</span> <span class='keywordsign'>(</span><span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>receive</span> <span class='lower'>channel</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='lower'>ignore</span> <span class='keywordsign'>(</span><span class='constructor module'>Thread</span><span class='keywordsign'>.</span><span class='lower'>create</span> <span class='lower'>producer</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>consumer</span>
</code></pre>
<p>
Now it is possible to build a stream from an <code>iter</code> function and a
corresponding value:</p>
<pre><code class='tryocaml'><span class='keyword'>module</span> <span class='constructor module'>StringSet</span> <span class='keywordsign'>=</span> <span class='constructor module'>Set</span><span class='keywordsign'>.</span><span class='constructor module'>Make</span><span class='keywordsign'>(</span><span class='constructor module'>String</span><span class='keywordsign'>)</span><span class='keywordsign'>;;</span>

<span class='keyword'>let</span> <span class='lower'>set</span> <span class='keywordsign'>=</span> <span class='constructor module'>StringSet</span><span class='keywordsign'>.</span><span class='lower'>empty</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>set</span> <span class='keywordsign'>=</span> <span class='constructor module'>StringSet</span><span class='keywordsign'>.</span><span class='lower'>add</span> <span class='string'>&#34;here&#34;</span> <span class='lower'>set</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>set</span> <span class='keywordsign'>=</span> <span class='constructor module'>StringSet</span><span class='keywordsign'>.</span><span class='lower'>add</span> <span class='string'>&#34;are&#34;</span> <span class='lower'>set</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>set</span> <span class='keywordsign'>=</span> <span class='constructor module'>StringSet</span><span class='keywordsign'>.</span><span class='lower'>add</span> <span class='string'>&#34;some&#34;</span> <span class='lower'>set</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>set</span> <span class='keywordsign'>=</span> <span class='constructor module'>StringSet</span><span class='keywordsign'>.</span><span class='lower'>add</span> <span class='string'>&#34;values&#34;</span> <span class='lower'>set</span><span class='keywordsign'>;;</span>
<span class='keyword'>let</span> <span class='lower'>stream</span> <span class='keywordsign'>=</span> <span class='lower'>elements</span> <span class='constructor module'>StringSet</span><span class='keywordsign'>.</span><span class='lower'>iter</span> <span class='lower'>set</span><span class='keywordsign'>;;</span>
<span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>iter</span> <span class='lower'>print_endline</span> <span class='lower'>stream</span><span class='keywordsign'>;;</span>
</code></pre>
<p>
Some data types, like Hashtbl and Map, provide an <code>iter</code> function that
iterates through key-value pairs. Here&#39;s a function for those, too:</p>
<pre><code class='tryocaml'>  <span class='keyword'>let</span> <span class='lower'>items</span> <span class='lower'>iter</span> <span class='lower'>coll</span> <span class='keywordsign'>=</span>
    <span class='keyword'>let</span> <span class='lower'>channel</span> <span class='keywordsign'>=</span> <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>new_channel</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='lower'>producer</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keywordsign'>=</span>
      <span class='keyword'>let</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span> <span class='keywordsign'>=</span>
        <span class='lower'>iter</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='lower'>k</span> <span class='lower'>v</span> <span class='keywordsign'>-&#62;</span>
                <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>sync</span> <span class='keywordsign'>(</span><span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>send</span> <span class='lower'>channel</span> <span class='keywordsign'>(</span><span class='constructor module'>Some</span> <span class='keywordsign'>(</span><span class='lower'>k</span><span class='keywordsign'>,</span> <span class='lower'>v</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span> <span class='lower'>coll</span> <span class='keyword'>in</span>
      <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>sync</span> <span class='keywordsign'>(</span><span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>send</span> <span class='lower'>channel</span> <span class='constructor module'>None</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='keyword'>let</span> <span class='lower'>consumer</span> <span class='lower'>i</span> <span class='keywordsign'>=</span>
      <span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>sync</span> <span class='keywordsign'>(</span><span class='constructor module'>Event</span><span class='keywordsign'>.</span><span class='lower'>receive</span> <span class='lower'>channel</span><span class='keywordsign'>)</span> <span class='keyword'>in</span>
    <span class='lower'>ignore</span> <span class='keywordsign'>(</span><span class='constructor module'>Thread</span><span class='keywordsign'>.</span><span class='lower'>create</span> <span class='lower'>producer</span> <span class='keywordsign'>(</span><span class='keywordsign'>)</span><span class='keywordsign'>)</span><span class='keywordsign'>;</span>
    <span class='constructor module'>Stream</span><span class='keywordsign'>.</span><span class='lower'>from</span> <span class='lower'>consumer</span>
</code></pre>
<p>
If we want just the keys, or just the values, it is simple to transform
the output of <code>items</code> using <code>stream_map</code>:</p>
<pre><code class='tryocaml'><span class='keyword'>let</span> <span class='lower'>keys</span> <span class='lower'>iter</span> <span class='lower'>coll</span> <span class='keywordsign'>=</span> <span class='lower'>stream_map</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>(</span><span class='lower'>k</span><span class='keywordsign'>,</span> <span class='lower'>v</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>k</span><span class='keywordsign'>)</span> <span class='keywordsign'>(</span><span class='lower'>items</span> <span class='lower'>iter</span> <span class='lower'>coll</span><span class='keywordsign'>)</span>
<span class='keyword'>let</span> <span class='lower'>values</span> <span class='lower'>iter</span> <span class='lower'>coll</span> <span class='keywordsign'>=</span> <span class='lower'>stream_map</span> <span class='keywordsign'>(</span><span class='keyword'>fun</span> <span class='keywordsign'>(</span><span class='lower'>k</span><span class='keywordsign'>,</span> <span class='lower'>v</span><span class='keywordsign'>)</span> <span class='keywordsign'>-&#62;</span> <span class='lower'>v</span><span class='keywordsign'>)</span> <span class='keywordsign'>(</span><span class='lower'>items</span> <span class='lower'>iter</span> <span class='lower'>coll</span><span class='keywordsign'>)</span>
</code></pre>
<p>
Keep in mind that these techniques spawn producer threads which carry a
few risks: they only terminate when they have finished iterating, and
any change to the original data structure while iterating may produce
unexpected results.</p>
<h2 id="OtherbuiltinStreamfunctions"> Other built-in Stream functions</h2><p>
There are a few other documented methods in the <code>Stream</code> module:</p>
<ul>
 <li>Stream.empty, which raises <code>Stream.Failure</code> unless a stream is empty
 </li>
 <li>Stream.count, which returns the stream count (number of discarded
 elements)</li>
</ul>

<p>In addition, there are a few undocumented functions: <code>iapp</code>, <code>icons</code>,
<code>ising</code>, <code>lapp</code>, <code>lcons</code>, <code>lsing</code>, <code>sempty</code>, <code>slazy</code>, and <code>dump</code>. They
are visible in the interface with the caveat: &quot;For system use only, not
for the casual user&quot;. Some of these functions are used internally by
Camlp4 <a href='stream_expressions.html' title='Stream Expressions'>Stream
Expressions</a>, which are
based on the <code>Stream</code> module as well. In any case, they are best left
alone.</p>

      </div>
    </div>
  </div>
</div>

    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-left">
            <li><a style='cursor:pointer;' onclick="document.getElementById('footer').style.display='none'">[X]</a></li>

            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/tree/master/md-pages/learn/tutorials/streams.md">Edit this page</a></li>
          </ul>
          <ul class="nav pull-right">
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Feedback</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/issues">Contact us</a></li>
            <li><a href="https://github.com/ocamllabs/sandbox-ocaml.org/">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      // <!--
      if(document.getElementsByTagName('pre').length > 0)
         octry('')
      // -->
    </script>
  </body>
</html>
