<!DOCTYPE HTML>

<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title> &ndash; OCaml</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Google Web Fonts -->
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet">
    <link href="http://fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet">
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="/static/css/bootstrap.css" rel="stylesheet" media="screen">
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img src="/static/img/ocaml.png" alt="OCaml"></a>
          <div class="nav-collapse collapse">
                        <ul class="nav">
              <li ><a href="/learn/">Learn</a></li>
              <li ><a href="/docs/">Documentation</a></li>
              <li ><a href="/platform/">Platform</a></li>
              <li ><a href="/list.html">Packages</a></li>
              <li ><a href="/community/">Community</a></li>
            </ul>

            <form class="navbar-search pull-right">
              <input class="search-query" type="text" placeholder="Search" />
            </form>
          </div>
        </div>
      </div>
    </nav>
    
        <div class="container">
      <div class="row">

        <div id="content-primary" class="span8">
          <div class="content">
            <h1 id="CallingClibraries"> Calling C libraries</h1><h2 id="NotefromRich"> Note from Rich</h2><p>

Chapters 12 and 13 really need to be rewritten from scratch.</p>
<p>I&#39;ve left them here - you can read them, but the formatting is screwy.</p>
<h2 id="MiniGtk"> MiniGtk</h2><p>
While the structure of lablgtk outlined in <a href='introduction_to_gtk.html' title='Introduction to Gtk'>Introduction to
Gtk</a> seems perhaps
over-complex, it&#39;s worth considering exactly why the author chose two
layers. To appreciate this, you really need to get your hands dirty and
look at other ways that a Gtk wrapper might have been written.</p>
<p>To this end I played around with something I call
\&lt;dfn\&gt;MiniGtk\&lt;/dfn\&gt;, intended as a simple Gtk wrapper. All MiniGtk is
capable of is opening a window with a label, but after writing MiniGtk I
had renewed respect for the author of lablgtk!</p>
<p>MiniGtk is also a good tutorial for people who want to write OCaml
bindings around their favorite C library. If you&#39;ve ever tried to write
bindings for Perl or Java, you&#39;ll find doing the same for OCaml is
surprisingly easy, although you do have to worry a bit about the garbage
collector.</p>
<p>Let&#39;s talk first about how MiniGtk is structured: rather than using a
two layered approach as with lablgtk, I wanted to implement MiniGtk
using a single (object-oriented) layer. This means that MiniGtk consists
of a bunch of class definitions. Methods in those classes pretty much
directly translate into calls to the C <code>libgtk-1.2.so</code> library.</p>
<p>I also wanted to rationalise the module naming scheme for Gtk. So there
is exactly one top-level module called (surprise!) <code>Gtk</code> and all classes
are inside this module. A test program looks like this:</p>
<pre><code class='ocaml'><script>ml3193b357e8873d640f8c78a18f8e937a = 'let win = new Gtk.window ~title:&#34;My window&#34; ();;\nlet lbl = new Gtk.label ~text:&#34;Hello&#34; ();;\nwin#add lbl;;\n\nlet () =\n  Gtk.main ()\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> win <span class='k'>=</span> <span class='k'>new</span> <span class='m'>Gtk</span><span class='o'>.</span>window <span class='o'>~</span>title<span class='o'>:</span><span class='s'>&#34;My window&#34;</span> ()<span class='o'>;;</span>
<span class='k'>let</span> lbl <span class='k'>=</span> <span class='k'>new</span> <span class='m'>Gtk</span><span class='o'>.</span>label <span class='o'>~</span>text<span class='o'>:</span><span class='s'>&#34;Hello&#34;</span> ()<span class='o'>;;</span>
win<span class='o'>#</span>add lbl<span class='o'>;;</span>

<span class='k'>let</span> () <span class='k'>=</span>
  <span class='m'>Gtk</span><span class='o'>.</span>main ()
</code></pre>
<p>
I defined a single abstract type to cover all <code>GtkObject</code>s (and
&quot;subclasses&quot; of this C structure). In the <code>Gtk</code> module you&#39;ll find this
type definition:</p>
<pre><code class='ocaml'><script>mlff03f45d0d3e2af7747dd4cc616ef251 = 'type obj\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>type</span> obj
</code></pre>
<p>
As discussed in the last chapter, this defines an abstract type of which
it is impossible to create any instances. In OCaml, at least. Certain C
functions are going to create instances of this type. For instance, the
function which creates new labels (ie. <code>GtkLabel</code> structures) is defined
this way:</p>
<pre><code class='ocaml'><script>ml8c2699ff69aa8bb5e39dfdcfe5af66a4 = 'external gtk_label_new : string -&#62; obj = &#34;gtk_label_new_c&#34;\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>external</span> gtk_label_new <span class='o'>:</span> string <span class='k'>-></span> obj <span class='k'>=</span> <span class='s'>&#34;gtk_label_new_c&#34;</span>
</code></pre>
<p>
This strange function definition defines an \&lt;dfn\&gt;external
function\&lt;/dfn\&gt;, one coming from C. The C function is called
<code>gtk_label_new_c</code>, and it takes a string and returns one of our abstract
<code>obj</code> types.</p>
<p>OCaml doesn&#39;t quite let you call <em>any</em> C function yet. You need to write
a little C wrapper around the library&#39;s function to translate to and
from OCaml&#39;s internal types and C types. <code>gtk_label_new_c</code> (note the
additional <code>_c</code>) is my wrapper around the real Gtk C function called
<code>gtk_label_new</code>. Here it is. I&#39;ll explain more about it later.</p>
<pre><code class='ocaml'><script>mlafe2c8c65f4cf1e7f72e732ba2afac9d = 'CAMLprim value\ngtk_label_new_c (value str)\n{\n  CAMLparam1 (str);\n  CAMLreturn (wrap (GTK_OBJECT (\n    gtk_label_new (String_val (str)))));\n }\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span>CAMLprim value
gtk_label_new_c (value str)
<span class='o'>{</span>
  CAMLparam1 (str)<span class='o'>;</span>
  CAMLreturn (wrap (GTK_OBJECT (
    gtk_label_new (String_val (str)))))<span class='o'>;</span>
 <span class='o'>}</span>
</code></pre>
<p>
Before explaining this function further, I&#39;m going to take a step back
and look at the hierarchy of our Gtk classes. I&#39;ve chosen to reflect the
actual Gtk widget hierarchy as closely as possible. All Gtk widgets are
derived from a virtual base class called <code>GtkObject</code>. In fact from this
class is derived <code>GtkWidget</code> and the whole variety of Gtk widgets are
derived from this. So we define our own <code>GtkObject</code> equivalent class
like this (note that <code>object</code> is a reserved word in OCaml).</p>
<pre><code class='ocaml'><script>mle6769ac039930c18d8841ab63f116952 = 'type obj\n\nclass virtual gtk_object (obj : obj) =\nobject (self)\n  val obj = obj\n  method obj = obj\nend\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>type</span> obj

<span class='k'>class</span> <span class='k'>virtual</span> gtk_object (obj <span class='o'>:</span> obj) <span class='k'>=</span>
object (self)
  <span class='k'>val</span> obj <span class='k'>=</span> obj
  <span class='k'>method</span> obj <span class='k'>=</span> obj
<span class='k'>end</span>
</code></pre>
<p>
<code>type obj</code> defines our abstract object type, and <code>class gtk_object</code>
takes one of these &quot;things&quot; as a parameter to its constructor. Recall
from above that this parameter is actually the C <code>GtkObject</code> structure
(in fact it&#39;s a specially wrapped pointer to this structure).</p>
<p>You can&#39;t create <code>gtk_object</code> instances directly because it&#39;s a virtual
class, but if you could you&#39;d have to construct them like this:
<code>new gtk_object obj</code>. What would you pass as that <code>obj</code> parameter? You&#39;d
pass the return value of, for instance, <code>gtk_label_new</code> (go back and
have a look at how that <code>external</code> function was typed). This is shown
below:</p>
<pre><code class='ocaml'><script>ml54f38b2e5ac9e1d365e42f69de3b2ffe = '(* Example code, not really part of MiniGtk! *)\nclass label text =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit gtk_object obj\n  end\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='com2'>(* Example code<span class='ic'>,</span> not really part <span class='ic'>of</span> MiniGtk<span class='ic'>!</span> *)</span><!-- end comment -->
<span class='k'>class</span> label text <span class='k'>=</span>
  <span class='k'>let</span> obj <span class='k'>=</span> gtk_label_new text <span class='k'>in</span>
  object (self)
    <span class='k'>inherit</span> gtk_object obj
  <span class='k'>end</span>
</code></pre>
<p>
Of course the real <code>label</code> class doesn&#39;t inherit directly from
<code>gtk_object</code> as shown above, but in principle this is how it works.</p>
<p>Following the Gtk class hierarchy the only class derived directly from
<code>gtk_object</code> is our <code>widget</code> class, defined like this:</p>
<pre><code class='ocaml'><script>mld1ecba26280191feb851a75326abde25 = 'external gtk_widget_show : obj -&#62; unit = &#34;gtk_widget_show_c&#34;\nexternal gtk_widget_show_all : obj -&#62; unit = &#34;gtk_widget_show_all_c&#34;\n\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    method show = gtk_widget_show obj\n    method show_all = gtk_widget_show_all obj\n    initializer if show &#60;&#62; Some false then self#show\n  end\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>external</span> gtk_widget_show <span class='o'>:</span> obj <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_widget_show_c&#34;</span>
<span class='k'>external</span> gtk_widget_show_all <span class='o'>:</span> obj <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_widget_show_all_c&#34;</span>

<span class='k'>class</span> <span class='k'>virtual</span> widget <span class='o'>?</span>show obj <span class='k'>=</span>
  object (self)
    <span class='k'>inherit</span> gtk_object obj
    <span class='k'>method</span> show <span class='k'>=</span> gtk_widget_show obj
    <span class='k'>method</span> show_all <span class='k'>=</span> gtk_widget_show_all obj
    <span class='k'>initializer</span> <span class='k'>if</span> show <span class='o'>&#60;&#62;</span> Some <span class='o'>false</span> <span class='k'>then</span> self<span class='o'>#</span>show
  <span class='k'>end</span>
</code></pre>
<p>
This class is considerably more complex. Let&#39;s look at the
initialization code first:</p>
<pre><code class='ocaml'><script>mlb526215506ff991258b3e05990e59bc0 = 'class virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    initializer\n      if show &#60;&#62; Some false then self#show\n  end\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>class</span> <span class='k'>virtual</span> widget <span class='o'>?</span>show obj <span class='k'>=</span>
  object (self)
    <span class='k'>inherit</span> gtk_object obj
    <span class='k'>initializer</span>
      <span class='k'>if</span> show <span class='o'>&#60;&#62;</span> Some <span class='o'>false</span> <span class='k'>then</span> self<span class='o'>#</span>show
  <span class='k'>end</span>
</code></pre>
<p>
The <code>initializer</code> section may well be new to you. This is code which
runs when an object is being created - the equivalent of a constructor
in other languages. In this case we check the boolean optional <code>show</code>
argument and unless the user specified it explicitly as <code>false</code> we
automatically call the <code>#show</code> method. (All Gtk widgets need to be
&quot;shown&quot; after being created unless you want a widget to be created but
hidden).</p>
<p>The actual definition of the methods happens with the help of a couple
of external functions. These are basically direct calls to the C library
(well, in fact there&#39;s a tiny bit of wrapper code, but that&#39;s not
functionally important).</p>
<pre><code class='ocaml'><script>mlbf69d2f8afeb49cf475396235a8242d3 = 'method show = gtk_widget_show obj\nmethod show_all = gtk_widget_show_all obj\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>method</span> show <span class='k'>=</span> gtk_widget_show obj
<span class='k'>method</span> show_all <span class='k'>=</span> gtk_widget_show_all obj
</code></pre>
<p>
Notice that we pass the underlying <code>GtkObject</code> to both C library calls.
This makes sense because these functions are prototyped as
<code>void gtk_widget_show (GtkWidget *);</code> in C (<code>GtkWidget</code> and <code>GtkObject</code>
are safely used interchangably in this context).</p>
<p>I want to describe the <code>label</code> class (the real one this time!), but in
between <code>widget</code> and <code>label</code> is <code>misc</code>, a generic class which describes
a large class of miscellaneous widgets. This class just adds padding and
alignment around a widget such as a label. Here is its definition:</p>
<pre><code class='ocaml'><script>ml6579196c43bee2501a2521d1d1b58bdd = 'let may f x =\n  match x with\n  | None -&#62; ()\n  | Some x -&#62; f x\n\nexternal gtk_misc_set_alignment :\n  obj -&#62; float * float -&#62; unit = &#34;gtk_misc_set_alignment_c&#34;\nexternal gtk_misc_set_padding :\n  obj -&#62; int * int -&#62; unit = &#34;gtk_misc_set_padding_c&#34;\n\nclass virtual misc ?alignment ?padding ?show obj =\n  object (self)\n    inherit widget ?show obj\n    method set_alignment = gtk_misc_set_alignment obj\n    method set_padding = gtk_misc_set_padding obj\n    initializer\n      may (gtk_misc_set_alignment obj) alignment;\n      may (gtk_misc_set_padding obj) padding\n  end\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>let</span> may f x <span class='k'>=</span>
  <span class='k'>match</span> x <span class='k'>with</span>
  <span class='o'>|</span> None <span class='k'>-></span> ()
  <span class='o'>|</span> Some x <span class='k'>-></span> f x

<span class='k'>external</span> gtk_misc_set_alignment <span class='o'>:</span>
  obj <span class='k'>-></span> float <span class='o'>*</span> float <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_misc_set_alignment_c&#34;</span>
<span class='k'>external</span> gtk_misc_set_padding <span class='o'>:</span>
  obj <span class='k'>-></span> int <span class='o'>*</span> int <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_misc_set_padding_c&#34;</span>

<span class='k'>class</span> <span class='k'>virtual</span> misc <span class='o'>?</span>alignment <span class='o'>?</span>padding <span class='o'>?</span>show obj <span class='k'>=</span>
  object (self)
    <span class='k'>inherit</span> widget <span class='o'>?</span>show obj
    <span class='k'>method</span> set_alignment <span class='k'>=</span> gtk_misc_set_alignment obj
    <span class='k'>method</span> set_padding <span class='k'>=</span> gtk_misc_set_padding obj
    <span class='k'>initializer</span>
      may (gtk_misc_set_alignment obj) alignment<span class='o'>;</span>
      may (gtk_misc_set_padding obj) padding
  <span class='k'>end</span>
</code></pre>
<p>
We start with a helper function called
<code>may : (&#39;a -&gt; unit) -&gt; &#39;a option -&gt; unit</code> which invokes its first
argument on the contents of its second unless the second argument is
<code>None</code>. This trick (stolen from lablgtk of course) is very useful when
dealing with optional arguments as we&#39;ll see.</p>
<p>The methods in <code>misc</code> should be straightforward. What is tricky is the
initialization code. First notice that we take optional <code>alignment</code> and
<code>padding</code> arguments to the constructor, and we pass the optional <code>show</code>
and mandatory <code>obj</code> arguments directly up to <code>widget</code>. What do we do
with the optional <code>alignment</code> and <code>padding</code>? The initializer uses these:</p>
<pre><code class='ocaml'><script>ml17a969a3343a8e2394d067276ad3b840 = 'initializer\n  may (gtk_misc_set_alignment obj) alignment;\n  may (gtk_misc_set_padding obj) padding \n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>initializer</span>
  may (gtk_misc_set_alignment obj) alignment<span class='o'>;</span>
  may (gtk_misc_set_padding obj) padding 
</code></pre>
<p>
It&#39;s that tricky <code>may</code> function in action. <em>If</em> the user gave an
<code>alignment</code> argument, then this will set the alignment on the object by
calling <code>gtk_misc_set_alignment obj the_alignment</code>. But more commonly
the user will omit the <code>alignment</code> argument, in which case <code>alignment</code>
is <code>None</code> and this does nothing. (In effect we get Gtk&#39;s default
alignment, whatever that is). A similar thing happens with the
<code>padding</code>. Note there is a certain simplicity and elegance in the way
this is done.</p>
<p>Now we can finally get to the <code>label</code> class, which is derived directly
from <code>misc</code>:</p>
<pre><code class='ocaml'><script>ml4d6af60e21a26dbe7dd8f764e77d5b22 = 'external gtk_label_new :\n    string -&#62; obj  = &#34;gtk_label_new_c&#34;\nexternal gtk_label_set_text :\n    obj -&#62; string -&#62; unit = &#34;gtk_label_set_text_c&#34;\nexternal gtk_label_set_justify :\n    obj -&#62; Justification.t -&#62; unit = &#34;gtk_label_set_justify_c&#34;\nexternal gtk_label_set_pattern :\n    obj -&#62; string -&#62; unit = &#34;gtk_label_set_pattern_c&#34;\nexternal gtk_label_set_line_wrap :\n    obj -&#62; bool -&#62; unit = &#34;gtk_label_set_line_wrap_c&#34;\n\nclass label ~text\n  ?justify ?pattern ?line_wrap ?alignment\n  ?padding ?show () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ?alignment ?padding ?show obj\n    method set_text = gtk_label_set_text obj\n    method set_justify = gtk_label_set_justify obj\n    method set_pattern = gtk_label_set_pattern obj\n    method set_line_wrap = gtk_label_set_line_wrap obj\n    initializer\n      may (gtk_label_set_justify obj) justify;\n      may (gtk_label_set_pattern obj) pattern;\n      may (gtk_label_set_line_wrap obj) line_wrap\n  end\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>external</span> gtk_label_new <span class='o'>:</span>
    string <span class='k'>-></span> obj  <span class='k'>=</span> <span class='s'>&#34;gtk_label_new_c&#34;</span>
<span class='k'>external</span> gtk_label_set_text <span class='o'>:</span>
    obj <span class='k'>-></span> string <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_label_set_text_c&#34;</span>
<span class='k'>external</span> gtk_label_set_justify <span class='o'>:</span>
    obj <span class='k'>-></span> <span class='m'>Justification</span><span class='o'>.</span>t <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_label_set_justify_c&#34;</span>
<span class='k'>external</span> gtk_label_set_pattern <span class='o'>:</span>
    obj <span class='k'>-></span> string <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_label_set_pattern_c&#34;</span>
<span class='k'>external</span> gtk_label_set_line_wrap <span class='o'>:</span>
    obj <span class='k'>-></span> bool <span class='k'>-></span> unit <span class='k'>=</span> <span class='s'>&#34;gtk_label_set_line_wrap_c&#34;</span>

<span class='k'>class</span> label <span class='o'>~</span>text
  <span class='o'>?</span>justify <span class='o'>?</span>pattern <span class='o'>?</span>line_wrap <span class='o'>?</span>alignment
  <span class='o'>?</span>padding <span class='o'>?</span>show () <span class='k'>=</span>
  <span class='k'>let</span> obj <span class='k'>=</span> gtk_label_new text <span class='k'>in</span>
  object (self)
    <span class='k'>inherit</span> misc <span class='o'>?</span>alignment <span class='o'>?</span>padding <span class='o'>?</span>show obj
    <span class='k'>method</span> set_text <span class='k'>=</span> gtk_label_set_text obj
    <span class='k'>method</span> set_justify <span class='k'>=</span> gtk_label_set_justify obj
    <span class='k'>method</span> set_pattern <span class='k'>=</span> gtk_label_set_pattern obj
    <span class='k'>method</span> set_line_wrap <span class='k'>=</span> gtk_label_set_line_wrap obj
    <span class='k'>initializer</span>
      may (gtk_label_set_justify obj) justify<span class='o'>;</span>
      may (gtk_label_set_pattern obj) pattern<span class='o'>;</span>
      may (gtk_label_set_line_wrap obj) line_wrap
  <span class='k'>end</span>
</code></pre>
<p>
Although this class is bigger than the ones we&#39;ve looked at up til now,
it&#39;s really more of the same idea, <em>except</em> that this class isn&#39;t
virtual. You can create instances of this class which means it finally
has to call <code>gtk_..._new</code>. This is the initialization code (we discussed
this pattern above):</p>
<pre><code class='ocaml'><script>ml5fb0e76ef5c586ff60290228e371bfaf = 'class label ~text ... () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ... obj\n  end\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>class</span> label <span class='o'>~</span>text <span class='o'>...</span> () <span class='k'>=</span>
  <span class='k'>let</span> obj <span class='k'>=</span> gtk_label_new text <span class='k'>in</span>
  object (self)
    <span class='k'>inherit</span> misc <span class='o'>...</span> obj
  <span class='k'>end</span>
</code></pre>
<p>
(Pop quiz: what happens if we need to define a class which is both a
base class from which other classes can be derived, and is also a
non-virtual class of which the user should be allowed to create
instances?)</p>
<h4 id="WrappingcallstoClibraries"> Wrapping calls to C libraries</h4><p>
Now we&#39;ll look in more detail at actually wrapping up calls to C library
functions. Here&#39;s a simple example:</p>
<pre><code class='ocaml'><script>ml19b3bdede4695d890c8ae9e54aab30b5 = '/* external gtk_label_set_text :\n     obj -&#62; string -&#62; unit\n       = &#34;gtk_label_set_text_c&#34; */\n\nCAMLprim value\ngtk_label_set_text_c (value obj, value str)\n{\n  CAMLparam2 (obj, str);\n  gtk_label_set_text (unwrap (GtkLabel, obj),\n    String_val (str));\n  CAMLreturn (Val_unit);\n}\n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='o'>/*</span> <span class='k'>external</span> gtk_label_set_text <span class='o'>:</span>
     obj <span class='k'>-></span> string <span class='k'>-></span> unit
       <span class='k'>=</span> <span class='s'>&#34;gtk_label_set_text_c&#34;</span> <span class='o'>*/</span>

CAMLprim value
gtk_label_set_text_c (value obj<span class='o'>,</span> value str)
<span class='o'>{</span>
  CAMLparam2 (obj<span class='o'>,</span> str)<span class='o'>;</span>
  gtk_label_set_text (unwrap (GtkLabel<span class='o'>,</span> obj)<span class='o'>,</span>
    String_val (str))<span class='o'>;</span>
  CAMLreturn (Val_unit)<span class='o'>;</span>
<span class='o'>}</span>
</code></pre>
<p>
Comparing the OCaml prototype for the external function call (in the
comment) with the definition of the function we can see two things:</p>
<ul>
 <li>The C function that OCaml calls is named <code>&quot;gtk_label_set_text_c&quot;</code>.
 </li>
 <li>Two arguments are passed (<code>value obj</code> and <code>value str</code>) and a unit is
 returned.</li>
</ul>

<p>Values are OCaml&#39;s internal representation of all sorts of things from
simple integers through to strings and even objects. I&#39;m not going to go
into any great detail about the <code>value</code> type because it is more than
adequately covered in the OCaml manual. To use <code>value</code> you need to just
know what macros are available to convert between a <code>value</code> and some C
type. The macros look like this:</p>
<p>\&lt;dl\&gt; \&lt;dt\&gt;<code>String_val (val)</code>\&lt;/dt\&gt; \&lt;dd\&gt; Convert from a <code>value</code>
which is known to be a string to a C string (ie. <code>char *</code>). \&lt;/dd\&gt;
\&lt;dt\&gt;<code>Val_unit</code>\&lt;/dt\&gt; \&lt;dd\&gt; The OCaml unit <code>()</code> as a <code>value</code>. \&lt;/dd\&gt;
\&lt;dt\&gt;<code>Int_val (val)</code>\&lt;/dt\&gt; boolean \&lt;dd\&gt; Convert from a <code>value</code> which
is known to be an integer to a C <code>int</code>. \&lt;/dd\&gt;
\&lt;dt\&gt;<code>Val_int (i)</code>\&lt;/dt\&gt; \&lt;dd\&gt; Convert from a C integer <code>i</code> into an
integer <code>value</code>. \&lt;/dd\&gt; \&lt;dt\&gt;<code>Bool_val (val)</code>\&lt;/dt\&gt; \&lt;dd\&gt; Convert
from a <code>value</code> which is known to be a boolean to a C boolean (ie. an
<code>int</code>). \&lt;/dd\&gt; \&lt;dt\&gt;<code>Val_bool (i)</code>\&lt;/dt\&gt; \&lt;dd\&gt; Convert from a C
integer <code>i</code> into a boolean <code>value</code>. \&lt;/dd\&gt; \&lt;/dl\&gt;</p>
<p>You can guess the others or consult the manual. Note that there is no
straightforward conversion from C <code>char *</code> to a value. This involves
allocating memory, which is somewhat more complicated.</p>
<p>In <code>gtk_label_set_text_c</code> above, the <code>external</code> definition, plus strong
typing and type inference, has already ensured that the arguments are of
the correct type, so to convert <code>value str</code> to a C <code>char *</code> we called
<code>String_val (str)</code>.</p>
<p>The other parts of the function are a bit stranger. To ensure that the
garbage collector &quot;knows&quot; that your C function is still using <code>obj</code> and
<code>str</code> while the C function is running (remember that the garbage
collector might be triggered within your C function by a number of
events - a callback to OCaml or using one of OCaml&#39;s allocation
functions), you need to frame the function to add code to tell the
garbage collector about the &quot;roots&quot; that you&#39;re using. And tell the
garbage collector when you finish using those roots too, of course. This
is done by framing the function within <code>CAMLparamN</code> ... <code>CAMLreturn</code>.
Hence:</p>
<pre><code class='ocaml'><script>mleca80fd00d52ac071660e68221f482e5 = 'CAMLparam2 (obj, str);\n...\nCAMLreturn (Val_unit); \n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span>CAMLparam2 (obj<span class='o'>,</span> str)<span class='o'>;</span>
<span class='o'>...</span>
CAMLreturn (Val_unit)<span class='o'>;</span> 
</code></pre>
<p>
<code>CAMLparam2</code> is a macro saying that you&#39;re using two <code>value</code> parameters.
(There is another macro for annotating local <code>value</code> variables too). You
need to use <code>CAMLreturn</code> instead of plain <code>return</code> which tells the GC
you&#39;ve finished with those roots. It might be instructive to examine
what code is inlined when you write <code>CAMLparam2 (obj, str)</code>. This is the
generated code (with the author&#39;s version of OCaml, so it might vary
between implementations slightly):</p>
<pre><code class='ocaml'><script>ml43e4efa419be7fd56e758cb8ee39e733 = 'struct caml__roots_block *caml__frame\n    = local_roots;\nstruct caml__roots_block caml__roots_obj;\n\ncaml__roots_obj.next = local_roots;\nlocal_roots = &#38;caml__roots_obj;\ncaml__roots_obj.nitems = 1;\ncaml__roots_obj.ntables = 2;\ncaml__roots_obj.tables [0] = &#38;obj;\ncaml__roots_obj.tables [1] = &#38;str; \n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span><span class='k'>struct</span> caml__roots_block <span class='o'>*</span>caml__frame
    <span class='k'>=</span> local_roots<span class='o'>;</span>
<span class='k'>struct</span> caml__roots_block caml__roots_obj<span class='o'>;</span>

caml__roots_obj<span class='o'>.</span>next <span class='k'>=</span> local_roots<span class='o'>;</span>
local_roots <span class='k'>=</span> <span class='o'>&#38;</span>caml__roots_obj<span class='o'>;</span>
caml__roots_obj<span class='o'>.</span>nitems <span class='k'>=</span> 1<span class='o'>;</span>
caml__roots_obj<span class='o'>.</span>ntables <span class='k'>=</span> 2<span class='o'>;</span>
caml__roots_obj<span class='o'>.</span>tables <span class='o'>[</span>0<span class='o'>]</span> <span class='k'>=</span> <span class='o'>&#38;</span>obj<span class='o'>;</span>
caml__roots_obj<span class='o'>.</span>tables <span class='o'>[</span>1<span class='o'>]</span> <span class='k'>=</span> <span class='o'>&#38;</span>str<span class='o'>;</span> 
</code></pre>
<p>
And for <code>CAMLreturn (foo)</code>:</p>
<pre><code class='ocaml'><script>ml58bd4d636216107f57b1deacaabb49fd = 'local_roots = caml__frame;\nreturn (foo); \n'; function copytoclipboard(s){}</script><span style='position:relative;top:-1em;'><span onclick='alert("not yet implemented")'>[try]</span><span onclick='alert("not yet implemented")'>[copy]</span><span onclick='alert("not yet implemented")'>[github]</span></span>local_roots <span class='k'>=</span> caml__frame<span class='o'>;</span>
return (foo)<span class='o'>;</span> 
</code></pre>
<p>
If you follow the code closely you&#39;ll see that <code>local_roots</code> is
obviously a linked list of <code>caml__roots_block</code> structures. One (or more)
of these structures is pushed onto the linked list when we enter the
function, and all of these are popped back off when we leave, thus
restoring <code>local_roots</code> to its previous state when we leave the
function. (<em>If</em> you remembered to call <code>CAMLreturn</code> instead of <code>return</code>
of course - otherwise <code>local_roots</code> will end up pointing at
uninitialised data on the stack with &quot;hilarious&quot; consequences).</p>
<p>Each <code>caml__roots_block</code> structure has space for up to five <code>value</code>s
(you can have multiple blocks, so this isn&#39;t a limitation). When the GC
runs we can infer that it must walk through the linked list, starting at
<code>local_roots</code>, and treat each <code>value</code> as a root for garbage collection
purposes. The consequences of <em>not</em> declaring a <code>value</code> parameter or
local <code>value</code> variable in this way would be that the garbage collector
might treat that variable as unreachable memory and thus reclaim it
while your function is running!</p>
<p><code>CAMLprim</code> is a Windows-only thing and so we won&#39;t talk about it ...</p>
<p>Finally there is the mysterious <code>unwrap</code> macro. This is one I wrote
myself, or rather, this is one I mostly copied from lablgtk. There are
two related functions, called <code>wrap</code> and <code>unwrap</code> and as you might
possibly have guessed, they wrap and unwrap <code>GtkObject</code>s in OCaml
<code>value</code>s. These functions establish the somewhat magical relationship
between <code>GtkObject</code> and our opaque, mysterious <code>obj</code> type which we
defined for OCaml (see the very first part of this chapter to remind
yourself).</p>
<p>The problem is how do we wrap up (and hide) the C <code>GtkObject</code> structure
in a way that we can pass it around as an opaque &quot;thing&quot; (<code>obj</code>) through
our OCaml code, and hopefully pass it back later to a C function which
can unwrap it and retrieve the same <code>GtkObject</code> back again?</p>
<p>In order for it to get passed to OCaml code at all, we must somehow
convert it to a <code>value</code>. Luckily we can quite easily use the C API to
create <code>value</code> blocks which the OCaml garbage collector <em>won&#39;t</em> examine
too closely ......</p>

          </div>
        </div>
      </div>
    </div>
    <footer id="footer" class="navbar navbar-inverse navbar-fixed-bottom">
      <div class="navbar-inner">
        <div class="container-fluid">
          <ul class="nav pull-right">
            <li><a href="#">Feedback</a></li>
            <li><a href="#">Contact us</a></li>
            <li><a href="#">Find us on GitHub</a></li>
          </ul>
        </div>
      </div>
    </footer>
    <!-- Load javascript from CDN -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
  </body>
</html>
